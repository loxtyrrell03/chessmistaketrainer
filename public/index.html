<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Personal Chess Mistake Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="icon" href="/logo.jpg" />
  <script>
    // Replace mojibake em/en dash sequences that can appear as "—" / "–"
    (function(){
      function sanitizeNodeText(root){
        try{
          var walker = document.createTreeWalker(root || document.body, NodeFilter.SHOW_TEXT);
          var node;
          while((node = walker.nextNode())){
            var t = node.nodeValue;
            if(!t) continue;
            var nt = t.replace(/—/g, '-').replace(/–/g, '-');
            if(nt !== t) node.nodeValue = nt;
          }
        }catch{}
      }
      document.addEventListener('DOMContentLoaded', function(){
        sanitizeNodeText(document.body);
        try{
          var mo = new MutationObserver(function(muts){
            for(var i=0;i<muts.length;i++){
              var m = muts[i];
              if(m.type==='childList'){
                m.addedNodes && m.addedNodes.forEach && m.addedNodes.forEach(function(n){
                  if(n && n.nodeType===1) sanitizeNodeText(n);
                  else if(n && n.nodeType===3) sanitizeNodeText(n.parentNode||document.body);
                });
              } else if(m.type==='characterData'){
                sanitizeNodeText(m.target.parentNode||document.body);
              }
            }
          });
          mo.observe(document.body, { childList:true, subtree:true, characterData:true });
        }catch{}
      });
    })();
  try{ window.EngineLive = EngineLive; }catch{}
  </script>
  <!--
    Personal Chess Mistake Trainer (single-file app)

    ? Single HTML file: all HTML, CSS, and JS are inline (one file only).
    ? Works offline once loaded (except for fetching online games).
    ? No frameworks used.

    This build addresses your latest requests:
      • Board-size slider works even in fullscreen (width uses min(100%, var(--board-size))).
      • Black pieces are truly black; forced non-emoji (solid) glyphs.
      • Added "Show mistake" button; shows red arrow for the played mistake; clears on Reveal Best or on move.
      • Dragging shows legal-move dots; removed dotted/focus square when dragging/lifting.
      • Imports stack across sources (Lichess + Chess.com + Manual) and analyse runs over the full stack.
      • Stop analysis immediately resets the button; partial results still saved and a set is created if >0 mistakes.

    MIT-style: extend/adapt freely.
  -->
  <style>
    :root{
      /* Layout (white, logo-like background) */
      --bg:#fdfcf9;      /* near-white */
      --panel:#ffffff;   /* pure white panels */
      --card:#ffffff;    /* pure white cards */
      --text:#1f1b16;    /* warm near-black */
      --muted:#7f776c;   /* soft warm grey */
      --acc:#d14b3a;     /* terracotta/red from logo */
      --good:#2f9e44;    /* keep green for success */
      --bad:#e0523f;     /* error close to accent */
      --warn:#d9a441;    /* warm amber */
      --border:#ece7df;  /* very light border */

      /* Board look (wood + cream) */
      --sq-light:#e8d5b7;
      --sq-dark:#b88a58;
      --sq-hl:#ffd54f;
      --sq-sel:#7bdff6;
      --arrow-user:#e0523f; /* red (logo) */
      --arrow-best:#2f9e44; /* green */

      /* Train sizing */
      --board-size: 520px; /* main board target width */
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    h1,h2,h3{margin:0 0 .5rem}
    a{color:var(--acc);text-decoration:none}
    .wrap{max-width:1100px;margin:0 auto;padding:18px}

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:18px;
    }

    /* Train page grid (fixed split; pane-split slider removed) */
    .train-grid{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:18px;
    }

    /* Training view layout: hide sets pane; keep board left + info right */
    #trainSection.training-mode .train-grid{ grid-template-columns:1fr; }
    /* Always hide the Sets panel on the Train page */
    #trainSection .train-grid > .card:nth-of-type(2){ display:none !important; }
    /* Also hide any card that contains the Train Sets table anywhere */
    .card:has(#trainSetsTBody),
    .card:has(#activeSetInfo),
    .card:has(#btnStart){ display:none !important; }
    /* Hide the top select-a-set panel while training */
    #trainSection.training-mode #trainSelectView{ display:none; }
    /* Show only selection view when not training */
    #trainSection:not(.training-mode) .train-grid{ display:none; }
    .train-center{ display:flex; flex-direction:column; align-items:center; gap:12px }
    .train-block{ width:min(100%, var(--board-size)); margin:0 auto }
    /* Expandable 1-line fields (FEN/PGN) */
    .exp-field{ position:relative }
    .exp-field .exp-label{ display:block; font-weight:600; margin-bottom:4px }
    .exp-field .exp-collapsed{ cursor:pointer; user-select:text; width:100%; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; padding:6px 8px; border:1px dashed var(--border); border-radius:8px; background:var(--panel); font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace; color:var(--muted) }
    .exp-field .exp-panel{ display:none; position:absolute; inset:auto 0 0 0; transform:translateY(4px); z-index:6; background:var(--panel); border:1px solid var(--border); border-radius:10px; box-shadow:0 6px 18px rgba(0,0,0,.08); padding:8px }
    .exp-field.open .exp-panel{ display:block }
    .exp-field .exp-text{ width:100%; min-height:140px; resize:vertical; background:var(--card); color:var(--text); border:1px solid var(--border); border-radius:8px; padding:8px; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace }
    .exp-field .copy-btn{ position:absolute; right:12px; bottom:12px }
    /* Keep current-mistake action buttons on one row; reveal on full row below */
    .mistake-actions{ display:flex; gap:8px; align-items:center; flex-wrap:nowrap; white-space:nowrap }
    .mistake-actions > button{ flex:0 0 auto }
    .mistake-reveal-row{ display:block }
    .mistake-reveal-row > #btnReveal{ display:block; width:100% }
    .mistake-actions-wrap{ display:inline-grid; grid-template-columns: max-content }
    /* Size right panel to content width (actions) */
    #trainRightCol{ width: max-content }
    /* Keep current-mistake action buttons on one row */
    .mistake-actions{ display:flex; gap:8px; align-items:center; flex-wrap:nowrap; white-space:nowrap }
    .mistake-actions > button{ flex:0 0 auto }

    /* Hide training legend badges */
    #trainSection .legend.tiny{ display:none !important; }

    /* Toggle switch for engine */
    .switch{ position:relative; display:inline-block; width:44px; height:24px; vertical-align:middle }
    .switch input{ opacity:0; width:0; height:0 }
    .slider{ position:absolute; cursor:pointer; inset:0; background:#3a445a; transition:.2s; border-radius:24px }
    .slider:before{ content:""; position:absolute; height:18px; width:18px; left:3px; bottom:3px; background:#fff; transition:.2s; border-radius:50% }
    .switch input:checked + .slider{ background:var(--acc) }
    .switch input:checked + .slider:before{ transform:translateX(20px) }

    /* Compact toggle specifically for Engine panel */
    #enginePanel .switch{ width:32px; height:20px }
    #enginePanel .slider:before{ width:14px; height:14px; left:3px; bottom:3px }
    /* When ON, knob travels flush to the right edge */
    #enginePanel .switch input:checked + .slider:before{ transform:translateX(15px) }

    /* Engine arrow color (warm teal for contrast) */
    :root{ --arrow-engine:#0fb5a8 }

    @media (max-width:1000px){
      .grid, .train-grid{grid-template-columns:1fr}
    }

    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:14px;
      box-shadow:0 8px 24px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.02);
    }
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .row > *{flex:1}
    label{display:block;margin:.25rem 0 .35rem;color:var(--muted);font-size:.85rem}
    input[type="text"], textarea, select, input[type="number"], input[type="range"]{
      width:100%;background:var(--panel);border:1px solid var(--border);color:var(--text);
      border-radius:10px;padding:10px 12px;font-size:14px;outline:none;
    }
    input[type="range"]{padding:6px 8px}
    textarea{min-height:120px;resize:vertical}
    /* Input with prefix (e.g., 'chess.com/' inside the field) */
    .input-prefix{display:flex;align-items:center;background:var(--panel);border:1px solid var(--border);color:var(--text);border-radius:10px}
    .input-prefix .prefix{padding:10px 10px;color:var(--muted);border-right:1px solid var(--border);white-space:nowrap}
    .input-prefix input{flex:1;background:transparent;border:0;color:var(--text);padding:10px 12px;outline:none}

    button{
      appearance:none;border:0;background:var(--acc);color:white;
      padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;
      box-shadow:0 6px 18px rgba(209,75,58,.25)
    }
    button.secondary{background:var(--border);box-shadow:none}
    button.ghost{background:transparent;border:1px solid var(--border);color:var(--text)}
    .btn-green{background:var(--good)}
    .btn-red{background:var(--bad)}
    .muted{color:var(--muted)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
    .small{font-size:.9rem}
    .tiny{font-size:.8rem}
    .success{color:var(--good)}
    .danger{color:var(--bad)}
    .warn{color:var(--warn)}
    .right{float:right}

    /* Board containers */
    .board-wrap{display:flex;gap:14px;align-items:flex-start}
    .board{
      /* board width controlled via --board-size; stays square */
      width: min(100%, var(--board-size));
      aspect-ratio:1 / 1; /* always square */
      background:transparent; border-radius:0; overflow:hidden; border:0; position:relative
    }
    /* Evaluation bar (left of main board) */
    .eval-bar{ width:14px; border-radius:10px; overflow:hidden; border:1px solid var(--border); background:var(--panel); flex:0 0 14px; display:none; position:relative }
    .eval-bar .eval-fill{ position:absolute; left:0; right:0; bottom:0; height:50%; background:#f5f5f5 }
    .eval-bar .tick{ position:absolute; left:0; right:0; top:50%; height:1px; background:var(--border); opacity:.6 }
    /* Cursor hint when hovering near corner */
    .board.resize-corner-hover{ cursor:nwse-resize; }
    /* Drag handle for resizing the main board */
    .resize-handle{
      /* Hidden visual handle; resize still works via corner hover/drag */
      display:none !important;
    }
    /* Game Viewer mini board: fills available width responsively (no cramping) */
    .board-mini{
      width:100%;
      max-width:540px;
      aspect-ratio:1 / 1;
      background:transparent;border-radius:12px;overflow:hidden;border:1px solid #c7cdd8;position:relative
    }

    /* Ensure chessboard.js containers fill their wrappers */
    #board, #gvBoard, #statsBoard{ width:100%; height:100%; }
    /* Legacy custom grid (no longer used for main rendering) */
    .grid8{ display:grid; grid-template-columns:repeat(8, minmax(0,1fr)); grid-template-rows:repeat(8, minmax(0,1fr)); width:100%; height:100%; contain: content; }
    .sq{
      display:flex;align-items:center;justify-content:center;
      user-select:none;position:relative;transition:background .08s ease;
      overflow:hidden; /* if glyph gets large, don't distort grid */
      font-size:var(--cell-font, 36px); /* set by JS per board size */
    }
    .sq.light{background:var(--sq-light)}
    .sq.dark{background:var(--sq-dark)}
    /* coords removed */
    .sq.hint::after{
      content:"";position:absolute;width:26%;height:26%;border-radius:50%;
      background:rgba(0,0,0,.25)
    }
    .sq.sel{outline:3px solid var(--sq-sel);z-index:2}
    .sq.hl{outline:3px solid var(--sq-hl)}

    /* Crisp readable pieces — force monochrome (non-emoji) solid glyphs */
    .piece{
      filter:drop-shadow(0 2px 2px rgba(0,0,0,.25));
      opacity:1 !important; font-weight:900; letter-spacing:0;
      pointer-events:auto;
      /* Prefer symbol fonts, force text presentation to avoid color/emoji glyphs (purple pawns etc.) */
      font-family:"Noto Sans Symbols 2","DejaVu Sans","Segoe UI Symbol","Symbola","Noto Sans","Arial Unicode MS",system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,Arial;
      font-variant-emoji:text;
    }
    .piece.w{color:#ffffff;text-shadow:0 1px 0 #000, 0 0 4px rgba(0,0,0,.5)}
    .piece.b{color:#111111;text-shadow:0 1px 0 #ffffff, 0 0 3px rgba(255,255,255,.15)} /* true black */

    /* Remove dotted focus rectangles when dragging/lifting */
    .sq:focus, .piece:focus { outline: none; }
    .sq, .piece { -webkit-tap-highlight-color: transparent; }

    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .legend span{padding:4px 8px;background:var(--panel);border-radius:999px;border:1px solid var(--border)}
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width:800px){
      .board-wrap{flex-direction:column}
    }

    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px dashed var(--border);text-align:left;vertical-align:top}
    th{color:var(--muted);font-weight:600}
    tr:hover td{background:#121622}
    tr.selected td{background:#1a2233}

    .bar{height:140px;background:#121622;border-radius:10px;margin-top:8px;position:relative}
    .bar canvas{width:100%;height:100%}

    .pill{padding:2px 8px;border-radius:999px;font-weight:700;font-size:.75rem}
    .pill.inacc{background:#264f2f;color:#a2f5be;border:1px solid #2f9e44}
    .pill.mist{background:#5b4a27;color:#ffe8a1;border:1px solid #f2c94c}
     .pill.blun{background:#4f1e24;color:#ffb3bd;border:1px solid #ff6b6b}
     .stroke{border:1px dashed var(--border);border-radius:10px;padding:10px}
     /* Move list styles */
     #moveList .mv{ cursor:pointer; padding:2px 4px; border-radius:6px; display:inline-block; }
     #moveList .mv:hover{ background:#121622; }
     #moveList .mv.active{ background:#1a2233; color:#fff; }
     #moveList .num{ color:var(--muted); margin-right:2px; min-width:2ch; text-align:right; display:inline-block; }
     #moveList .ml-table{ width:100%; border-collapse:collapse; table-layout:fixed; }
     #moveList .ml-table td{ border:1px dashed var(--border); padding:2px 4px; vertical-align:top; white-space:nowrap; overflow:hidden; text-overflow:ellipsis; }
     #moveList .cell{ display:flex; align-items:center; gap:4px; min-width:0; }
     /* Make move list panel wider to fit SAN without truncation */
     #movesCol{ width:360px; }
     #moveListPanel{ max-width:360px; }
   </style>
  <!-- chessboard.js CSS (local) -->
  <link rel="stylesheet" href="/chessboardjs/css/chessboard-1.0.0.min.css" />
  <style>
    .topnav{background:var(--panel);border-bottom:1px solid var(--border);position:sticky;top:0;z-index:5}
    .topnav .navwrap{max-width:1100px;margin:0 auto;display:flex;gap:12px;align-items:center;padding:10px 18px}
    .brand{display:flex;align-items:center;gap:8px;font-weight:700;color:var(--text)}
    .brand .logo{height:28px;width:auto;border-radius:6px;display:block}
    .topnav a{color:#5b4638;padding:6px 10px;border-radius:8px}
    .topnav a.active{background:var(--border);color:var(--text)}
    .section{display:none}
    .section.active{display:block}

    /* Last-move highlight for chessboard.js squares */
    #board [data-square].last-move,
    #gvBoard [data-square].last-move,
    #statsBoard [data-square].last-move{
      /* slightly transparent yellow to reduce intensity */
      background: rgba(255, 213, 79, 0.6) !important;
    }
    /* Prevent native browser drag on chessboard piece images */
    #board img, #gvBoard img, #statsBoard img {
      -webkit-user-drag: none; /* vendor-prefixed; JS handler also prevents native drag */
    }
  </style>
</head>
<body>
  <div class="topnav">
    <div class="navwrap">
      <a href="#" id="brandHome" class="brand" title="Home"><img class="logo" src="/logo.jpg" alt="PMT logo" /><span>PMT</span></a>
      <a href="#" data-sec="home" id="navHome" class="active">Home</a>
      <a href="#" data-sec="analyze" id="navAnalyze">Import</a>
      <a href="#" data-sec="stats" id="navStats">Stats</a>
      <a href="#" data-sec="sets" id="navSets">Sets</a>
      <a href="#" data-sec="train" id="navTrain">Train</a>
      <div style="margin-left:auto"></div>
      <span id="authUserName" class="small" style="color:#cbd5e1;margin-right:8px;max-width:220px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:none"></span>
      <button id="btnAuth" class="ghost small" title="Sign in to sync">Sign in</button>
    </div>
  </div>

  <!-- Auth modal -->
  <div id="authModal" style="display:none">
    <div id="authBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:50"></div>
    <div class="card" style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:min(92%,640px);z-index:51;padding:20px 22px 18px;border-radius:14px">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
        <div style="font-size:1.25rem;font-weight:700">Welcome back</div>
        <button id="authClose" class="ghost" style="padding:6px 10px">?</button>
      </div>
      <div class="muted" style="margin-bottom:12px">Sign in to sync your data across devices.</div>
      <div style="display:flex;flex-direction:column;gap:10px">
        <button id="btnGoogle" class="ghost" style="display:flex;gap:10px;align-items:center;justify-content:center;border:1px solid var(--border);padding:10px;border-radius:10px">
          <img alt="" src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" style="width:20px;height:20px"/>
          <span>Continue with Google</span>
        </button>
        <div class="muted" style="text-align:center">or</div>
        <input id="authEmail" type="email" placeholder="Email" autocomplete="email" />
        <input id="authPass" type="password" placeholder="Password" autocomplete="current-password" />
        <div class="row" style="gap:10px">
          <button id="btnEmailPrimary" style="flex:1">Sign in</button>
          <button id="btnReset" class="secondary" style="flex:1">Reset password</button>
        </div>
        <div id="authError" class="small" style="color:var(--bad);min-height:18px"></div>
        <div class="small" style="text-align:center">
          <a href="#" id="linkToggleMode">New here? Create an account</a>
        </div>
      </div>
    </div>
  </div>

  <!-- Home -->
  <div class="wrap section active" id="homeSection">
    <h1>Chess Mistake Trainer</h1>
    <div class="card" style="margin-top:12px">
      <h2>Start</h2>
      <ul>
        <li>Import recent games.</li>
        <li>Analyse to create a set.</li>
        <li>Manage sets and train.</li>
      </ul>
      <button id="btnGoAnalyze">Go to Import</button>
    </div>
  </div>

  <!-- Import -->
  <div class="wrap section" id="analyzeSection">
    <h1>Import and Analyse</h1>

    <div class="grid" style="margin-top:14px">
      <!-- LEFT COLUMN -->
      <div class="card">
        <h2>Import</h2>
        <!-- Unified import controls -->
        <!-- Settings (visible) -->
        <div id="importSettingsBox" class="tiny" style="display:block; margin-top:8px">
          <div class="row" style="align-items:flex-end">
            <div>
              <label>Providers</label>
              <div class="row" style="gap:10px">
                <label class="tiny"><input type="checkbox" id="provLichess" checked> Lichess</label>
                <label class="tiny"><input type="checkbox" id="provChesscom" checked> Chess.com</label>
              </div>
            </div>
          </div>
          <div class="row">
            <div>
              <label>Mode</label>
              <div>
                <label class="tiny"><input type="radio" name="importMode" id="modeCount" checked> By most recent</label>
                <label class="tiny" style="margin-left:10px"><input type="radio" name="importMode" id="modeTime"> By period</label>
              </div>
            </div>
            <div id="countWrap2" style="max-width:140px">
              <label>Games</label>
              <input id="importCount2" type="number" min="1" max="100" value="10" />
            </div>
            <div id="periodWrap" style="display:none; max-width:320px">
              <label>Period</label>
              <div style="display:flex; gap:8px; align-items:center">
                <input id="periodValue" type="number" step="0.1" min="0" value="30" style="max-width:120px"/>
                <select id="periodUnit">
                  <option value="minutes">minutes</option>
                  <option value="hours">hours</option>
                  <option value="days" selected>days</option>
                  <option value="weeks">weeks</option>
                  <option value="months">months</option>
                </select>
              </div>
            </div>
          </div>
          <div class="row" style="margin-top:8px; flex-direction:column; align-items:stretch; gap:8px">
            <div>
              <label>Link Chess.com username</label>
              <div style="display:flex; gap:8px; align-items:center">
                <div class="input-prefix" style="flex:1">
                  <span class="prefix">chess.com/</span>
                  <input id="accChessCom" type="text" placeholder="username" />
                </div>
                <button id="btnLinkChessCom" class="ghost">Link</button>
              </div>
            </div>
            <div>
              <label>Link Lichess username</label>
              <div style="display:flex; gap:8px; align-items:center">
                <div class="input-prefix" style="flex:1">
                  <span class="prefix">lichess.org/</span>
                  <input id="accLichess" type="text" placeholder="username" />
                </div>
                <button id="btnLinkLichess" class="ghost">Link</button>
              </div>
            </div>
          </div>
          <div class="tiny muted">Usernames and preferences are saved to your account.</div>
          <div style="display:flex; justify-content:flex-end; margin-top:8px"><button id="btnOpenPGN" class="ghost" style="margin-right:8px">Import PGN</button><button id="btnImportUnified">Import</button></div>
        </div>
        <div id="legacyLichessRow" class="row" style="margin-top:6px; display:none">
          <div>
            <label>Lichess username</label>
            <input id="lichessUser" type="text" placeholder="e.g., lox123" />
          </div>
          <div style="max-width:120px">
            <label>Games</label>
            <input id="lichessCount" type="number" min="1" max="50" value="5" />
          </div>
          <div style="max-width:220px">
            <label>&nbsp;</label>
            <button id="btnFetchLichess">Fetch (Lichess)</button>
          </div>
        </div>
        <div id="legacyChesscomRow" class="row" style="display:none">
          <div>
            <label>Chess.com username</label>
            <input id="chesscomUser" type="text" placeholder="e.g., lox123" />
          </div>
          <div style="max-width:120px">
            <label>Games</label>
            <input id="chesscomCount" type="number" min="1" max="50" value="5" />
          </div>
          <div style="max-width:220px">
            <label>&nbsp;</label>
            <button id="btnFetchChesscom">Fetch (Chess.com)</button>
          </div>
        </div>
        <!-- PGN area removed: now uses popup --></div>

        <!-- Status panel removed; messages moved to Imported Games header -->

        <div class="stroke tiny" id="importedBox" style="margin-top:10px">
          <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
            <b>Imported Games</b>
            <span class="tiny muted" id="importHelp">Fetched games will appear here.</span>
            <span class="tiny mono" id="importMistakes" style="color:#cbd5e1">Mistakes: 0</span>
            <span style="margin-left:auto"></span>
            <button id="btnClearImports" class="ghost" title="Clear imported games & their mistakes">Clear imports</button>
            <button id="btnAnalyzeImported" class="btn-green" title="Analyse mistakes (server)">Analyse mistakes</button>
            <button id="btnAnalyzeSettings" class="ghost" title="Analysis settings" style="padding:4px 8px">?</button>
          </div>
          <div style="max-height:220px;overflow:auto;border:1px dashed var(--border);border-radius:10px;margin-top:6px">
            <table id="importTable" style="width:100%">
              <thead>
                <tr>
                  <th>#</th>
                  <th>White</th>
                  <th>Black</th>
                  <th>Res</th>
                  <th>Date</th>
                  <th>Source</th>
                  <th>Analyse</th>
                </tr>
              </thead>
              <tbody id="importTBody"></tbody>
            </table>
          </div>$insertion<!-- Game Viewer with fully responsive board -->
          <!-- Create-set actions moved below the list (left-aligned) -->
          <div id="createSetRow" class="tiny" style="margin-top:8px; display:flex; align-items:center; gap:8px">
            <button id="btnCreateSetFromLast" class="secondary" title="Create a set from the last analysis results">Create set (0 mistakes)</button>
            <button id="btnAddToExistingSet" class="ghost" title="Add analyzed mistakes to an existing set">Add to existing set</button>
            <span id="createSetInfo" class="muted">-</span>
          </div>
          
          <!-- Game Viewer with fully responsive board -->
          <div id="gameViewer" class="stroke tiny" style="margin-top:10px; display:none">
            <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
              <b>Game Viewer</b>
              <span id="gvStatus" class="mono">-</span>
              <div style="margin-left:auto;display:flex;gap:6px">
                <button id="gvStart" class="ghost" title="Start">�</button>
                <button id="gvPrev" class="ghost" title="Prev">�</button>
                <button id="gvNext" class="ghost" title="Next">�</button>
                <button id="gvEnd" class="ghost" title="End">�</button>
              </div>
            </div>
            <div class="board-mini" style="margin-top:8px">
              <div id="gvBoard" aria-label="game-viewer-board"></div>
            </div>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid #242a39;margin:16px 0">
        <div class="stroke tiny" style="margin-top:8px">
          Trainer has moved to its own page. Use the <b>Train</b> tab in the top navigation to start a session.
        </div>
      </div>

      
    </div>
  </div>

  <!-- Sets Page -->
  <div class="wrap section" id="setsSection">
    <h1>Sets</h1>
    <div class="card" style="margin-top:10px">
      <div class="row" style="align-items:flex-end">
        <div>
          <label>New set name</label>
          <input id="newSetName" type="text" placeholder="e.g., Blitz mistakes Aug" />
        </div>
        <div style="max-width:220px">
          <label>&nbsp;</label>
          <button id="btnCreateEmptySet" class="ghost">Create empty set</button>
        </div>
      </div>
      <div class="row" style="align-items:flex-end; justify-content:flex-end; margin-top:8px">
        <div style="max-width:260px">
          <label>Sort sets</label>
          <select id="setsSortSelect">
            <option value="date_desc">Created: Newest first</option>
            <option value="date_asc">Created: Oldest first</option>
          </select>
        </div>
      </div>
      <div style="margin-top:10px;max-height:360px;overflow:auto;border:1px dashed var(--border);border-radius:10px">
        <table style="width:100%">
          <thead>
            <tr>
              <th>#</th><th>Name</th><th>Count</th><th>Created</th><th>Actions</th>
            </tr>
          </thead>
          <tbody id="setsTBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Stats Page -->
  <div class="wrap section" id="statsSection">
    <h1>Stats</h1>
    <div class="grid" style="margin-top:12px">
      <!-- LEFT: Mistake list filtered by set -->
      <div class="card">
        <h2>Mistake List</h2>
        <div class="row" style="align-items:flex-end;margin-top:6px">
          <div>
            <label>Set</label>
            <select id="statsSetSelect"></select>
          </div>
        </div>
        <div class="tiny muted" style="margin:6px 0 10px">Select a set to view its mistakes. Click a row to preview on the right.</div>
        <div style="max-height:360px;overflow:auto;border:1px dashed var(--border);border-radius:10px">
          <table id="statsMistakeTable">
            <thead>
              <tr>
                <th>#</th>
                <th>Severity</th>
                <th>Side</th>
                <th>Played</th>
                <th>Best</th>
                <th>?cp</th>
              </tr>
            </thead>
            <tbody id="statsMistakeTBody"></tbody>
          </table>
        </div>
      </div>

      <!-- RIGHT: Board + Summary -->
      <div class="card">
        <h2>Preview</h2>
        <div class="board-mini" style="margin-top:8px">
          <div id="statsBoard" aria-label="stats-board"></div>
        </div>
        <div class="stroke tiny" style="margin-top:10px">
          <div class="small"><b>Selected mistake</b></div>
          <div class="tiny mono" id="statsMInfo">-</div>
          <div class="tiny"><b>Side to move:</b> <span id="statsSideToMove">-</span></div>
          <div class="tiny"><b>Best:</b> <span id="statsBest">-</span></div>
          <div class="tiny"><b>?cp:</b> <span id="statsDelta">-</span></div>
        </div>

        <hr style="border:none;border-top:1px solid #242a39;margin:16px 0">
        <h2>Summary</h2>
        <div class="grid-2" style="margin-top:8px">
          <div class="stroke">
            <div class="small"><b>Accuracy:</b> <span id="statsAcc">-</span></div>
            <div class="small"><b>Reviews done:</b> <span id="statsReviews">0</span></div>
          </div>
          <div class="stroke">
            <div class="small"><b>Total mistakes:</b> <span id="statsTotal">0</span></div>
          </div>
        </div>
        <div style="margin-top:10px">
          <div class="small"><b>Severity distribution</b></div>
          <div class="bar"><canvas id="statsSevChart" width="600" height="180"></canvas></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Train Page -->
  <div class="wrap section" id="trainSection">
    <h1>Train</h1>

    <!-- View 1: Select a set to train -->
    <div id="trainSelectView" class="card" style="margin-top:12px">
      <h2>Select a set</h2>
      <div class="tiny muted" style="margin-top:6px">Select a set and start.</div>
      <div style="max-height:420px;overflow:auto;border:1px dashed var(--border);border-radius:10px;margin-top:8px">
        <table style="width:100%">
          <thead>
            <tr><th>#</th><th>Name</th><th>Count</th><th>Actions</th></tr>
          </thead>
          <tbody id="trainSelectTBody"></tbody>
        </table>
      </div>
    </div>

    <div class="train-grid" style="margin-top:12px">
      <div>
        <h2>Board</h2>
        <div class="board-wrap" style="margin-top:10px">
          <div id="evalBar" class="eval-bar" aria-hidden="true"><div class="eval-fill"></div><div class="tick"></div></div>
          <div class="train-block" style="display:flex; flex-direction:column; gap:8px; align-items:stretch">
            <div class="board" id="trainBoard">
              <div id="board" aria-label="chessboard"></div>
              <div id="resizeHandle" class="resize-handle" title="Drag to resize"></div>
            </div>
            <!-- Train viewer controls (navigate game mainline) -->
            <div id="tvControls" class="tiny" style="display:grid; grid-template-columns: 1fr auto 1fr; align-items:center; gap:8px">
              <span id="tvStatus" class="mono">-</span>
              <div style="display:flex; gap:6px; justify-content:center">
                <button id="tvStart" class="ghost" title="Start">�</button>
                <button id="tvPrev" class="ghost" title="Prev">�</button>
                <button id="tvNext" class="ghost" title="Next">�</button>
                <button id="tvEnd" class="ghost" title="End">�</button>
              </div>
            </div>
          </div>
          <div id="trainRightCol" style="flex:0 0 auto">
            <div class="legend tiny">
              <span>Drag to move</span>
              <span>?? correct = best move</span>
              <span>? otherwise</span>
            </div>
            <div class="stroke" style="margin-top:10px">
              <div class="small"><b>Current Mistake</b></div>
              <div class="tiny muted" id="mInfo">—</div>
              <div class="tiny" style="margin-top:6px"><b>Goal:</b> find the best move from this position.</div>
              <div class="tiny"><b>Side to move:</b> <span id="sideToMove">—</span></div>
              <div class="tiny"><b>Your attempt:</b> <span id="yourMove">—</span></div>
              <div class="tiny"><b>Feedback:</b> <span id="feedback">—</span></div>
              <div class="mistake-actions-wrap" style="margin-top:8px">
                <div class="mistake-actions">
                  <!-- Top row actions (Reveal moved to its own row) -->
                  <button id="btnShowMistake" class="ghost">Show mistake</button>
                  <button id="btnBack" class="ghost" disabled>Back</button>
                  <button id="btnNext" class="ghost">Next</button>
                  <button id="btnFlip" class="ghost">Flip board</button>
                </div>
                <div class="mistake-reveal-row" style="margin-top:8px">
                  <button id="btnReveal" class="ghost wide">Reveal best</button>
                </div>
              </div>
            </div>
            <!-- Engine Analysis panel moved above Game Info -->
            <div class="stroke tiny" style="margin-top:10px" id="enginePanel">
              <div class="row" style="align-items:center; justify-content:space-between; gap:10px; width:100%">
                <div style="display:flex; align-items:center; gap:8px; flex:1; flex-wrap:wrap">
                  <b>Engine</b>
                  <span id="engineStateLive" class="tiny muted">off</span>
                  <span id="engineMeta" class="tiny mono muted">-</span>
                  <span id="enginePerf" class="tiny mono muted" title="nodes per second">0 kn/s</span>
                  <span id="engineDepth" class="tiny mono muted" title="depth">depth: -/-</span>
                </div>
                <div style="display:flex; align-items:center; gap:10px">
                  <button id="engineSettingsBtn" class="ghost" title="Engine settings" style="padding:2px 8px">?</button>
                  <label class="switch" title="Toggle engine analysis">
                    <input type="checkbox" id="engineToggle">
                    <span class="slider"></span>
                  </label>
                </div>
              </div>
              <div id="engineLines" class="mono" style="margin-top:6px; white-space:pre-wrap"></div>
            </div>
            <div class="stroke tiny" style="margin-top:10px">
              <div><b>Game Info</b></div>
              <div class="exp-field" id="fenField" style="margin-top:6px">
                <span class="exp-label tiny">FEN</span>
                <div id="trainFenCollapsed" class="exp-collapsed" title="Click to expand">-</div>
                <div class="exp-panel">
                  <textarea id="trainFenFull" class="exp-text" readonly></textarea>
                  <button id="copyFen" class="ghost copy-btn" title="Copy FEN">Copy</button>
                </div>
              </div>
              <div class="exp-field" id="pgnField" style="margin-top:10px">
                <span class="exp-label tiny">PGN</span>
                <div id="trainPgnCollapsed" class="exp-collapsed" title="Click to expand">-</div>
                <div class="exp-panel">
                  <textarea id="trainPgnFull" class="exp-text" readonly></textarea>
                  <button id="copyPgn" class="ghost copy-btn" title="Copy PGN">Copy</button>
                </div>
              </div>
              <div class="tiny" style="margin-top:10px">Link: <a id="trainLink" href="#" target="_blank" rel="noopener">-</a></div>
            </div>
              </div>
              <div id="movesCol">
                <div class="stroke tiny" id="moveListPanel" style="height:100%; display:flex; flex-direction:column">
                  <div><b>Moves</b></div>
                  <div id="moveList" class="tiny mono" style="margin-top:6px; overflow:auto; flex:1; line-height:1.6"></div>
                </div>
              </div>
            </div>
            <div class="row" style="margin-top:10px">
              <button id="btnExitTrain" class="ghost">Exit</button>
            </div>

          </div>
        </div>
      </div>
      <div class="card">
        <h2>Sets</h2>
        <div class="tiny muted">Click a set to activate then Start.</div>
        <div style="max-height:380px;overflow:auto;border:1px dashed var(--border);border-radius:10px;margin-top:6px">
          <table style="width:100%">
            <thead>
              <tr><th>#</th><th>Name</th><th>Count</th></tr>
            </thead>
            <tbody id="trainSetsTBody"></tbody>
          </table>
        </div>
        <div class="row" style="margin-top:10px">
            <!-- Mode selector and Woodpecker count removed -->
            <div style="max-width:220px">
              <label>&nbsp;</label>
              <button id="btnStart">Start</button>
            </div>
        </div>
        <div class="tiny muted" id="activeSetInfo" style="margin-top:6px">Active set: —</div>
      </div>
    </div>
  </div>

  <!-- Firebase (App + Analytics) -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js';

    // Use the Firebase Hosting "firebaseapp.com" domain as authDomain to
    // match the Google provider's authorized redirect URIs and avoid
    // redirect_uri_mismatch. (web.app works too if added in console.)
    const AUTH_DOMAIN = 'chessmistaketrainer.firebaseapp.com';
    const firebaseConfig = {
      apiKey: "AIzaSyB_VkTkQXOgc4Q0jithJk9iwzRv2OLLIE0",
      authDomain: AUTH_DOMAIN,
      projectId: "chessmistaketrainer",
      storageBucket: "chessmistaketrainer.firebasestorage.app",
      messagingSenderId: "283045516917",
      appId: "1:283045516917:web:c0d57f12aceb33a16d4a3c",
      measurementId: "G-86S4RMVDR3"
    };

    const app = initializeApp(firebaseConfig);
    try{ console.debug('[Auth] Using authDomain =', AUTH_DOMAIN); }catch{}
    window.firebaseApp = app;
    const REGION = 'europe-west2';
    const PROJECT_ID = firebaseConfig.projectId || (app && app.options && app.options.projectId) || 'chessmistaketrainer';
    window.FN_BASE = `https://${REGION}-${PROJECT_ID}.cloudfunctions.net`;
    window.FN_LICHESS_URL = window.FN_LICHESS_URL || `${window.FN_BASE}/fetchLichess`;
    window.FN_CHESSCOM_URL = window.FN_CHESSCOM_URL || `${window.FN_BASE}/fetchChessCom`;
    // Allow overriding SF backend URL via localStorage for easy re-pointing
    try{
      let __ov = localStorage.getItem('pmtt_sf_backend_url');
      const isValid = (v) => {
        try{
          if(!v) return false;
          if(/[<>]/.test(v)) return false; // common placeholder markers
          if(/your-new-service/i.test(v)) return false; // ignore placeholder value
          const u = new URL(v);
          return /^https?:$/.test(u.protocol);
        }catch{ return false }
      };
      if(__ov && isValid(__ov)) window.SF_BACKEND_URL = __ov;
      else if(__ov) { console.warn('[config] Ignoring invalid pmtt_sf_backend_url override:', __ov); }
    }catch{}
    window.SF_BACKEND_URL = window.SF_BACKEND_URL || 'https://sf-backend-283045516917.europe-west2.run.app';
    try{ console.debug('[config] Using SF_BACKEND_URL =', window.SF_BACKEND_URL); }catch{}

    // Analytics disabled to avoid env errors unless explicitly enabled
    const ENABLE_ANALYTICS = false;
    if (ENABLE_ANALYTICS) {
      (async () => {
        try {
          const mod = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-analytics.js');
          const supported = await mod.isSupported();
          if (supported) mod.getAnalytics(app);
        } catch {}
      })();
    }
  </script>

  <!-- Firebase Auth + Firestore sync (module) -->
  <script type="module">
    import { getAuth, onAuthStateChanged, signInAnonymously } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js';
    import {
      getFirestore,
      enableIndexedDbPersistence,
      enableMultiTabIndexedDbPersistence,
      collection, doc, getDocs, onSnapshot, writeBatch, addDoc, query, orderBy
    } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js';

    const fbApp = window.firebaseApp;
    const fbAuth = getAuth(fbApp);
    const db = getFirestore(fbApp);

    // Prefer single-tab persistence and fallback to multi-tab when needed
    enableIndexedDbPersistence(db).catch(async (err)=>{
      console.warn('[Firestore] enableIndexedDbPersistence failed; attempting multi-tab persistence.', err?.code || err);
      try{
        await enableMultiTabIndexedDbPersistence(db);
        console.info('[Firestore] Multi-tab persistence enabled.');
      }catch(e){
        console.warn('[Firestore] Multi-tab persistence failed; using memory cache only.', e?.code || e);
      }
    });

    // Use fbAuth instead of auth in this module
    const mistakeId = (m) => {
      const key = `${m.fen}|${m.played}`;
      try { return btoa(unescape(encodeURIComponent(key))).replace(/=+$/,''); }
      catch { return key.replace(/[^a-zA-Z0-9_-]/g,'_'); }
    };

    const api = {
      ready:false, user:null, db,
      async saveAllMistakes(arr){
        if(!api.user) return;
        const col = collection(db, 'users', api.user.uid, 'mistakes');
        const snap = await getDocs(col);
        const curIds = new Set(); snap.forEach(d => curIds.add(d.id));
        const nextIds = new Set(arr.map(m => mistakeId(m)));
        const batch = writeBatch(db);
        for(const m of arr){ batch.set(doc(col, mistakeId(m)), m, { merge:true }); }
        for(const id of curIds){ if(!nextIds.has(id)) batch.delete(doc(col, id)); }
        await batch.commit();
      },
      async addMistakesRemote(newOnes){
        if(!api.user || !newOnes.length) return;
        const col = collection(db, 'users', api.user.uid, 'mistakes');
        const batch = writeBatch(db);
        for(const m of newOnes){ batch.set(doc(col, mistakeId(m)), m, { merge:true }); }
        await batch.commit();
      },
      async clearAllRemote(){
        if(!api.user) return;
        const mCol = collection(db, 'users', api.user.uid, 'mistakes');
        const aCol = collection(db, 'users', api.user.uid, 'attempts');
        const mSnap = await getDocs(mCol);
        const aSnap = await getDocs(aCol);
        const batch = writeBatch(db);
        mSnap.forEach(d => batch.delete(doc(mCol, d.id)));
        aSnap.forEach(d => batch.delete(doc(aCol, d.id)));
        await batch.commit();
      },
      async logAttemptRemote(mId, correct, ts, move){
        if(!api.user) return;
        const aCol = collection(db, 'users', api.user.uid, 'attempts');
        await addDoc(aCol, { id:mId, correct:!!correct, ts:ts||Date.now(), move: move||null });
      },
      async getAttemptsRemote(){
        if(!api.user) return [];
        const aCol = collection(db, 'users', api.user.uid, 'attempts');
        const q = query(aCol, orderBy('ts','asc'));
        const snap = await getDocs(q);
        const arr=[]; snap.forEach(d=>arr.push(d.data())); return arr;
      },
      // Sets sync
      async saveAllSets(sets){
        if(!api.user) return;
        const sCol = collection(db, 'users', api.user.uid, 'sets');
        const batch = writeBatch(db);
        for(const s of (sets||[])) batch.set(doc(sCol, s.id), s, { merge:true });
        await batch.commit();
      },
      async deleteSetRemote(id){
        if(!api.user || !id) return;
        const sCol = collection(db, 'users', api.user.uid, 'sets');
        const b = writeBatch(db); b.delete(doc(sCol, id)); await b.commit();
      },
      async updateSetName(id, name){
        if(!api.user || !id) return;
        const sCol = collection(db, 'users', api.user.uid, 'sets');
        const b = writeBatch(db); b.set(doc(sCol, id), { name }, { merge:true }); await b.commit();
      },
      // Imports sync
      // Stable, short ID for imports to avoid oversized Firestore doc IDs
      importId(rec){
        try{
          const s = String(rec?.pgn || '');
          let h1 = 0, h2 = 0;
          for(let i=0;i<s.length;i++){
            const c = s.charCodeAt(i);
            h1 = (h1 * 31 + c) | 0;
            h2 = (h2 * 131 + c) | 0;
          }
          const id = 'p' + (h1>>>0).toString(36) + (h2>>>0).toString(36);
          return id;
        }catch{
          return 'p' + Date.now().toString(36);
        }
      },
      async appendImports(pgns, source){
        if(!api.user) return;
        const iCol = collection(db, 'users', api.user.uid, 'imports');
        const batch = writeBatch(db);
        const now = Date.now(); let idx=0;
        for(const pgn of (pgns||[])){
          if(!pgn) continue;
          const rec = { pgn, source: source||'Imported', ts: now + (idx++) };
          const id = api.importId(rec);
          batch.set(doc(iCol, id), rec, { merge:true });
        }
        try{ await batch.commit(); }
        catch(e){ try{ console.warn('[Imports] Firestore save failed:', e?.code||e); }catch{} }
      },
      async clearImportsRemote(){
        if(!api.user) return;
        const iCol = collection(db, 'users', api.user.uid, 'imports');
        const snap = await getDocs(iCol);
        const batch = writeBatch(db);
        snap.forEach(d => batch.delete(doc(iCol, d.id)));
        await batch.commit();
      },
      async savePrefs(p){
        if(!api.user || !p) return;
        const ref = doc(db, 'users', api.user.uid, 'prefs', 'app');
        const b = writeBatch(db); b.set(ref, p, { merge:true }); await b.commit();
      }
    };

    window.firebaseAPI = api;

    // Cloud sync is optional; avoid automatic sign-in to prevent console errors
    // when Anonymous auth is not enabled. Call firebaseAPI.initAuth() to start.
    api.initAuth = async function(){ try { await signInAnonymously(fbAuth); } catch {} };
    if (window.ENABLE_CLOUD_SYNC) { api.initAuth(); }
    onAuthStateChanged(fbAuth, async (user) => {
      api.user = user || null; api.ready = !!user; window.firebaseUser = user || null;
      try { window.setAuthUIUser && window.setAuthUIUser(user || null); } catch {}

      // Detach previous listeners if any
      try{ if(api._unsubs){ Object.values(api._unsubs).forEach(fn=>{ try{ fn&&fn(); }catch{} }); } }catch{}
      api._unsubs = {};

      if(!user){
        // Wipe local session data on sign-out
        try{
          localStorage.removeItem('pmtt_mistakes');
          localStorage.removeItem('pmtt_attempts');
          localStorage.removeItem('pmtt_sets');
        }catch{}
        try{ window.importedGames = []; }catch{}
        try{ window.LAST_ANALYZED = { mistakes: [], suggestedName: '' }; }catch{}
        try{ window.dispatchEvent(new CustomEvent('firebase:mMistakesUpdated')); }catch{}
        try{ window.dispatchEvent(new CustomEvent('firebase:attemptsUpdated')); }catch{}
        try{ window.dispatchEvent(new CustomEvent('firebase:setsUpdated')); }catch{}
        try{ window.dispatchEvent(new CustomEvent('firebase:importsUpdated')); }catch{}
        return;
      }

      // live sync mistakes -> local (merge to avoid transient drops during slow writes)
      const mCol = collection(db, 'users', user.uid, 'mistakes');
      const keyOfLocal = (m) => (((m||{}).fen)||'') + '|' + (((m||{}).played)||'');
      api._unsubs.mistakes = onSnapshot(mCol, (snap) => {
        const remote=[]; snap.forEach(d=>remote.push(ensureSeverity(d.data())));
        try{
          const local = JSON.parse(localStorage.getItem('pmtt_mistakes')||'[]');
          const map = new Map();
          for(const m of local){ const k = keyOfLocal(m); if(k) map.set(k, ensureSeverity(m)); }
          for(const m of remote){ const k = keyOfLocal(m); if(k) map.set(k, ensureSeverity(m)); }
          const merged = Array.from(map.values());
          localStorage.setItem('pmtt_mistakes', JSON.stringify(merged));
        }catch{
          try{ localStorage.setItem('pmtt_mistakes', JSON.stringify(remote)); }catch{}
        }
        window.dispatchEvent(new CustomEvent('firebase:mMistakesUpdated'));
      });

      // live sync attempts -> local
      try{
        const aCol = collection(db, 'users', user.uid, 'attempts');
        const qA = query(aCol, orderBy('ts','asc'));
        api._unsubs.attempts = onSnapshot(qA, (snap) => {
          const arr=[]; snap.forEach(d=>arr.push(d.data()));
          try{ localStorage.setItem('pmtt_attempts', JSON.stringify(arr)); }catch{}
          window.dispatchEvent(new CustomEvent('firebase:attemptsUpdated'));
        });
      }catch{}

      // live sync sets -> local
      const sCol = collection(db, 'users', user.uid, 'sets');
      api._unsubs.sets = onSnapshot(sCol, (snap) => {
        const arr=[]; snap.forEach(d=>arr.push(d.data()));
        try{
          const norm = arr.map(s=>{
            const out = {...s};
            if(!Array.isArray(out.items)) out.items = [];
            for(let i=0;i<out.items.length;i++){
              const it = out.items[i] || {};
              if(typeof it.severity === 'undefined' || it.severity === null){
                try{ it.severity = severityFromDrop(it.deltaCp); }catch{ it.severity = null; }
              }
            }
            out.version = 2;
            return out;
          });
          localStorage.setItem('pmtt_sets', JSON.stringify(norm));
        }catch{}
        window.dispatchEvent(new CustomEvent('firebase:setsUpdated'));
      });

      // live sync imports -> merge remote into local to avoid flicker/erase on slow writes
      const iCol = collection(db, 'users', user.uid, 'imports');
      api._unsubs.imports = onSnapshot(iCol, (snap) => {
        const remote=[]; snap.forEach(d=>remote.push(d.data()));
        try{
          const local = Array.isArray(window.importedGames) ? window.importedGames : [];
          // If remote is temporarily empty right after a local add, avoid clearing UI
          const justLocallyUpdated = (Date.now() - (window._importsLocalBump||0)) < 4000;
          if(justLocallyUpdated && remote.length < local.length){
            // keep local as-is; remote will merge on next snapshot
            window.dispatchEvent(new CustomEvent('firebase:importsUpdated'));
            return;
          }
          const map = new Map();
          for(const r of local){ if(r && r.pgn){ if(typeof r.sel==='undefined') r.sel=true; map.set(r.pgn, r); } }
          for(const r of remote){
            if(r && r.pgn){
              const prev = map.get(r.pgn);
              const sel = prev && typeof prev.sel !== 'undefined' ? prev.sel : true;
              map.set(r.pgn, {...r, sel});
            }
          }
          window.importedGames = Array.from(map.values());
        }catch{ window.importedGames = remote; }
        try{ window.dispatchEvent(new CustomEvent('firebase:importsUpdated')); }catch{}
      });
      
      // live sync prefs -> local
      try{
        const pRef = doc(db, 'users', user.uid, 'prefs', 'app');
        api._unsubs.prefs = onSnapshot(pRef, (snap)=>{
          const d = (snap && snap.data && snap.data()) ? snap.data() : {};
          try{ localStorage.setItem('pmtt_prefs', JSON.stringify(d)); }catch{}
          try{ window.dispatchEvent(new CustomEvent('firebase:prefsUpdated')); }catch{}
        });
      }catch{}
    });
  </script>

  <!-- Auth modal logic (Google + email/password) -->
  <script type="module">
    import {
      getAuth, GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult,
      signInWithEmailAndPassword, createUserWithEmailAndPassword,
      sendPasswordResetEmail, signOut, onAuthStateChanged
    } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js';

    const auth = getAuth(window.firebaseApp);
    const provider = new GoogleAuthProvider();
    provider.setCustomParameters({ prompt: 'select_account' });
    // Prefer redirect everywhere for consistency and fewer popup issues.
    // Allow override via window.AUTH_USE_POPUP=true for local debugging.
    const preferRedirect = (()=>{
      try{
        if (window.AUTH_USE_POPUP === true) return false;
        return true;
      }catch{ return true }
    })();

    const byId = (id)=> document.getElementById(id);
    const modal = byId('authModal');
    const backdrop = byId('authBackdrop');
    const closeBtn = byId('authClose');
    const openBtn = byId('btnAuth');
    const emailEl = byId('authEmail');
    const passEl = byId('authPass');
    const primaryBtn = byId('btnEmailPrimary');
    const resetBtn = byId('btnReset');
    const googleBtn = byId('btnGoogle');
    const toggleLink = byId('linkToggleMode');
    const errEl = byId('authError');

    let mode = 'signin';

    function nameForUser(u){
      if(!u) return '';
      return u.displayName || u.email || (u.isAnonymous ? 'Guest' : '');
    }

    function applyAuthUI(user){
      const openBtn = byId('btnAuth');
      const nameEl = byId('authUserName');
      if(openBtn){
        openBtn.textContent = user ? 'Sign out' : 'Sign in';
        openBtn.title = user ? nameForUser(user) : 'Sign in to sync';
      }
      if(nameEl){
        const nm = nameForUser(user);
        nameEl.textContent = user ? nm : '';
        nameEl.style.display = user ? 'inline' : 'none';
      }
    }
    // expose for other scripts
    window.setAuthUIUser = applyAuthUI;
    // Set initial UI state if auth already initialized
    try { applyAuthUI(auth.currentUser || null); } catch {}
    function setMode(m){
      mode = m === 'signup' ? 'signup' : 'signin';
      if(primaryBtn) primaryBtn.textContent = mode === 'signup' ? 'Create account' : 'Sign in';
      if(resetBtn) resetBtn.style.display = mode === 'signup' ? 'none' : 'inline-block';
      if(toggleLink) toggleLink.textContent = mode === 'signup' ? 'Have an account? Sign in' : 'New here? Create an account';
      if(errEl){ errEl.style.color='var(--bad)'; errEl.textContent = ''; }
    }
    setMode('signin');

    function openModal(){ if(modal){ modal.style.display = 'block'; } setMode('signin'); emailEl?.focus(); }
    function closeModal(){ if(modal){ modal.style.display = 'none'; } }

    openBtn?.addEventListener('click', async()=>{
      const user = auth.currentUser;
      // If signed in anonymously, open modal to upgrade instead of signing out.
      if(user && user.isAnonymous){ openModal(); return; }
      if(user){ try{ await signOut(auth); }catch{}; return; }
      openModal();
    });
    closeBtn?.addEventListener('click', closeModal);
    backdrop?.addEventListener('click', closeModal);
    toggleLink?.addEventListener('click', (e)=>{ e.preventDefault(); setMode(mode==='signup'?'signin':'signup'); });

    function showErr(e){
      if(!errEl) return;
      const code = (e && e.code)||'';
      const msg = (e && e.message)||'';
      const pretty = code.replace('auth/','').replace(/-/g,' ');
      errEl.textContent = pretty || msg || 'Error';
      errEl.style.color = 'var(--bad)';
    }

    // Handle redirect results on load (in case we used redirect flow)
    getRedirectResult(auth).then((res)=>{
      console.debug('[Auth] getRedirectResult resolved', !!res?.user);
      if(res && res.user){
        closeModal();
        setTimeout(()=>{ try{ applyAuthUI(auth.currentUser||null); }catch{} }, 0);
      }
    }).catch((e)=>{ console.debug('[Auth] getRedirectResult error', e?.code||e); });

    googleBtn?.addEventListener('click', async()=>{
      if(!googleBtn) return;
      googleBtn.disabled = true;
      try{
        console.debug('[Auth] Google click. preferRedirect=', preferRedirect);
        if (preferRedirect) {
          await signInWithRedirect(auth, provider);
          return; // navigation follows
        }
        await signInWithPopup(auth, provider);
        closeModal();
      } catch(e){
        console.warn('[Auth] Sign-in attempt failed, trying redirect', e?.code||e);
        try{ await signInWithRedirect(auth, provider); return; }catch{}
        showErr(e);
      } finally {
        try{ googleBtn.disabled = false; }catch{}
      }
    });

    primaryBtn?.addEventListener('click', async()=>{
      const email = (emailEl?.value||'').trim();
      const pass = (passEl?.value||'');
      if(!email || !pass){ if(errEl){ errEl.textContent = 'Enter email and password'; } return; }
      try{
        if(mode==='signup') await createUserWithEmailAndPassword(auth, email, pass);
        else await signInWithEmailAndPassword(auth, email, pass);
        closeModal();
      }catch(e){ showErr(e); }
    });
    resetBtn?.addEventListener('click', async()=>{
      const email = (emailEl?.value||'').trim();
      if(!email){ if(errEl){ errEl.textContent = 'Enter your email to reset password'; } return; }
      try{
        await sendPasswordResetEmail(auth, email);
        if(errEl){ errEl.style.color='var(--good)'; errEl.textContent='Password reset email sent'; setTimeout(()=>{ errEl.style.color='var(--bad)'; }, 1500); }
      }
      catch(e){ showErr(e); }
    });

    onAuthStateChanged(auth, (user)=>{
      console.debug('[Auth] state change =>', user ? (user.email || user.displayName || user.uid) : 'signed out');
      applyAuthUI(user);
      if(user){ closeModal(); }
    });
  </script>

  <!-- Stockfish WASM (local, project-relative path) -->
  <script src="engine/stockfish.js"></script>
  <!-- jQuery + chessboard.js (local) -->
  <script src="/vendor/jquery.min.js"></script>
  <script src="/chessboardjs/js/chessboard-1.0.0.min.js"></script>

  <script>
    /********************************************************************
     * Utils
     ********************************************************************/
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const sleep = ms => new Promise(res => setTimeout(res, ms));
    const nowTs = () => Date.now();
    const days = n => n * 24 * 60 * 60 * 1000;
    const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
    const uid = () => 'm_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
    function tsToDate(ts){ try{ const d=new Date(ts); return d.toLocaleDateString()+' '+d.toLocaleTimeString(); }catch{return '-';} }
    function setStatus(msg){
      try{
        if(typeof msg === 'string'){
          // Update mistake counter if present in status but keep showing progress text
          if(/mistakes found:\s*(\d+)/i.test(msg)){
            try{ const m = msg.match(/mistakes found:\s*(\d+)/i); if(m) setMistakeCounter(parseInt(m[1],10)||0); }catch{}
          }
          // Normalize end-of-run message
          if(/^Done\. Added\s+/i.test(msg)) msg = 'Analysis finished';
        }
        const h=document.getElementById('importHelp'); if(h) h.textContent=msg;
      }catch{}
    }
    function setMistakeCounter(n){
      try{
        const el=document.getElementById('importMistakes');
        if(!el) return;
        let u = n;
        try{
          const arr = (window.LAST_ANALYZED && Array.isArray(window.LAST_ANALYZED.mistakes)) ? window.LAST_ANALYZED.mistakes : null;
          if(arr){ u = (new Set(arr.map(keyOf))).size; }
        }catch{}
        el.textContent = `Mistakes: ${u}`;
      }catch{}
    }

    // Disable native HTML5 drag inside chess boards (we use chessboard.js's own drag)
    document.addEventListener('dragstart', function (e) {
      const t = e.target;
      if (t && t.tagName === 'IMG' && (t.closest('#board') || t.closest('#gvBoard') || t.closest('#statsBoard'))) {
        e.preventDefault();
      }
    }, true);

    // Engine Settings modal (PV, Depth, Arrows, Threads, Hash)
    (function(){
      function buildModal(){
        const modal = document.createElement('div');
        modal.id = 'engineSettingsModal';
        modal.style.display = 'none';
        modal.innerHTML = `
          <div id="engSetBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:70"></div>
          <div style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:71">
            <div class="card" style="width:min(520px, 95vw); max-height:90vh; overflow:auto">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
                <h2>Engine Settings</h2>
                <button id="engSetClose" class="ghost" title="Close">�</button>
              </div>
              <div class="row" style="margin-top:10px">
                <div style="max-width:140px">
                  <label>PV (lines)</label>
                  <input id="engPvInput" type="number" min="1" max="10" value="3" />
                </div>
                <div style="max-width:140px">
                  <label>Arrows</label>
                  <input id="engArrowInput" type="number" min="0" max="10" value="1" />
                </div>
                <div class="stroke" style="flex:1">
                  <div class="small"><b>Depth</b> <span id="engDepthVal" class="mono muted" style="margin-left:6px">16</span></div>
                  <input id="engDepthInput" type="range" min="1" max="100" value="16" style="width:100%; margin-top:8px" />
                </div>
              </div>
              <div class="row" style="margin-top:10px">
                <div style="max-width:140px">
                  <label>Threads</label>
                  <input id="engThreadsInput" type="number" min="1" max="32" value="1" />
                  <div class="tiny muted" id="engThreadsHint"></div>
                </div>
                <div style="max-width:180px">
                  <label>Hash (MB)</label>
                  <input id="engHashInput" type="number" min="16" max="2048" step="16" value="128" />
                  <div class="tiny muted">TT size; larger uses more RAM</div>
                </div>
              </div>
              <div class="row" style="margin-top:12px; justify-content:flex-end">
                <button id="engSetCancel" class="ghost">Cancel</button>
                <button id="engSetSave" class="secondary">Save</button>
              </div>
            </div>
          </div>`;
        document.body.appendChild(modal);
        return modal;
      }
      let modalEl = null;
      function ensureModal(){ if(!modalEl) modalEl = buildModal(); return modalEl; }
      function open(){
        const m = ensureModal();
        // preload values from EngineLive
        try{
          const LS_PV='pmtt_eng_pv', LS_DEPTH='pmtt_eng_depth', LS_ARROWS='pmtt_eng_arrows', LS_THREADS='pmtt_eng_threads', LS_HASH='pmtt_eng_hash';
          let pv = (window.EngineLive && window.EngineLive.getMultiPV) ? window.EngineLive.getMultiPV() : null;
          let d  = (window.EngineLive && window.EngineLive.getDepth) ? window.EngineLive.getDepth() : null;
          let arrows = (window.EngineLive && window.EngineLive.getArrowCount) ? window.EngineLive.getArrowCount() : null;
          let thr = (window.EngineLive && window.EngineLive.getThreads) ? window.EngineLive.getThreads() : null;
          let hm  = (window.EngineLive && window.EngineLive.getHashMB) ? window.EngineLive.getHashMB() : null;
          if(pv==null){ try{ pv = Math.max(1, Math.min(10, parseInt(localStorage.getItem(LS_PV)||'',10)||3)); }catch{ pv=3; } }
          if(d==null){ try{ d  = Math.max(1, Math.min(100, parseInt(localStorage.getItem(LS_DEPTH)||'',10)||16)); }catch{ d=16; } }
          if(arrows==null){ try{ arrows = Math.max(0, Math.min(10, parseInt(localStorage.getItem(LS_ARROWS)||'',10)||1)); }catch{ arrows=1; } }
          if(thr==null){ try{ thr = Math.max(1, Math.min(32, parseInt(localStorage.getItem(LS_THREADS)||'',10)||1)); }catch{ thr=1; } }
          if(hm==null){ try{ hm  = Math.max(16, Math.min(2048, parseInt(localStorage.getItem(LS_HASH)||'',10)||128)); }catch{ hm=128; } }
          // cap arrows by pv
          arrows = Math.max(0, Math.min(pv, arrows));
          const pvEl = document.getElementById('engPvInput'); if(pvEl) pvEl.value = String(pv);
          const dEl = document.getElementById('engDepthInput'); if(dEl) dEl.value = String(d);
          const dvEl= document.getElementById('engDepthVal'); if(dvEl) dvEl.textContent = String(d);
          const aEl = document.getElementById('engArrowInput'); if(aEl){ aEl.max=String(pv); aEl.value = String(arrows); }
          const tEl = document.getElementById('engThreadsInput'); if(tEl){
            try{ const hc = (navigator.hardwareConcurrency||0)|0; if(hc>0){ tEl.max = String(Math.min(32,hc)); const hint=document.getElementById('engThreadsHint'); if(hint) hint.textContent = `CPU cores: ${hc}`; } }catch{}
            tEl.value = String(thr);
          }
          const hEl = document.getElementById('engHashInput'); if(hEl) hEl.value = String(hm);
        }catch{}
        m.style.display = 'block';
      }
      function close(){ try{ const m=ensureModal(); m.style.display='none'; }catch{} }
      let wiredOnce = false;
      function wire(){
        if(wiredOnce) return; wiredOnce = true;
        ensureModal();
        document.getElementById('engSetBackdrop')?.addEventListener('click', close);
        document.getElementById('engSetClose')?.addEventListener('click', close);
        document.getElementById('engSetCancel')?.addEventListener('click', close);
        const dEl = document.getElementById('engDepthInput');
        if(dEl){ dEl.addEventListener('input', ()=>{ const dv=document.getElementById('engDepthVal'); if(dv) dv.textContent=String(dEl.value); }); }
        // When PV changes, adjust Arrows max immediately
        const pvEl = document.getElementById('engPvInput');
        const aEl = document.getElementById('engArrowInput');
        if(pvEl && aEl){ pvEl.addEventListener('input', ()=>{ try{ const pv=Math.max(1, Math.min(10, parseInt(pvEl.value,10)||1)); aEl.max=String(pv); if(parseInt(aEl.value,10)>pv) aEl.value=String(pv); }catch{} }); }
        document.getElementById('engSetSave')?.addEventListener('click', ()=>{
          try{
            const LS_PV='pmtt_eng_pv', LS_DEPTH='pmtt_eng_depth', LS_ARROWS='pmtt_eng_arrows', LS_THREADS='pmtt_eng_threads', LS_HASH='pmtt_eng_hash';
            const pv = Math.max(1, Math.min(10, parseInt(document.getElementById('engPvInput')?.value,10)||3));
            const d  = Math.max(1, Math.min(100, parseInt(document.getElementById('engDepthInput')?.value,10)||16));
            const arrows = Math.max(0, Math.min(pv, parseInt(document.getElementById('engArrowInput')?.value,10)||1));
            const thr = Math.max(1, Math.min(parseInt(document.getElementById('engThreadsInput')?.value,10)||1, parseInt(document.getElementById('engThreadsInput')?.max||'32',10)||32));
            const hm  = Math.max(16, Math.min(2048, parseInt(document.getElementById('engHashInput')?.value,10)||128));
            try{
              localStorage.setItem(LS_PV, String(pv));
              localStorage.setItem(LS_DEPTH, String(d));
              localStorage.setItem(LS_ARROWS, String(arrows));
              localStorage.setItem(LS_THREADS, String(thr));
              localStorage.setItem(LS_HASH, String(hm));
            }catch{}
            if(window.EngineLive){
              if(window.EngineLive.setMultiPV) window.EngineLive.setMultiPV(pv);
              if(window.EngineLive.setDepth) window.EngineLive.setDepth(d);
              if(window.EngineLive.setArrowCount) window.EngineLive.setArrowCount(arrows);
              if(window.EngineLive.setThreads) window.EngineLive.setThreads(thr);
              if(window.EngineLive.setHashMB) window.EngineLive.setHashMB(hm);
            }
          }catch{}
          close();
        });
      }
      document.getElementById('engineSettingsBtn')?.addEventListener('click', ()=>{ open(); wire(); });
    })();

    /********************************************************************
     * Game viewer (Import page)
     ********************************************************************/
    const GAMEVIEW = { fens: [], idx: 0, total: 0, pgn: '', whiteBottom: true };
    function gvHide(){ const el = $('#gameViewer'); if(el) el.style.display = 'none'; }
    function gvShow(){ const el = $('#gameViewer'); if(el) el.style.display = 'block'; }
    function gvUpdate(){
      const lbl = $('#gvStatus');
      if(!lbl) return;
      const total = GAMEVIEW.total;
      const idx = GAMEVIEW.idx;
      lbl.textContent = total ? `Move ${idx}/${total}` : '-';
      setBoardFonts(); /* keep font sizes responsive */
    }

    /********************************************************************
     * Train viewer (Train page main board)
     ********************************************************************/
    const TRAINVIEW = { fens: [], san: [], idx: 0, total: 0 };
    function tvUpdate(){
      const lbl = document.getElementById('tvStatus'); if(!lbl) return;
      const total = TRAINVIEW.total; const idx = TRAINVIEW.idx;
      lbl.textContent = total ? `Move ${idx}/${total}` : '-';
      try{ setBoardFonts(); }catch{}
      try{ updateMoveListHighlight(); }catch{}
    }
    function setTrainNavEnabled(on){
      ['tvStart','tvPrev','tvNext','tvEnd'].forEach(id=>{ try{ const b=document.getElementById(id); if(b) b.disabled = !on; }catch{} });
    }
    function initTrainViewFromMistake(m){
      try{
        if(!m || !m.pgn){ TRAINVIEW.fens=[]; TRAINVIEW.idx=0; TRAINVIEW.total=0; setTrainNavEnabled(false); tvUpdate(); return; }
        const cl = ChessLite(); cl.reset();
        const startFen = cl.fen();
        const mixed = cl.loadPGN(m.pgn);
        const movesOnly = mixed.filter(x=>x && x.san);
        const fens = [startFen, ...movesOnly.map(x=>x.fenAfter)];
        const sans = movesOnly.map(x=>x.san);
        TRAINVIEW.fens = fens; TRAINVIEW.total = Math.max(0, fens.length-1);
        TRAINVIEW.san = sans;
        // Find the index of the active mistake position within the mainline
        let idx = fens.findIndex(f=>f===m.fen);
        if(idx < 0){
          const norm = s => String(s||'').split(' ').slice(0,4).join(' ');
          const want = norm(m.fen);
          idx = fens.findIndex(f=>norm(f)===want);
        }
        TRAINVIEW.idx = Math.max(0, idx>=0 ? idx : 0);
        setTrainNavEnabled(!!fens.length);
        renderMoveList();
        tvUpdate();
      }catch(e){ try{ console.warn('TRAINVIEW init error', e); }catch{}; TRAINVIEW.fens=[]; TRAINVIEW.idx=0; TRAINVIEW.total=0; setTrainNavEnabled(false); tvUpdate(); }
    }
    function renderMoveList(){
      try{
        const wrap = document.getElementById('moveList'); if(!wrap) return;
        const sans = Array.isArray(TRAINVIEW.san) ? TRAINVIEW.san : [];
        if(!sans.length){ wrap.innerHTML = '<span class="muted">(no moves)</span>'; return; }
        const parts = [];
        for(let i=0;i<sans.length;i+=2){
          const num = Math.floor(i/2)+1;
          const wIdx = i+1; // fens index after white move
          const bIdx = (i+1)+1; // fens index after black move
          const wSan = sans[i]||''; const bSan = sans[i+1]||'';
          const wCls = (TRAINVIEW.idx===wIdx)?'mv active':'mv';
          const bCls = (TRAINVIEW.idx===bIdx)?'mv active':'mv';
          parts.push(`<tr><td><span class="num">${num}.</span> <span class="${wCls}" data-idx="${wIdx}">${wSan}</span></td><td>${bSan?`<span class="${bCls}" data-idx="${bIdx}">${bSan}</span>`:''}</td></tr>`);
        }
        wrap.innerHTML = `<table class="ml-table"><tbody>${parts.join('')}</tbody></table>`;
        wrap.querySelectorAll('.mv').forEach(el=>{
          el.addEventListener('click', () => {
            const i = parseInt(el.getAttribute('data-idx')||'0',10)||0;
            if(!TRAINVIEW.fens.length) return;
            const clamped = Math.max(0, Math.min(i, TRAINVIEW.fens.length-1));
            TRAINVIEW.idx = clamped;
            setTimeout(()=>{ drawBoardMain(TRAINVIEW.fens[TRAINVIEW.idx]); tvUpdate(); resetTrainToggles(); }, 0);
          });
        });
      }catch{}
    }
    function updateMoveListHighlight(){
      try{
        const wrap = document.getElementById('moveList'); if(!wrap) return;
        wrap.querySelectorAll('.mv.active').forEach(el=>el.classList.remove('active'));
        const cur = wrap.querySelector(`.mv[data-idx="${TRAINVIEW.idx}"]`);
        if(cur){
          cur.classList.add('active');
          // Keep the selected move visible inside the moveList scroller only
          try{
            const cr = (typeof cur.getBoundingClientRect==='function') ? cur.getBoundingClientRect() : null;
            const pr = (typeof (wrap).getBoundingClientRect==='function') ? (wrap).getBoundingClientRect() : null;
            if(cr && pr){
              if(cr.top < pr.top){ wrap.scrollTop += (cr.top - pr.top) - 4; }
              else if(cr.bottom > pr.bottom){ wrap.scrollTop += (cr.bottom - pr.bottom) + 4; }
            }
          }catch{}
        }
      }catch{}
    }
    function resetTrainToggles(){
      try{ BOARD.arrows.user=null; BOARD.arrows.showBest=false; renderArrows(); }catch{}
      try{ document.getElementById('btnReveal')?.setAttribute('aria-pressed','false'); }catch{}
      try{ document.getElementById('btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
    }

    /********************************************************************
     * Storage (local + remote)
     ********************************************************************/
    const LS_MISTAKES = 'pmtt_mistakes';
    const LS_ATTEMPTS = 'pmtt_attempts';
    const LS_SETS = 'pmtt_sets';
    const LS_SETS_SORT = 'pmtt_sets_sort'; // 'date_desc' | 'date_asc'
    const fb = () => (window.firebaseAPI && window.firebaseAPI.ready) ? window.firebaseAPI : null;

    function loadMistakes(){ try{ return JSON.parse(localStorage.getItem(LS_MISTAKES)||'[]'); }catch{return [];} }
    function saveMistakes(arr){
      try{ arr = (arr||[]).map(ensureSeverity); }catch{}
      localStorage.setItem(LS_MISTAKES, JSON.stringify(arr));
      if(fb()) fb().saveAllMistakes(arr).catch(()=>{});
      renderStatsSetOptions(); renderStatsMistakeList(); renderStatsSummary();
    }
    function addMistakes(newOnes){
      const cur = loadMistakes();
      const seen = new Set(cur.map(m => m.fen + '|' + m.played));
      const merged = [...cur];
      const toUpload=[];
      for(const m of newOnes){
        const k = m.fen + '|' + m.played;
        if(!seen.has(k)){
          const mm = ensureSeverity({...m});
          merged.push(mm);
          toUpload.push(mm);
          // ensure de-dupe within the incoming batch too
          seen.add(k);
        }
      }
      localStorage.setItem(LS_MISTAKES, JSON.stringify(merged));
      if(fb() && toUpload.length) fb().addMistakesRemote(toUpload).catch(()=>{});
      renderMistakeList(); renderStats();
    }
    function clearAllLocal(){
      localStorage.removeItem(LS_MISTAKES);
      localStorage.removeItem(LS_ATTEMPTS);
      if(fb()) fb().clearAllRemote().catch(()=>{});
      renderMistakeList(); renderStats();
    }
    function logAttempt(mId, correct, moveUCI){
      const arr = JSON.parse(localStorage.getItem(LS_ATTEMPTS)||'[]');
      const rec = { id:mId, ts:nowTs(), correct:!!correct, move: moveUCI||null };
      arr.push(rec); localStorage.setItem(LS_ATTEMPTS, JSON.stringify(arr));
      if(fb()) fb().logAttemptRemote(mId, correct, rec.ts, moveUCI).catch(()=>{});
      renderStats();
    }
    function getAttempts(){
      try{
        const cached = JSON.parse(localStorage.getItem(LS_ATTEMPTS)||'[]');
        if(fb()){
          fb().getAttemptsRemote().then(arr => { localStorage.setItem(LS_ATTEMPTS, JSON.stringify(arr)); renderStats(); }).catch(()=>{});
        }
        return cached;
      }catch{return []}
    }

    // --- Backfill WP fields for legacy mistakes (runs in small batches) ---
    async function backfillWinProbForLegacyMistakes(maxToFix = 20, depth = 8){
      try{
        const list = loadMistakes();
        const toFix = [];
        for(const m of list){
          const needs = (typeof m.deltaWp !== 'number') || (typeof m.cpBefore === 'undefined') || (typeof m.cpAfter === 'undefined');
          if(needs) toFix.push(m);
          if(toFix.length >= maxToFix) break;
        }
        if(!toFix.length) return;

        for(const m of toFix){
          try{
            const cl = ChessLite(); cl.loadFEN(m.fen);
            let uci = null;
            if(m.played){
              const isUci = /^[a-h][1-8][a-h][1-8][qrbn]?$/i.test(m.played||'');
              uci = isUci ? m.played : cl.parseSANtoMove(m.played);
            }
            if(!uci) continue;
            const tmp = ChessLite(); tmp.loadFEN(m.fen);
            const mv = tmp.moveUci(uci);
            if(!mv || mv.ok===false) continue;
            const fenAfter = tmp.fen();

            const { cp: cpB } = await Engine.analyze(m.fen, depth);
            const { cp: cpOpp } = await Engine.analyze(fenAfter, depth);
            m.cpBefore = cpB;
            m.cpAfter = cpOpp;
            m.deltaWp = Math.max(0, winProbFromCp(cpB) - winProbFromCp(-cpOpp));
            if(getClassifier()==='wp'){
              m.severity = severityFromScores(cpB, cpOpp);
            }
          }catch{}
        }
        saveMistakes(list);
      }catch{}
    }

    window.addEventListener('firebase:mMistakesUpdated', ()=>{
      try{
        renderStatsSetOptions();
        renderStatsMistakeList();
        renderStatsSummary();
        backfillWinProbForLegacyMistakes(20, 8);
      }catch{}
    });
    window.addEventListener('firebase:attemptsUpdated', ()=>{ try{renderStats();}catch{} });
    window.addEventListener('firebase:setsUpdated', ()=>{
      try{ ACTIVE_SET = null; ACTIVE_SET_KEYS = new Set(); }catch{}
      try{renderSets(); renderSetsForTrain(); renderActiveSetInfo();}catch{}
    });
    window.addEventListener('firebase:importsUpdated', ()=>{ try{rebuildImportedTable();}catch{} });

    /********************************************************************
     * Sets (de-duped)
     ********************************************************************/
    // Key helpers: tolerate historical variations (SAN vs UCI stored in sets/records)
    const UCI_RE = /^[a-h][1-8][a-h][1-8][qrbn]?$/i;
    function ensureSeverity(m){
      try{
        if(m && (typeof m.severity === 'undefined' || m.severity === null)){
          const s = severityFromDrop(m.deltaCp);
          if(s) m.severity = s; else m.severity = null;
        }
      }catch{}
      return m;
    }
    // === NEW: snapshot + hydrate helpers ===
    function snapshotMistake(m){
      return {
        id: m.id || uid(),
        fen: m.fen, side: m.side, played: m.played, best: m.best, deltaCp: m.deltaCp, deltaWp: (typeof m.deltaWp!== 'undefined' ? m.deltaWp : null), cpBefore: (typeof m.cpBefore!=='undefined'?m.cpBefore:null), cpAfter: (typeof m.cpAfter!=='undefined'?m.cpAfter:null),
        severity: (m && typeof m.severity !== 'undefined' && m.severity !== null) ? m.severity : severityFromDrop(m?.deltaCp||0),
        pgn: m.pgn || null, gameUrl: m.gameUrl || null,
        ef: m.ef ?? 2.5, reps: m.reps ?? 0, interval: m.interval ?? 0,
        nextReview: m.nextReview ?? nowTs()
      };
    }

    async function hydrateMistakesFromSet(set){
      if(!set || !Array.isArray(set.items) || !set.items.length) return;
      const existing = loadMistakes();
      const toAdd = [];
      for(const item of set.items){
        // Use robust key comparison
        const wantKeys = new Set(keysForMistake(item));
        const found = existing.some(m => {
          const have = keysForMistake(m);
          for(const k of have){ if(wantKeys.has(k)) return true; }
          return false;
        });
        if(!found){
          const snap = {...item};
          if(typeof snap.severity === 'undefined' || snap.severity === null){
            try{ snap.severity = severityFromDrop(snap.deltaCp); }catch{ snap.severity = null; }
          }
          snap.id = snap.id || uid();
          snap.nextReview = nowTs(); // make it available in SRS immediately
          toAdd.push(snap);
        }
      }
      if(toAdd.length){
        saveMistakes([...existing, ...toAdd]);
      }
    }
    const isUci = (s) => !!(s && UCI_RE.test(String(s)));
    function normFenKey(fen){
      try{
        const toks = String(fen||'').trim().split(/\s+/);
        return [toks[0]||'', toks[1]||'', toks[2]||'', (toks[3]||'-')].join(' ');
      }catch{ return fen||''; }
    }
    function sanitizeSANKey(s){
      try{
        let out = String(s||'').trim();
        out = out.replace(/[\u00D7�]/g,'x');       // unicode times -> x
        out = out.replace(/[+#]/g,'');              // drop check/mate marks
        out = out.replace(/!!|\?\?|!\?|\?!/g,'');// drop NAG-like
        out = out.replace(/e\.p\./gi,'');         // drop en passant marker
        out = out.replace(/\s+/g,'');              // drop spaces
        // Normalize castling digits to letter O
        if(/^0-0-0$/i.test(out)) out = 'O-O-O';
        else if(/^0-0$/i.test(out)) out = 'O-O';
        return out;
      }catch{ return String(s||''); }
    }
    const keyOf = (m) => (m.fen + '|' + m.played);

    // Utility: set the Create Set button label to unique mistake count
    function updateCreateSetButtonCount(all){
      try{
        const btn = document.getElementById('btnCreateSetFromLast');
        if(!btn) return;
        const uniq = (new Set((all||[]).map(keyOf))).size;
        btn.textContent = `Create set (${uniq} mistake${uniq!==1?'s':''})`;
      }catch{}
    }
    function keysForMistake(m){
      try{
        const fen = m?.fen || '';
        const nfen = normFenKey(fen);
        const played = m?.played || '';
        const out = new Set();
        const add = (f,k)=>{ if(f && k) out.add(f + '|' + k); };
        // As-is and sanitized SAN
        add(fen, played);
        add(nfen, played);
        const sp = sanitizeSANKey(played);
        if(sp && sp!==played){ add(fen, sp); add(nfen, sp); }
        // Convert between SAN/ UCI for robust matching
        if(isUci(played)){
          try{
            const san = uciToSAN(fen, played);
            add(fen, san); add(nfen, san);
            const ss = sanitizeSANKey(san); if(ss && ss!==san){ add(fen, ss); add(nfen, ss); }
          }catch{}
        }else{
          try{
            const cl = ChessLite(); cl.loadFEN(fen);
            const uci = cl.parseSANtoMove(sp||played);
            if(uci){ add(fen, uci); add(nfen, uci); }
          }catch{}
        }
        return Array.from(out.values());
      }catch{ return [keyOf(m)]; }
    }
    function expandKeys(keys){
      const out = new Set();
      try{
        for(const k of (keys||[])){
          if(!k || typeof k !== 'string'){ continue; }
          out.add(k);
          const bar = k.indexOf('|');
          if(bar>0){
            const fen = k.slice(0, bar);
            const nfen = normFenKey(fen);
            const mv0 = k.slice(bar+1);
            const mv = mv0;
            const sp = sanitizeSANKey(mv);
            const add = (f,move)=>{ if(f && move) out.add(f + '|' + move); };
            // base + normalized-fen variants
            add(nfen, mv);
            if(sp && sp!==mv){ add(fen, sp); add(nfen, sp); }
            if(isUci(mv)){
              try{
                const san = uciToSAN(fen, mv);
                add(fen, san); add(nfen, san);
                const ss = sanitizeSANKey(san); if(ss && ss!==san){ add(fen, ss); add(nfen, ss); }
              }catch{}
            }else{
              try{
                const cl = ChessLite(); cl.loadFEN(fen);
                const uci = cl.parseSANtoMove(sp||mv);
                if(uci){ add(fen, uci); add(nfen, uci); }
              }catch{}
            }
          }
        }
      }catch{}
      return out;
    }
    async function ensureMistakesForSet(targetSet, timeoutMs){
      function hasSome(){
        const all = loadMistakes();
        if(!all || !all.length) return false;
        if(!targetSet || !targetSet.keys || !targetSet.keys.length) return all.length>0;
        const keySet = expandKeys(targetSet.keys);
        return all.some(m => {
          const ks = keysForMistake(m);
          for(const k of ks){ if(keySet.has(k)) return true; }
          return false;
        });
      }
      if(hasSome()) return;
      await new Promise((res)=>{
        let done=false;
        const onUpd=()=>{ if(!done && hasSome()){ done=true; try{ window.removeEventListener('firebase:mMistakesUpdated', onUpd); }catch{} res(); } };
        try{ window.addEventListener('firebase:mMistakesUpdated', onUpd); }catch{}
        setTimeout(()=>{ if(!done){ done=true; try{ window.removeEventListener('firebase:mMistakesUpdated', onUpd); }catch{} res(); } }, Math.max(500, timeoutMs||3000));
      });
    }
    function loadSets(){ try{ return JSON.parse(localStorage.getItem(LS_SETS)||'[]'); }catch{return [];} }
    function saveSets(arr){
      try{
        const norm = (arr||[]).map(s=>{
          const out = {...s};
          if(!Array.isArray(out.items)) out.items = [];
          for(let i=0;i<out.items.length;i++){
            const it = out.items[i] || {};
            if(typeof it.severity === 'undefined' || it.severity === null){
              try{ it.severity = severityFromDrop(it.deltaCp); }catch{ it.severity = null; }
            }
          }
          out.version = 2;
          return out;
        });
        localStorage.setItem(LS_SETS, JSON.stringify(norm));
        try{ if(fb()) fb().saveAllSets(norm).catch(()=>{}); }catch{}
      }catch{
        localStorage.setItem(LS_SETS, JSON.stringify(arr||[]));
        try{ if(fb()) fb().saveAllSets(arr).catch(()=>{}); }catch{}
      }
      renderSets();
    }

    function getSetSortOrder(){
      try{ return localStorage.getItem(LS_SETS_SORT) || 'date_desc'; }catch{ return 'date_desc'; }
    }
    function sortSetsByCreated(list){
      const order = getSetSortOrder();
      const arr = (list||[]).slice();
      arr.sort((a,b)=>{
        const ac = (a && typeof a.created==='number') ? a.created : 0;
        const bc = (b && typeof b.created==='number') ? b.created : 0;
        return order==='date_asc' ? (ac - bc) : (bc - ac);
      });
      return arr;
    }
    function initSetsSortUI(){
      const sel = document.getElementById('setsSortSelect');
      if(!sel) return;
      try{ sel.value = getSetSortOrder(); }catch{}
      sel.addEventListener('change', ()=>{
        try{ localStorage.setItem(LS_SETS_SORT, sel.value); }catch{}
        try{ renderSets(); }catch{}
        try{ renderSetsForTrain(); }catch{}
        try{ renderStatsSetOptions(); }catch{}
      });
    }

    function findExistingSetByNameAndKeys(name, keys){
      const sets = loadSets();
      const keySet = new Set(keys);
      return sets.find(s => s.name === name && s.keys.length === keySet.size && s.keys.every(k => keySet.has(k)));
    }
    function createSetFromMistakes(mistakes, name){
      const keys = Array.from(new Set(mistakes.map(keyOf)));
      const existing = findExistingSetByNameAndKeys(name||'', keys);
      if(existing) return existing; // avoid duplicates
      const items = mistakes.map(snapshotMistake);
      try{ console.debug('[client] createSetFromMistakes:', { count: items.length, sample: items.slice(0,3) }); }catch{}
      const set = {
        id: uid(),
        name: name || `Set ${new Date().toLocaleString()}`,
        keys,
        items,          // NEW: denormalized snapshot
        version: 2,     // marker for future migrations
        created: nowTs()
      };
      const sets = loadSets(); sets.unshift(set); saveSets(sets); return set;
    }

    function renderSets(){
      const tb = $('#setsTBody'); if(!tb) return;
      const sets = sortSetsByCreated(loadSets()); tb.innerHTML = '';
      let i=0; for(const s of sets){
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${++i}</td>
          <td><span class="setName" data-setid="${s.id}">${s.name}</span></td>
          <td>${s.keys.length}</td>
          <td class="tiny">${tsToDate(s.created)}</td>
          <td>
            <button class="ghost" data-act="rename" data-id="${s.id}">Rename</button>
            <button class="ghost" data-act="train" data-id="${s.id}">Train</button>
            <button class="ghost" data-act="delete" data-id="${s.id}">Delete</button>
          </td>`;
        tb.appendChild(tr);
      }
      tb.querySelectorAll('button[data-act="delete"]').forEach(btn => btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-id');
        const sets = loadSets().filter(x => x.id!==id); saveSets(sets);
        try{ if(fb()) fb().deleteSetRemote(id).catch(()=>{}); }catch{}
      }));
      tb.querySelectorAll('button[data-act="rename"]').forEach(btn => btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-id');
        const sets = loadSets();
        const k = sets.findIndex(x => x.id===id);
        if(k>=0){
          const current = sets[k].name || '';
          let nn = window.prompt('Rename set', current);
          if(typeof nn === 'string'){ nn = nn.trim(); }
          if(nn && nn.length && nn !== current){
            sets[k].name = nn; saveSets(sets);
            try{ if(fb()) fb().updateSetName(id, nn).catch(()=>{}); }catch{}
          }
        }
      }));
      async function ensureMistakesForSetLegacy(targetSet, timeoutMs){
        function hasSome(){
          const all = loadMistakes();
          if(!all || !all.length) return false;
          if(!targetSet || !targetSet.keys || !targetSet.keys.length) return all.length>0;
          const ks = new Set(targetSet.keys);
          return all.some(m => ks.has(keyOf(m)));
        }
        if(hasSome()) return;
        await new Promise((res)=>{
          let done=false; const onUpd=()=>{ if(!done && hasSome()){ done=true; try{ window.removeEventListener('firebase:mMistakesUpdated', onUpd); }catch{} res(); } };
          try{ window.addEventListener('firebase:mMistakesUpdated', onUpd); }catch{}
          setTimeout(()=>{ if(!done){ done=true; try{ window.removeEventListener('firebase:mMistakesUpdated', onUpd); }catch{} res(); } }, Math.max(500, timeoutMs||3000));
        });
      }

      tb.querySelectorAll('button[data-act="train"]').forEach(btn => btn.addEventListener('click', async () => {
        const id = btn.getAttribute('data-id');
        const s = loadSets().find(x => x.id===id); if(!s) return;
        setActiveSet(s);
        // jump to Train selection -> training mode and start SRS
        showSection('train');
        enterTrainingMode();
        renderActiveSetInfo();
        try{ const info=document.getElementById('mInfo'); if(info) info.textContent='Loading set�'; }catch{}
        await hydrateMistakesFromSet(s);
        await ensureMistakesForSet(s, 10000);
        TrainSession.start();
      }));
    }
    let ACTIVE_SET = null; let ACTIVE_SET_KEYS = new Set();
    function setActiveSet(s){
      ACTIVE_SET = s;
      ACTIVE_SET_KEYS = expandKeys((s&&s.keys)||[]);
    }
    function renderActiveSetInfo(){ const el = $('#activeSetInfo'); if(el) el.textContent = `Active set: ${ACTIVE_SET?ACTIVE_SET.name:'—'}`; }

    function renderSetsForTrain(){
      const tb = $('#trainSetsTBody'); if(!tb) return;
      tb.innerHTML = '';
      const sets = sortSetsByCreated(loadSets());
      let i=0; for(const s of sets){
        const tr = document.createElement('tr');
        tr.style.cursor = 'pointer';
        tr.classList.toggle('selected', ACTIVE_SET && s.id===ACTIVE_SET.id);
        tr.innerHTML = `<td>${++i}</td><td>${s.name}</td><td>${s.keys.length}</td>`;
        tr.addEventListener('click', () => { setActiveSet(s); renderActiveSetInfo(); renderSetsForTrain(); });
        tb.appendChild(tr);
      }
    }

    /********************************************************************
     * User-only helpers for filtering mistakes
     ********************************************************************/
    function parsePGNHeaders(pgn){
      const h={}; const re=/\[(\w+)\s+"([^"]*)"\]/g; let m; while((m=re.exec(pgn||''))) h[m[1]]=m[2]; return h;
    }
    function inferUsernames(){
      const names=[];
      const u1=$('#lichessUser')?.value.trim(); if(u1) names.push(u1.toLowerCase());
      const u2=$('#chesscomUser')?.value.trim(); if(u2) names.push(u2.toLowerCase());
      window.LAST_USERNAMES = new Set(names);
    }
    // Derive a comparable timestamp from PGN headers
    function pgnTimeMs(pgn){
      try{
        const h = parsePGNHeaders(pgn||'');
        const norm = (d)=> (d||'').replace(/\?/g,'01').replace(/\./g,'-');
        function toMs(d,t){
          const dd = norm(d); if(!dd) return 0;
          let iso = dd;
          if(/^\d{4}-\d{2}-\d{2}$/.test(dd)){
            const tt = (t||'12:00:00');
            const tfix = /^\d{2}:\d{2}(:\d{2})?$/.test(tt) ? (tt.length===5?tt+':00':tt) : '12:00:00';
            iso = dd + 'T' + tfix + 'Z';
          }
          const ms = Date.parse(iso);
          return isNaN(ms) ? 0 : ms;
        }
        const utc = toMs(h.UTCDate, h.UTCTime);
        if(utc) return utc;
        const dateOnly = toMs(h.Date, h.UTCTime || '12:00:00');
        if(dateOnly) return dateOnly;
        const end = toMs(h.EndDate || h.EventDate, h.EndTime || '12:00:00');
        if(end) return end;
      }catch{}
      return 0;
    }
    function userSideForPGN(pgn){
      try{
        const h=parsePGNHeaders(pgn||''); const w=(h.White||'').toLowerCase(); const b=(h.Black||'').toLowerCase();
        const us = window.LAST_USERNAMES || new Set();
        for(const name of us){ if(!name) continue; if(w===name || w.includes(name)) return 'w'; if(b===name || b.includes(name)) return 'b'; }
        return null;
      }catch{return null;}
    }
    function filterMistakesToUserOnly(ms){
      if(!ms || !ms.length) return [];
      const out=[];
      for(const m of ms){
        const side = userSideForPGN(m.pgn||'');
        if(side && m.side===side) out.push(m);
      }
      return out;
    }

    /********************************************************************
     * ChessLite minimal engine (FEN, legal moves, SAN parsing)
     ********************************************************************/
    function ChessLite(){
      const FILES='abcdefgh';
      let board = new Array(64).fill(null);
      let side='w';
      let castling={K:true,Q:true,k:true,q:true};
      let ep=-1, halfmove=0, fullmove=1;

      function idx(file, rank){ return (7-(rank-1))*8+file; }
      function sqToIdx(sq){ const f=FILES.indexOf(sq[0]); const r=parseInt(sq[1],10); return idx(f,r); }
      function idxToSq(i){ const r=8-Math.floor(i/8); const f=i%8; return FILES[f]+r; }
      function pieceColor(pc){ return pc===pc?.toUpperCase()?'w':'b'; }
      function reset(){ loadFEN("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"); }
      function loadFEN(f){
        board.fill(null);
        const parts=f.trim().split(/\s+/);
        const rows=parts[0].split('/');
        for(let r=0;r<8;r++){
          let file=0;
          for(const ch of rows[r]){
            if(/[1-8]/.test(ch)) file+=parseInt(ch,10);
            else{ board[r*8+file]=ch; file++; }
          }
        }
        side=parts[1]||'w';
        castling={K:false,Q:false,k:false,q:false};
        if(parts[2]&&parts[2]!=='-'){ for(const c of parts[2]) if(castling.hasOwnProperty(c)) castling[c]=true; }
        ep=(parts[3]&&parts[3]!=='-')?sqToIdx(parts[3]):-1;
        halfmove=parts[4]?parseInt(parts[4],10):0;
        fullmove=parts[5]?parseInt(parts[5],10):1;
        return true;
      }
      function fen(){
        let s='';
        for(let r=0;r<8;r++){
          let empty=0;
          for(let f=0;f<8;f++){
            const p=board[r*8+f];
            if(!p) empty++;
            else{ if(empty){s+=empty;empty=0;} s+=p; }
          }
          if(empty) s+=empty;
          if(r<7) s+='/';
        }
        s+=' '+side+' ';
        let cstr=''; if(castling.K)cstr+='K'; if(castling.Q)cstr+='Q'; if(castling.k)cstr+='k'; if(castling.q)cstr+='q';
        s+=(cstr||'-');
        s+=' '+(ep>=0?idxToSq(ep):'-');
        s+=' '+halfmove+' '+fullmove;
        return s;
      }
      function rcOf(i){ return { r:Math.floor(i/8), c:i%8 }; }
      function inBounds(r,c){ return r>=0&&r<8&&c>=0&&c<8; }
      function kingIndex(color){ const K=(color==='w')?'K':'k'; for(let i=0;i<64;i++) if(board[i]===K) return i; return -1; }
      function squareAttacked(i, by){
        const {r,c}=rcOf(i);
        // pawns
        if(by==='w'){ const rr=r+1; if(inBounds(rr,c-1)&&board[rr*8+c-1]==='P')return true; if(inBounds(rr,c+1)&&board[rr*8+c+1]==='P')return true;}
        else{ const rr=r-1; if(inBounds(rr,c-1)&&board[rr*8+c-1]==='p')return true; if(inBounds(rr,c+1)&&board[rr*8+c+1]==='p')return true;}
        // knights
        const nn=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for(const [dr,dc] of nn){ const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc))continue; const p=board[rr*8+cc]; if(p && ((by==='w'&&p==='N')||(by==='b'&&p==='n'))) return true; }
        // bishops/queens
        const di=[[-1,-1],[-1,1],[1,-1],[1,1]];
        for(const [dr,dc] of di){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const p=board[rr*8+cc]; if(p){ if((by==='w'&&('BQ'.includes(p)))||(by==='b'&&('bq'.includes(p)))) return true; break;} rr+=dr; cc+=dc; } }
        // rooks/queens
        const or=[[-1,0],[1,0],[0,-1],[0,1]];
        for(const [dr,dc] of or){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const p=board[rr*8+cc]; if(p){ if((by==='w'&&('RQ'.includes(p)))||(by==='b'&&('rq'.includes(p)))) return true; break;} rr+=dr; cc+=dc; } }
        // king
        for(let dr=-1;dr<=1;dr++){ for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0)continue; const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc))continue; const p=board[rr*8+cc]; if(p && ((by==='w'&&p==='K')||(by==='b'&&p==='k'))) return true; } }
        return false;
      }
      function inCheck(color){ const ki=kingIndex(color); return squareAttacked(ki, color==='w'?'b':'w'); }

      function clone(){ return { board:board.slice(), side, castling:{...castling}, ep, halfmove, fullmove }; }
      function restore(s){ board=s.board.slice(); side=s.side; castling={...s.castling}; ep=s.ep; halfmove=s.halfmove; fullmove=s.fullmove; }

      function makeMove(from, to, promotion){
        const prev=clone();
        const p=board[from];
        const pc=pieceColor(p);
        const cap=board[to];

        // en passant capture
        if((p==='P'||p==='p')){
          const {r:rf,c:cf}=rcOf(from); const {r:rt,c:ct}=rcOf(to);
          if(cf!==ct && !cap){ const capIdx = pc==='w' ? to+8 : to-8; board[capIdx]=null; }
        }
        // move piece
        board[to]=board[from]; board[from]=null;

        // promotion
        if(promotion){ board[to] = (pc==='w'?promotion.toUpperCase():promotion.toLowerCase()); }

        // castling rook move
        if(p==='K' && Math.abs(rcOf(to).c - rcOf(from).c)===2){
          if(rcOf(to).c===6){ board[sqToIdx('f1')]='R'; board[sqToIdx('h1')]=null; }
          else { board[sqToIdx('d1')]='R'; board[sqToIdx('a1')]=null; }
          castling.K=false; castling.Q=false;
        }
        if(p==='k' && Math.abs(rcOf(to).c - rcOf(from).c)===2){
          if(rcOf(to).c===6){ board[sqToIdx('f8')]='r'; board[sqToIdx('h8')]=null; }
          else { board[sqToIdx('d8')]='r'; board[sqToIdx('a8')]=null; }
          castling.k=false; castling.q=false;
        }

        // update ep
        ep=-1;
        if(p==='P' || p==='p'){
          const {r:rf}=rcOf(from); const {r:rt}=rcOf(to);
          if(Math.abs(rt-rf)===2) ep = pc==='w' ? (to+8) : (to-8);
        }

        // castling rights
        const fromSq=idxToSq(from), toSq=idxToSq(to);
        if(p==='K'){ castling.K=false; castling.Q=false; }
        if(p==='k'){ castling.k=false; castling.q=false; }
        if(fromSq==='h1'||toSq==='h1') castling.K=false;
        if(fromSq==='a1'||toSq==='a1') castling.Q=false;
        if(fromSq==='h8'||toSq==='h8') castling.k=false;
        if(fromSq==='a8'||toSq==='a8') castling.q=false;

        if((p==='P'||p==='p') || cap) halfmove=0; else halfmove++;
        if(side==='b') fullmove++;
        side = side==='w'?'b':'w';

        return prev;
      }

      function generate(){
        const moves=[];
        const us=side, them=side==='w'?'b':'w';
        for(let i=0;i<64;i++){
          const p=board[i]; if(!p||pieceColor(p)!==us) continue;
          const {r,c}=rcOf(i);

          const add=(from,to,promotion)=>{
            // Determine captured piece (including en passant) on the current board state
            let captured=null;
            const targetPiece = board[to];
            if(targetPiece && pieceColor(targetPiece)===them){
              captured = targetPiece;
            } else {
              // En passant: pawn moves diagonally to empty square equal to ep target
              if((p==='P'||p==='p') && to===ep && !targetPiece){
                captured = (us==='w') ? 'p' : 'P';
              }
            }
            const prev=clone(); makeMove(from,to,promotion);
            const legal=!inCheck(us); restore(prev);
            if(legal){ moves.push({from, to, promotion:promotion||null, piece:p, captured}); }
          };

          if(p==='P'||p==='p'){
            const forward=(us==='w')?-1:1; const start=(us==='w')?6:1; const promo=(us==='w')?0:7;
            const oneR=r+forward;
            if(inBounds(oneR,c) && !board[oneR*8+c]){
              if(oneR===promo){ for(const pr of ['q','r','b','n']) add(i, oneR*8+c, pr); }
              else add(i, oneR*8+c);
              const twoR=r+2*forward;
              if(r===start && !board[twoR*8+c]) add(i, twoR*8+c);
            }
            for(const dc of [-1,1]){
              const rr=r+forward, cc=c+dc; if(!inBounds(rr,cc)) continue;
              const t=rr*8+cc;
              if(board[t] && pieceColor(board[t])===them){
                if(rr===promo){ for(const pr of ['q','r','b','n']) add(i,t,pr); }
                else add(i,t);
              }else if(t===ep){ add(i,t); }
            }
          }else if(p==='N'||p==='n'){
            const NN=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for(const [dr,dc] of NN){ const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc)) continue; const t=rr*8+cc; if(!board[t]||pieceColor(board[t])!==us) add(i,t); }
          }else if(p==='B'||p==='b'){
            const D=[[-1,-1],[-1,1],[1,-1],[1,1]];
            for(const [dr,dc] of D){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const t=rr*8+cc; if(board[t]){ if(pieceColor(board[t])!==us) add(i,t); break; } add(i,t); rr+=dr; cc+=dc; } }
          }else if(p==='R'||p==='r'){
            const D=[[-1,0],[1,0],[0,-1],[0,1]];
            for(const [dr,dc] of D){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const t=rr*8+cc; if(board[t]){ if(pieceColor(board[t])!==us) add(i,t); break; } add(i,t); rr+=dr; cc+=dc; } }
          }else if(p==='Q'||p==='q'){
            const D=[[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
            for(const [dr,dc] of D){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const t=rr*8+cc; if(board[t]){ if(pieceColor(board[t])!==us) add(i,t); break; } add(i,t); rr+=dr; cc+=dc; } }
          }else if(p==='K'||p==='k'){
            for(let dr=-1;dr<=1;dr++){ for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0)continue; const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc))continue; const t=rr*8+cc; if(!board[t]||pieceColor(board[t])!==us) add(i,t); } }
            if(us==='w' && r===7 && c===4){
              if(castling.K && !board[sqToIdx('f1')] && !board[sqToIdx('g1')] && !inCheck('w') && !squareAttacked(sqToIdx('f1'),'b') && !squareAttacked(sqToIdx('g1'),'b')) add(i,sqToIdx('g1'));
              if(castling.Q && !board[sqToIdx('d1')] && !board[sqToIdx('c1')] && !board[sqToIdx('b1')] && !inCheck('w') && !squareAttacked(sqToIdx('d1'),'b') && !squareAttacked(sqToIdx('c1'),'b')) add(i,sqToIdx('c1'));
            }
            if(us==='b' && r===0 && c===4){
              if(castling.k && !board[sqToIdx('f8')] && !board[sqToIdx('g8')] && !inCheck('b') && !squareAttacked(sqToIdx('f8'),'w') && !squareAttacked(sqToIdx('g8'),'w')) add(i,sqToIdx('g8'));
              if(castling.q && !board[sqToIdx('d8')] && !board[sqToIdx('c8')] && !board[sqToIdx('b8')] && !inCheck('b') && !squareAttacked(sqToIdx('d8'),'w') && !squareAttacked(sqToIdx('c8'),'w')) add(i,sqToIdx('c8'));
            }
          }
        }
        return moves.map(m=>({
          from: idxToSq(m.from), to: idxToSq(m.to),
          uci: idxToSq(m.from)+idxToSq(m.to)+(m.promotion?m.promotion:''),
          piece: m.piece, promotion: m.promotion||null,
          captured: m.captured
        }));
      }

      function moveUci(uci){
        const from = sqToIdx(uci.slice(0,2)), to = sqToIdx(uci.slice(2,4));
        const promo = uci.length>4 ? uci[4] : null;
        const legal = generate().filter(m => m.uci === (uci));
        if(legal.length){
          const prev = makeMove(from,to,promo);
          return {ok:true, prev};
        }
        return {ok:false};
      }

      function parseSANtoMove(san){
        san=san.trim();
        if(/^O-O-O|^0-0-0/.test(san)){ return (side==='w'?'e1c1':'e8c8'); }
        if(/^O-O|^0-0/.test(san)){ return (side==='w'?'e1g1':'e8g8'); }
        san = san.replace(/[+#]|!!|\?\?|!\?|\?!/g, '');
        let promo=null; const pm=san.match(/=([NBRQ])/); if(pm){ promo=pm[1].toLowerCase(); san=san.replace(/=([NBRQ])/, ''); }
        const dm=san.match(/([a-h][1-8])$/); if(!dm) return null; const dest=dm[1]; san=san.slice(0, san.length-dest.length);
        let pieceLetter='P'; if(/^[NBRQK]/.test(san)){ pieceLetter=san[0]; san=san.slice(1); }
        san=san.replace('x','');
        let disFile=null, disRank=null;
        if(san.length===2){ if(/[a-h]/.test(san[0]))disFile=san[0]; if(/[1-8]/.test(san[0]))disRank=san[0]; if(/[a-h]/.test(san[1]))disFile=san[1]; if(/[1-8]/.test(san[1]))disRank=san[1]; }
        else if(san.length===1){ if(/[a-h]/.test(san))disFile=san; if(/[1-8]/.test(san))disRank=san; }

        const legal=generate().filter(m=>m.to===dest).filter(m=>{
          const want=pieceLetter; const isPawn=want==='P';
          const okPiece = isPawn ? /[Pp]/.test(m.piece) :
            (want==='N'?/[Nn]/.test(m.piece): want==='B'?/[Bb]/.test(m.piece):
             want==='R'?/[Rr]/.test(m.piece): want==='Q'?/[Qq]/.test(m.piece): /[Kk]/.test(m.piece));
          if(!okPiece) return false;
          if(disFile && m.from[0]!==disFile) return false;
          if(disRank && m.from[1]!==disRank) return false;
          if(promo && m.promotion!==promo) return false;
          return true;
        });
        return (legal[0] && legal[0].uci) || null;
      }

      function loadPGN(pgn){
        const text = (pgn||'').replace(/\r/g,'').replace(/\[(.|\n)*?\]\s*/g,' ').trim();
        const tokens=[]; let i=0;
        while(i<text.length){
          const ch=text[i];
          if(ch==='{' ){ let j=i+1; while(j<text.length&&text[j]!=='}') j++; tokens.push({type:'comment', value:text.slice(i+1,j)}); i=j+1; continue; }
          if(/\s/.test(ch)){ i++; continue; }
          const num=text.slice(i).match(/^\d+\.(\.\.)?/); if(num){ i+=num[0].length; continue; }
          const res=text.slice(i).match(/^(1-0|0-1|1\/2-1\/2|\*)/); if(res){ i+=res[0].length; continue; }
          const nag=text.slice(i).match(/^\$\d+/); if(nag){ i+=nag[0].length; continue; }
          let j=i; while(j<text.length && !/\s|\{/.test(text[j])) j++;
          tokens.push({type:'san', value:text.slice(i,j)}); i=j;
        }
        reset();
        const moves=[];
        for(const t of tokens){
          if(t.type==='san'){
            const uci=parseSANtoMove(t.value);
            if(!uci) continue;
            const mv=moveUci(uci);
            if(!mv.ok) continue;
            moves.push({uci, san:t.value, fenAfter:fen()});
          }else{
            moves.push({comment:t.value});
          }
        }
        return moves;
      }

      return {
        reset, loadFEN, fen, turn:()=>side,
        moves: generate, moveUci, parseSANtoMove, loadPGN,
        idxToSq, sqToIdx, inCheck
      }
    }

    /********************************************************************
     * SAN helper (UCI -> SAN)
     ********************************************************************/
    function uciToSAN(fen, uci){
      if(!fen || !uci) return uci || '—';
      const cl = ChessLite(); cl.loadFEN(fen);
      const legal = cl.moves();
      const mv = legal.find(m => m.uci === uci);
      if(!mv){ try { return uci.slice(2,4); } catch { return uci; } }
      // Castling
      if((mv.piece==='K' || mv.piece==='k') && ((mv.from==='e1'&& (mv.to==='g1'||mv.to==='c1')) || (mv.from==='e8' && (mv.to==='g8'||mv.to==='c8')))){
        return (mv.to==='g1'||mv.to==='g8') ? 'O-O' : 'O-O-O';
      }
      const isPawn = /[Pp]/.test(mv.piece);
      const pieceLetter = isPawn ? '' : mv.piece.toUpperCase();
      // Disambiguation
      let disamb='';
      if(!isPawn){
        const competing = legal.filter(x => x.to===mv.to && x.piece===mv.piece && x.uci!==mv.uci);
        if(competing.length){
          const sameFile = competing.some(x => x.from[0]===mv.from[0]);
          const sameRank = competing.some(x => x.from[1]===mv.from[1]);
          if(!sameFile) disamb = mv.from[0];
          else if(!sameRank) disamb = mv.from[1];
          else disamb = mv.from;
        }
      }
      const isCapture = !!mv.captured;
      let san = '';
      if(isPawn){ san = (isCapture ? (mv.from[0] + 'x') : '') + mv.to; }
      else { san = pieceLetter + disamb + (isCapture?'x':'') + mv.to; }
      if(mv.promotion){ san += '=' + mv.promotion.toUpperCase(); }
      const tmp = ChessLite(); tmp.loadFEN(fen); tmp.moveUci(uci);
      const opp = tmp.turn(); const inCheck = tmp.inCheck(opp); const hasReply = tmp.moves().length>0;
      if(inCheck) san += hasReply ? '+' : '#';
      return san;
    }

    /********************************************************************
     * Stockfish wrapper
     ********************************************************************/
    const Engine = (() => {
      let sf=null, ready=false, busy=false, lastScore={cp:0,mate:null}, resolvers=[], initPromise=null;
      function ensure(){
        if(initPromise) return initPromise;
        initPromise = new Promise(async (resolve) => {
          try{
            if(window.SF_BACKEND_URL){ ready=true; $('#engineStateServer').textContent='server'; return resolve(true); }
          }catch{}
          try{
            if(typeof Stockfish==='function'){
              try{
                // Ensure engine assets resolve from /engine/
                Stockfish.locateFile = (path, prefix)=> '/engine/' + String(path).split('/').pop();
                // Help Emscripten resolve pthread helper relative to this script
                Stockfish.mainScriptUrlOrBlob = '/engine/stockfish.js';
              }catch{}
              sf = Stockfish();
            } else {
              sf = null;
            }
            if(!sf){ /* do not show error text in UI */ return resolve(false); }
            sf.onmessage = (e) => {
              const line=(''+(e.data||e)).trim();
              if(line==='uciok'){ sf.postMessage('isready'); return; }
              if(line==='readyok'){ ready=true; $('#engineStateServer').textContent='ready'; return; }
              if(line.startsWith('info')){
                const mMate=line.match(/score\s+mate\s+(-?\d+)/);
                const mCp=line.match(/score\s+cp\s+(-?\d+)/);
                if(mMate){ lastScore={mate:parseInt(mMate[1],10),cp:mMate[1][0]==='-'?-10000:10000}; }
                else if(mCp){ lastScore={cp:parseInt(mCp[1],10),mate:null}; }
              }
              if(line.startsWith('bestmove')){
                const bm=line.split(' ')[1]; const r=resolvers.shift(); busy=false; if(r) r({bestmove:bm, score:lastScore});
              }
            };
            sf.postMessage('uci');
            const t0=Date.now(); while(!ready && (Date.now()-t0)<4000){ await sleep(20); }
            $('#engineStateServer').textContent = ready ? 'ready' : 'loading…';
            resolve(true);
          }catch(err){ /* suppress Engine:error in UI */ resolve(false); }
        });
        return initPromise;
      }
      async function analyze(fen, depth=12){
        await ensure();
        while(busy) await sleep(5);
        if(sf){
          busy=true; lastScore={cp:0,mate:null};
          sf.postMessage('ucinewgame');
          sf.postMessage('position fen ' + fen);
          const p=new Promise(res=>resolvers.push(res));
          sf.postMessage('go depth '+depth);
          const out=await p;
          return { cp:(out.score.mate!==null?(out.score.mate>0?10000:-10000):out.score.cp), bestmove: out.bestmove };
        }
        // Server (Cloud Run)
        const base=(window.SF_BACKEND_URL||'').replace(/\/$/,'');
        const url=`${base}/bestmove`;
        const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({fen,depth})});
        const data=await res.json(); return { cp:data.cp??0, bestmove:data.bestmove };
      }
      return { analyze, ensure };
    })();

    /********************************************************************
     * PGN helpers & analysis (user-only)
     ********************************************************************/
    const DEFAULT_SEV={ inacc:50, mistake:150, blunder:300 };
    const DEFAULT_SEV_WP={ inacc:10, mistake:20, blunder:30 }; // percent
    function getSev(){
      try{
        const fromLs = JSON.parse(localStorage.getItem('pmtt_sev')||'{}');
        let base = {...DEFAULT_SEV, ...fromLs};
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          if(p && p.analysisThresholds && typeof p.analysisThresholds==='object'){
            base = {...base, ...p.analysisThresholds};
          }
        }catch{}
        return base;
      }catch{ return DEFAULT_SEV; }
    }
    function severityFromDrop(cp){ const T=getSev(); const x=Math.abs(Math.round(cp)); if(x>=T.blunder) return 'blunder'; if(x>=T.mistake) return 'mistake'; if(x>=T.inacc) return 'inaccuracy'; return null; }
    function getSevWp(){
      try{ const d=JSON.parse(localStorage.getItem('pmtt_sev_wp')||'{}'); return { inacc: Number.isFinite(d.inacc)?d.inacc:10, mistake: Number.isFinite(d.mistake)?d.mistake:20, blunder: Number.isFinite(d.blunder)?d.blunder:30 }; }catch{ return DEFAULT_SEV_WP; }
    }
    function getClassifier(){
      try{
        const v = localStorage.getItem('pmtt_classifier');
        if(v === 'cp' || v === 'wp') return v;
        return 'wp';
      }catch{ return 'wp'; }
    }
    function winProbFromCp(cp){ const k=0.00368208; const x=Number(cp)||0; const t=2/(1+Math.exp(-k*x))-1; return 50+50*t; }
    function severityFromScores(cpBefore, cpAfter){
      const cls = getClassifier();
      if(cls==='wp'){
        try{
          const pB = winProbFromCp(Number(cpBefore)||0);
          const pA = winProbFromCp(-(Number(cpAfter)||0));
          const drop = Math.max(0, pB - pA);
          const T = getSevWp();
          if(drop >= T.blunder) return 'blunder';
          if(drop >= T.mistake) return 'mistake';
          if(drop >= T.inacc)   return 'inaccuracy';
          return null;
        }catch{}
      }
      const dropCp = Math.max(0, (Number(cpBefore)||0) + (Number(cpAfter)||0));
      return severityFromDrop(dropCp);
    }
    function formatWinProbDrop(v){ const n=Number(v)||0; if(!Number.isFinite(n)||n<0) return '-'; return `${Math.round(n)}%`; }
    function formatDeltaForDisplay(m){
      const cls=getClassifier();
      if(cls==='wp'){
        if(m && typeof m.deltaWp==='number') return formatWinProbDrop(m.deltaWp);
        if(m && typeof m.cpBefore!=='undefined' && typeof m.cpAfter!=='undefined'){
          try{
            const dwp = Math.max(0, winProbFromCp(Number(m.cpBefore)||0) - winProbFromCp(-(Number(m.cpAfter)||0)));
            return formatWinProbDrop(dwp);
          }catch{}
        }
        return '-';
      }
      return formatCentipawnLoss(m?.deltaCp||0);
    }
    function formatBothDelta(m){
      const cp = formatCentipawnLoss(m?.deltaCp||0);
      let wpTxt = '-';
      if(typeof m?.deltaWp !== 'undefined' && m.deltaWp !== null){
        wpTxt = formatWinProbDrop(m.deltaWp);
      } else if(typeof m?.cpBefore !== 'undefined' && typeof m?.cpAfter !== 'undefined'){
        try{ const dwp = Math.max(0, winProbFromCp(Number(m.cpBefore)||0) - winProbFromCp(-(Number(m.cpAfter)||0))); wpTxt = formatWinProbDrop(dwp); }catch{}
      }
      return `${cp} | ${wpTxt}`;
    }

    // Format deltaCp (positive drop) as "centipawn loss" (negative value in pawns)
    function formatCentipawnLoss(deltaCp){
      const cp = Number(deltaCp)||0; // delta in centipawns (positive means worse)
      const loss = -(cp)/100;        // convert to pawns and invert sign
      const abs = Math.abs(loss);
      if(loss === 0) return '0';
      return abs < 1 ? loss.toFixed(1) : loss.toFixed(2);
    }

    async function analyzeOnBackend(pgns){
      const url=`${window.FN_BASE}/analyzePGNs`;
      try{ console.info('[backend] Starting analysis via Functions:', url); }catch{}
      const thr=getSev();
      const depth = parseInt(window.getAnalysisDepth?.()||12,10)||12;
      const cls = getClassifier();
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({pgns,depth,thresholds:thr, classifier: cls, wpThresholds:(cls==='wp'? getSevWp(): undefined)})});
      if(!res.ok) throw new Error(`analyzePGNs failed ${res.status}`);
      try{ const v = res.headers && res.headers.get && res.headers.get('X-Stockfish-Version'); if(v) console.info('[backend] Stockfish version (header):', v); }catch{}
      const json=await res.json();
      try{ if(json && json.engineVersion){ console.info('[backend] Stockfish version (body):', json.engineVersion); } }catch{}
      const arr = json.mistakes||[];
      try{ console.debug('[client] analyzeOnBackend: got', arr.length, 'mistakes; sample:', arr.slice(0,3)); }catch{}
      try{
        arr.forEach(m=>{
          if((typeof m.deltaWp === 'undefined' || m.deltaWp === null) && typeof m.cpBefore !== 'undefined' && typeof m.cpAfter !== 'undefined'){
            try{ m.deltaWp = Math.max(0, winProbFromCp(Number(m.cpBefore)||0) - winProbFromCp(-(Number(m.cpAfter)||0))); }catch{}
          }
        });
      }catch{}
      return arr;
    }

    /********************************************************************
     * Live Engine (WASM) analysis for Train board (Worker-based)
     ********************************************************************/
    const EngineLive = (() => {
      const DEBUG = (window.DEBUG_ENGINE ?? true);
      let __seq = 0;
      const ts = () => {
        try{ return new Date().toISOString() + ' +' + (Math.round((performance.now?.()||0))+'ms'); }catch{ return new Date().toISOString(); }
      };
      const dlog = (...args)=>{ try{ if(DEBUG) console.log('[EngineLive]', ts(), (++__seq)+':', ...args); }catch{} };
      const derr = (...args)=>{ try{ if(DEBUG) console.error('[EngineLive]', ts(), (++__seq)+':', ...args); }catch{} };

      let sf = null, ready = false, active = false, pending = false;
      let gotUci = false;
      let queuedFen = null;
      let curFen = null, analyzeTimer = null;
      let handshakeToken = 0;
      let readyRetryTimers = [];
      let lastRestartAt = 0;
      let restartCount = 0;
      const lines = new Map(); // multipv -> {scoreStr, pvUci:[], pvSan:[]}
      let engineName = '-';
      let lastNps = 0;
      let curDepth = 0; // current depth reported by engine
      let curSelDepth = 0; // optional seldepth
      const LS_ENG_PV = 'pmtt_eng_pv';
      const LS_ENG_DEPTH = 'pmtt_eng_depth';
      const LS_ENG_ARROWS = 'pmtt_eng_arrows';
      const LS_ENG_THREADS = 'pmtt_eng_threads';
      const LS_ENG_HASH = 'pmtt_eng_hash';
      function loadPv(){ try{ return Math.max(1, Math.min(10, parseInt(localStorage.getItem(LS_ENG_PV)||'',10)||3)); }catch{ return 3; } }
      function loadDepth(){ try{ return Math.max(1, Math.min(100, parseInt(localStorage.getItem(LS_ENG_DEPTH)||'',10)||16)); }catch{ return 16; } }
      function loadArrows(){ try{ return Math.max(0, Math.min(10, parseInt(localStorage.getItem(LS_ENG_ARROWS)||'',10)||1)); }catch{ return 1; } }
      function loadThreads(){ try{ const hc=(navigator.hardwareConcurrency||0)|0; const maxThr=hc>0?Math.min(32,hc):32; const v=parseInt(localStorage.getItem(LS_ENG_THREADS)||'',10)||1; return Math.max(1, Math.min(maxThr, v)); }catch{ return 1; } }
      function loadHash(){ try{ return Math.max(16, Math.min(2048, parseInt(localStorage.getItem(LS_ENG_HASH)||'',10)||128)); }catch{ return 128; } }
      let multiPV = loadPv();
      let depth = loadDepth();
      let arrowCount = Math.min(loadArrows(), multiPV);
      let threads = loadThreads();
      let hashMB = loadHash();

      function setState(txt){
        dlog('setState', 'state ->', txt, '| flags:', {ready, active, pending, gotUci});
        try{ const s = $('#engineStateLive'); if(s) s.textContent = txt; }catch{}
        try{ if(txt==='off'||txt==='error'||txt==='messageerror'){ evalBarVisible(false); } }catch{}
      }
      function clearUI(){ try{ const el=$('#engineLines'); if(el) el.textContent=''; }catch{} }
      function updateMeta(){
        try{ const m=$('#engineMeta'); if(m) m.textContent = engineName; }catch{}
        try{ const p=$('#enginePerf'); if(p){ const knps=Math.round(lastNps/1000); p.textContent = `${knps} kn/s`; } }catch{}
        try{ const d=$('#engineDepth'); if(d){ d.textContent = `depth: ${depth}/${curDepth||0}`; } }catch{}
      }
      function clearReadyRetryTimers(){ try{ readyRetryTimers.forEach(t=>clearTimeout(t)); readyRetryTimers=[]; }catch{} }

      function recalcEngineArrowsFromLines(){
        try{
          if(!arrowCount || arrowCount<=0){ BOARD.arrows.engine=null; renderArrows(); return; }
          const arr=[];
          for(let i=1;i<=multiPV;i++){
            const ln=lines.get(i);
            const mv=(ln && Array.isArray(ln.pvUci) && ln.pvUci.length)? ln.pvUci[0] : null;
            if(mv) arr.push(mv);
            if(arr.length>=arrowCount) break;
          }
          BOARD.arrows.engine = arr.length? arr : null;
          renderArrows();
        }catch{}
      }

      function restartWorker(reason){
        try{
          const now=Date.now();
          if(now - lastRestartAt < 1500){ dlog('restartWorker throttled'); return; }
          lastRestartAt = now;
          restartCount++;
        }catch{}
        dlog('restartWorker', { reason, restartCount });
        try{ clearReadyRetryTimers(); }catch{}
        try{ if(sf && sf.terminate){ sf.terminate(); } }catch{}
        sf = null; ready = false; gotUci = false;
        setState('loading');
        const ok = ensure();
        if(ok && active && curFen){
          // Re-run analysis once new worker comes up
          analyzeDebounced(curFen);
        }
      }
      function formatScore(line){
        const mMate=line.match(/score\s+mate\s+(-?\d+)/);
        if(mMate){ const n=parseInt(mMate[1],10); return (n>0?`#${n}`:`#-${Math.abs(n)}`); }
        const mCp=line.match(/score\s+cp\s+(-?\d+)/);
        const cp = mCp? parseInt(mCp[1],10):0;
        const pawns = (cp/100).toFixed(2);
        return (cp>=0?`+${pawns}`:pawns);
      }
      function pvToSANs(fen, pvUci){
        try{
          const out=[]; let cur = fen; const cl=ChessLite(); cl.loadFEN(cur);
          for(const u of pvUci){
            out.push(uciToSAN(cur, u));
            const mv=cl.moveUci(u); if(!mv.ok) break; cur = cl.fen();
          }
          return out;
        }catch{ return pvUci; }
      }
      function clearReadyRetryTimers(){ try{ readyRetryTimers.forEach(t=>clearTimeout(t)); readyRetryTimers=[]; }catch{} }

      function updateUI(){
        const el=$('#engineLines'); if(!el) return;
        const keys=Array.from({length: multiPV}, (_,i)=>i+1);
        const parts=[];
        for(const k of keys){
          const ln=lines.get(k); if(!ln) continue;
          const san = (ln.pvSan||[]).slice(0,6).join(' ');
          const scoreOut = (ln.scoreStrW || ln.scoreStr);
          parts.push(`${k}. ${scoreOut}  ${san}`);
        }
        el.textContent = parts.join("\n");
      }

      function ensure(){
        if(sf) return true;

        // Create dedicated worker that loads stockfish.js and resolves wasm locally
        try{
          // Use our bridge worker so stdout/stderr are forwarded to main thread
          // and engine assets resolve relative to /engine/
          const __wv = (function(){ try{ if(DEBUG){ window.ENGINE_WV = window.ENGINE_WV || Date.now(); return '?v='+window.ENGINE_WV; } }catch{} return ''; })();
          // Use the engine script itself as the worker. Pass wasm path via location.hash.
          // This matches Stockfish.js 17.x boot logic in worker context.
          const wasmPath = '/engine/stockfish.wasm';
          const workerUrl = '/engine/stockfish.js' + __wv + '#' + encodeURIComponent(wasmPath);
          sf = new Worker(workerUrl);
          try{ dlog('worker url', workerUrl); }catch{}
          // Expose for DevTools validation
          try{ window._engineWorker = sf; }catch{}
          dlog('worker created');
        }catch(err){
          setState('worker error');
          derr('worker creation failed', err);
          try{
            const el=$('#engineLines');
            if(el) el.textContent = 'Failed to create Stockfish worker: ' + (err && err.message ? err.message : String(err));
          }catch{}
          return false;
        }

        sf.onmessage = (e) => {
          const raw = (e && e.data != null ? e.data : e);
          const line = (''+raw).trim();
          if(DEBUG && line) dlog('onmessage', 'worker ->', line.slice(0,500));
          if(line === '__bridge_oob__' || line === '__bridge_abort__' || /^stockfish worker abort:/i.test(line)){
            restartWorker('bridge-signal:'+line);
            return;
          }

          if(line === 'uciok'){ gotUci=true; try{ sf.postMessage('isready'); }catch{} return; }
          if(line === 'readyok'){
            ready=true; setState('ready');
            clearReadyRetryTimers();
            // If a position is queued (e.g. after stop/isready handshake), start analysis now
            if(queuedFen){ const f=queuedFen; queuedFen=null; goNow(f); }
            return;
          }

          // Capture engine identity
          {
            const m = line.match(/^id\s+name\s+(.+)$/i);
            if(m){ engineName = m[1].trim(); updateMeta(); }
          }

          if(line.startsWith('info')){
            if(!active) return;
            // Track perf/depth from any info line
            try{ const md=line.match(/\bdepth\s+(\d+)/); if(md){ const nd=parseInt(md[1],10)||0; if(nd>curDepth){ curDepth=nd; updateMeta(); } } }catch{}
            try{ const msd=line.match(/\bseldepth\s+(\d+)/); if(msd){ const nsd=parseInt(msd[1],10)||0; if(nsd!==curSelDepth){ curSelDepth=nsd; } } }catch{}
            try{ const mnps=line.match(/\bnps\s+(\d+)/); if(mnps){ lastNps = parseInt(mnps[1],10)||0; updateMeta(); } }catch{}

            // Prefer PV lines with explicit multipv, but also handle engines that omit it for PV #1
            const m=line.match(/\bmultipv\s+(\d+)/);
            const idx = m ? (parseInt(m[1],10)||1) : 1;
            const scoreStr = formatScore(line);
            // compute eval for white, then adapt to bar orientation
            let cpWhite = 0;
            let scoreStrW = scoreStr;
            try{
              const mMate=line.match(/score\s+mate\s+(-?\d+)/);
              const mCp=line.match(/score\s+cp\s+(-?\d+)/);
              const turnWhite = /\sw\s/.test(curFen||' ');
              if(mMate){
                const mate=parseInt(mMate[1],10)||0; // positive = mate for side to move
                // derive white-centric cp and string (# for white, #- for black)
                const whiteMating = (turnWhite && mate>0) || (!turnWhite && mate<0);
                scoreStrW = whiteMating ? ('#'+Math.abs(mate)) : ('#-'+Math.abs(mate));
                const cp = mate>0 ? 10000 : -10000; cpWhite = turnWhite ? cp : -cp;
              } else if(mCp){
                const cp=parseInt(mCp[1],10)||0;
                cpWhite = turnWhite ? cp : -cp;
                const pawns = (cpWhite/100).toFixed(2);
                scoreStrW = (cpWhite>=0?`+${pawns}`:pawns);
              }
              if(idx===1 && (mMate || mCp)) updateEvalBar(cpWhite);
            }catch{}
            const prev = lines.get(idx) || {};
            const pvIdx=line.indexOf(' pv ');
            const nextPvUci = pvIdx>=0 ? line.slice(pvIdx+4).trim().split(/\s+/) : (prev.pvUci||[]);
            const nextPvSan = (pvIdx>=0 && curFen) ? pvToSANs(curFen, nextPvUci) : (prev.pvSan||nextPvUci);
            // If line had no explicit score, keep previous display string
            const hadScore = /score\s+(cp|mate)\s+(-?\d+)/.test(line);
            const nextScoreStr = hadScore ? scoreStr : (prev.scoreStr||scoreStr);
            const nextScoreStrW = hadScore ? scoreStrW : (prev.scoreStrW||scoreStrW);
            lines.set(idx, { scoreStr: nextScoreStr, scoreStrW: nextScoreStrW, pvUci: nextPvUci, pvSan: nextPvSan });
            // Recompute engine arrows from available PVs (top -> down)
            recalcEngineArrowsFromLines();
            updateUI();
          }

          if(line.startsWith('bestmove')){
            pending=false;
          }

          // Emit loader errors to UI as text
          if(line.startsWith('bestmove')){ dlog('bestmove', line); /* no state change needed; handshake waits for readyok */ }

          if(/^stockfish importScripts error:/.test(line) || /^stockfish worker error:/.test(line)){
            try{
              const el=$('#engineLines');
              if(el) el.textContent = line + '\nCheck that /engine/stockfish.wasm is present and COOP/COEP headers are enabled.';
            }catch{}
            setState('error');
          }
        };

        sf.onmessageerror = (e) => {
          setState('messageerror');
          derr('worker messageerror', e);
          try{ const el=$('#engineLines'); if(el) el.textContent = 'Stockfish worker messageerror.'; }catch{}
          try{ restartWorker('onmessageerror'); }catch{}
        };

        sf.onerror = (ev) => {
          const msg = '' + (ev && (ev.message || ev.reason) ? (ev.message || ev.reason) : (ev && ev.filename ? ev.filename : 'unknown'));
          setState('error');
          derr('worker error', msg, ev);
          try{
            const el=$('#engineLines');
            if(el) el.textContent = 'Stockfish worker error: ' + msg;
          }catch{}
          if(/out of bounds|RuntimeError|Aborted|unwind/i.test(msg)){
            try{ restartWorker('onerror:'+msg); }catch{}
          }
        };

        try{ postSF('uci'); }catch(e){ derr('post uci failed', e);}        
        // caller (enable) will set label to "loading"
        return true;
      }

      // Helper to log and send commands to the worker
      function postSF(cmd){
        try{
          dlog('post ->', cmd);
          sf && sf.postMessage && sf.postMessage(cmd);
        }catch(e){ derr('post failed', cmd, e); }
      }

      // Issue the actual search commands (assumes engine is idle/ready)
      function goNow(fen){
        dlog('goNow begin', { fen, multiPV, depth, ready, active });
        try{ postSF('ucinewgame'); }catch{}
        try{ postSF('position fen '+fen); }catch{}
        try{ postSF('setoption name Threads value '+threads); }catch{}
        try{ postSF('setoption name Hash value '+hashMB); }catch{}
        try{ postSF('setoption name MultiPV value '+multiPV); }catch{}
        try{ postSF('go depth '+depth); }catch{}
        dlog('goNow end');
      }

      function go(fen){
        if(!active) return;
        if(!ensure()) return;
        curFen=fen; lines.clear(); clearUI();
        BOARD.arrows.engine=null; renderArrows();
        try{ curDepth = 0; updateMeta(); }catch{}

        // If the engine core isn't ready yet, queue and kick uci
        if(!ready){
          queuedFen = fen;
          try{ postSF('uci'); }catch{}
          return;
        }

        // Fast path: do not wait for readyok; UCI is sequential.
        // Send stop then immediately (or after a tiny delay) post new search commands.
        queuedFen = null; // we'll launch immediately
        pending = true;
        try{ postSF('stop'); }catch(e){ derr('post stop failed', e); }
        // Small delay helps some builds finish flushing before new position
        try{ setTimeout(()=>{ if(active && curFen===fen){ dlog('fast goNow'); goNow(fen); } }, 10); }catch{ goNow(fen); }
        // No readyok timers on the fast path
        }

      function analyzeDebounced(fen){
        if(!active) return;
        curFen=fen;
        clearTimeout(analyzeTimer);
        dlog('analyzeDebounced scheduled', { fen });
        analyzeTimer=setTimeout(()=>{ dlog('analyzeDebounced firing', { fen }); go(fen); }, 80);
      }

      function enable(){
        active=true;
        // Reflect correct state immediately when engine is already initialized
        setState(ready ? 'ready' : 'loading');
        dlog('enable');
        updateMeta();
        try{ evalBarVisible(true); updateEvalBar(EVALBAR.lastCpWhite||0); }catch{}
        const ok = ensure();
        if(ok && BOARD.current) analyzeDebounced(BOARD.current);
      }

      function disable(){
        active=false;
        dlog('disable');
        setState('off');
        lines.clear();
        clearUI();
        try{ dlog('post -> stop'); sf && sf.postMessage('stop'); }catch{}
        clearReadyRetryTimers();
        BOARD.arrows.engine=null; renderArrows();
        try{ evalBarVisible(false); }catch{}
        try{ curDepth=0; updateMeta(); }catch{}
        try{ if(sf && sf.terminate){ sf.terminate(); } }catch{}
        sf = null; ready = false; gotUci = false; queuedFen = null; pending = false;
      }

      // Small debug surface for manual testing from DevTools
      function ping(){ try{ ensure(); sf && sf.postMessage('uci'); setTimeout(()=>sf && sf.postMessage('isready'), 250); }catch(e){ derr('ping failed', e);} }
      try{ window.EngineLiveDebug = { ping, ensure: ()=>ensure(), post:(s)=>sf && sf.postMessage(String(s)) }; }catch{}
      function setMultiPV(n){
        multiPV = Math.max(1, Math.min(10, parseInt(n,10)||1));
        try{ localStorage.setItem(LS_ENG_PV, String(multiPV)); }catch{}
        updateMeta();
        // Cap arrowCount by new multiPV
        arrowCount = Math.max(0, Math.min(arrowCount, multiPV));
        try{ ensure(); if(ready) postSF('setoption name MultiPV value '+multiPV); if(active && curFen) analyzeDebounced(curFen); }catch{}
        // Refresh arrows
        recalcEngineArrowsFromLines();
      }
      function setDepth(n){
        depth = Math.max(1, Math.min(100, parseInt(n,10)||depth));
        try{ localStorage.setItem(LS_ENG_DEPTH, String(depth)); }catch{}
        updateMeta();
        try{
          ensure();
          if(active && ready){ try{ postSF('stop'); }catch{} }
          if(active && curFen) analyzeDebounced(curFen);
        }catch{}
      }
      function setArrowCount(n){
        arrowCount = Math.max(0, Math.min(parseInt(n,10)||0, multiPV));
        try{ localStorage.setItem(LS_ENG_ARROWS, String(arrowCount)); }catch{}
        recalcEngineArrowsFromLines();
      }
      function setThreads(n){
        try{
          const hc=(navigator.hardwareConcurrency||0)|0; const maxThr=hc>0?Math.min(32,hc):32;
          threads = Math.max(1, Math.min(parseInt(n,10)||1, maxThr));
          localStorage.setItem(LS_ENG_THREADS, String(threads));
          ensure();
          if(ready){ try{ postSF('stop'); }catch{}
            try{ postSF('setoption name Threads value '+threads); }catch{}
            if(active && curFen) analyzeDebounced(curFen);
          }
        }catch{}
      }
      function setHashMB(n){
        try{
          hashMB = Math.max(16, Math.min(parseInt(n,10)||128, 2048));
          localStorage.setItem(LS_ENG_HASH, String(hashMB));
          ensure();
          if(ready){ try{ postSF('stop'); }catch{}
            try{ postSF('setoption name Hash value '+hashMB); }catch{}
            try{ postSF('ucinewgame'); }catch{}
            if(active && curFen) analyzeDebounced(curFen);
          }
        }catch{}
      }
      function getThreads(){ return threads; }
      function getHashMB(){ return hashMB; }
      function getArrowCount(){ return arrowCount; }
      function getMultiPV(){ return multiPV; }
      function getDepth(){ return depth; }
      function restart(){ restartWorker('manual'); }
      return { enable, disable, restart, analyzeDebounced, setMultiPV, setDepth, setArrowCount, setThreads, setHashMB, getArrowCount, getMultiPV, getDepth, getThreads, getHashMB };
      })();
    try{ window.EngineLive = EngineLive; }catch{}
    async function analyzeOnServer(pgn, depth){
      const base=(window.SF_BACKEND_URL||'').replace(/\/$/,''); if(!base) throw new Error('SF_BACKEND_URL not set');
      const url=`${base}/analyze`;
      try{ console.info('[backend] Starting analysis via SF_BACKEND_URL:', url); }catch{}
      const thr=getSev();
      depth = parseInt(depth||window.getAnalysisDepth?.()||12,10)||12;
      const depthFast = (window.getFastDepth ? window.getFastDepth() : 12);
      const mode = (window.getAnalysisMode ? window.getAnalysisMode() : 'double');
      const cls = getClassifier();
      const payload = { pgn, depth, thresholds: thr, classifier: cls, wpThresholds: (cls==='wp'? getSevWp(): undefined) };
      if(mode !== 'single'){ payload.depthFast = depthFast; }
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify(payload)});
      if(!res.ok) throw new Error(`Stockfish backend error ${res.status}`);
      try{ const v = res.headers && res.headers.get && res.headers.get('X-Stockfish-Version'); if(v) console.info('[backend] Stockfish version (header):', v); }catch{}
      const data=await res.json(); const mistakes=data.mistakes||[];
      try{ if(data && data.engineVersion){ console.info('[backend] Stockfish version (body):', data.engineVersion); } }catch{}
      try{ console.debug('[client] analyzeOnServer: got', mistakes.length, 'mistakes; sample:', mistakes.slice(0,3)); }catch{}
      try{
        // Backfill deltaWp from cpBefore/cpAfter if not provided
        mistakes.forEach(m=>{
          if((typeof m.deltaWp === 'undefined' || m.deltaWp === null) && typeof m.cpBefore !== 'undefined' && typeof m.cpAfter !== 'undefined'){
            try{ m.deltaWp = Math.max(0, winProbFromCp(Number(m.cpBefore)||0) - winProbFromCp(-(Number(m.cpAfter)||0))); }catch{}
          }
        });
      }catch{}
      try{
        mistakes.forEach(m=>{ m.pgn=pgn; const h=parsePGNHeaders(pgn); const urlHdr=h.Site||h.Link||''; if(urlHdr && /^https?:\/\//i.test(urlHdr)) m.gameUrl=urlHdr; });
      }catch{}
      return mistakes;
    }

    // Server: fast pass only
    async function scanOnServer(pgn, depthFast){
      const base=(window.SF_BACKEND_URL||'').replace(/\/$/,''); if(!base) throw new Error('SF_BACKEND_URL not set');
      const url=`${base}/scan`;
      const thr=getSev();
      const dFast = parseInt(depthFast||window.getFastDepth?.()||12,10)||12;
      const cls = getClassifier();
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({pgn,depthFast:dFast,thresholds:thr, classifier: cls, wpThresholds:(cls==='wp'? getSevWp(): undefined)})});
      if(!res.ok) throw new Error(`Stockfish scan error ${res.status}`);
      const data=await res.json();
      return Array.isArray(data.candidates)?data.candidates:[];
    }

    // Server: deep pass on candidates
    async function analyzeCandidatesOnServer(candidates, depth){
      const base=(window.SF_BACKEND_URL||'').replace(/\/$/,''); if(!base) throw new Error('SF_BACKEND_URL not set');
      const url=`${base}/analyzeCandidates`;
      const thr=getSev();
      const d = parseInt(depth||window.getAnalysisDepth?.()||12,10)||12;
      const cls = getClassifier();
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({candidates,depth:d,thresholds:thr, classifier: cls, wpThresholds:(cls==='wp'? getSevWp(): undefined)})});
      if(!res.ok) throw new Error(`Stockfish analyzeCandidates error ${res.status}`);
      const data=await res.json();
      return Array.isArray(data.mistakes)?data.mistakes:[];
    }

    // NEW: keep a stacked list of imported games across sources
    window.importedGames = window.importedGames || []; // [{pgn, source, sel?:boolean}]
    function rebuildImportedTable(){
      const tb = $('#importTBody'); if(!tb) return;
      tb.innerHTML='';
      let i=0;
      try{
        LAST_ANALYZED = { mistakes: [], suggestedName: '' };
        const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo');
        if(btn){ btn.textContent = 'Create set (0 mistakes)'; }
        if(info){ info.textContent = '-'; }
      }catch{}
      // ensure selection defaults
      try{ (window.importedGames||[]).forEach(r=>{ if(r && typeof r.sel==='undefined') r.sel = true; }); }catch{}
      const list = (window.importedGames||[]).slice().sort((a,b)=> pgnTimeMs(b.pgn) - pgnTimeMs(a.pgn));
      for(const rec of list){
        const pgn = rec.pgn; const source=rec.source||'Imported';
        const h = parsePGNHeaders(pgn||'');
        const tr=document.createElement('tr');
        tr.innerHTML = `
          <td>${++i}</td>
          <td>${h.White||'-'}</td>
          <td>${h.Black||'-'}</td>
          <td>${h.Result||'-'}</td>
          <td>${h.Date||h.UTCDate||'-'}</td>
          <td>${source}</td>
          <td style="text-align:center"><input type="checkbox" class="impSel" data-pgn="${encodeURIComponent(pgn)}" ${rec.sel!==false?'checked':''} /></td>`;
        tr.style.cursor='pointer';
        tr.addEventListener('click', () => {
          Array.from(tb.querySelectorAll('tr')).forEach(r=>r.classList.remove('selected'));
          tr.classList.add('selected');
          // load game into viewer (mini-board)
          try{
            const cl = ChessLite(); cl.reset();
            const startFen = cl.fen();
            const mixed = cl.loadPGN(pgn);
            const fens = [startFen, ...mixed.filter(x=>x.san).map(x=>x.fenAfter)];
            GAMEVIEW.fens=fens; GAMEVIEW.idx=0; GAMEVIEW.total=fens.length-1; GAMEVIEW.pgn=pgn;
            // Orient from user's perspective if possible
            const side = userSideForPGN(pgn);
            const wb = side ? (side==='w') : true;
            GAMEVIEW.whiteBottom = wb;
            gvShow(); setTimeout(()=>{ drawBoardInto('gvBoard', fens[0], wb); gvUpdate(); }, 0);
            setStatus('Game loaded in viewer.');
          }catch(e){ console.warn('viewer load failed', e); }
        });
        tb.appendChild(tr);
      }
      // wire selection checkboxes
      try{
        tb.querySelectorAll('input.impSel').forEach(el=>{
          el.addEventListener('click', (ev)=>{ ev.stopPropagation(); });
          el.addEventListener('change', (ev)=>{
            const key = decodeURIComponent(ev.target.getAttribute('data-pgn')||'');
            const sel = !!ev.target.checked;
            const arr = window.importedGames || [];
            for(const r of arr){ if(r && r.pgn===key){ r.sel = sel; break; } }
          });
        });
      }catch{}
      const help = $('#importHelp');
      if(help){
        try{
          const total = window.importedGames.length;
          const chosen = (window.importedGames||[]).filter(r=>r && r.sel!==false).length;
          help.textContent = `${total} game(s) listed � ${chosen} selected. Click a row to preview.`;
        }catch{ help.textContent = `${window.importedGames.length} game(s) listed. Click a row to preview.`; }
      }
    }
    function appendImportedGames(pgns, source){
      const set = new Set((window.importedGames||[]).map(r=>r.pgn));
      for(const p of (pgns||[])){
        if(!p || set.has(p)) continue;
        window.importedGames.push({pgn:p, source:source||'Imported', sel:true});
      }
      try{ window._importsLocalBump = Date.now(); }catch{}
      try{ if(fb()) fb().appendImports(pgns, source).catch(()=>{}); }catch{}
      rebuildImportedTable();
    }

    async function analyzeImportedWithBackendAbortable(state){
      const imported = window.importedGames || [];
      const list = imported.filter(x => x && x.sel!==false).map(x => x.pgn);
      if(!list.length){ alert('No imported games found. Import games first.'); return; }
      inferUsernames();
      const all=[];
      let i=0;
      let phaseTimer = null;
      for(const pgn of list){
        if(state.stop) break;
        try{
          const fastDepth = (window.getFastDepth ? window.getFastDepth() : 12);
          setStatus(`Fast pass at depth: ${fastDepth} � Game ${i+1}/${list.length}`);
          setMistakeCounter(all.length);
          try{
            const deep = parseInt(window.getAnalysisDepth?.()||12,10)||12;
            if(phaseTimer) { clearTimeout(phaseTimer); phaseTimer = null; }
            phaseTimer = setTimeout(()=>{ try{ setStatus(`Deep analysis at depth: ${deep} - Game ${i+1}/${list.length}`); }catch{} }, 1500);
          }catch{}
        }catch{}
        setStatus(`Analyzing ${++i}/${list.length} — mistakes found: ${all.length}`);
        try{
          let ms=[];
          if(window.SF_BACKEND_URL){
            try{ ms=await analyzeOnServer(pgn, window.getAnalysisDepth ? window.getAnalysisDepth() : 12); }
            catch(err){
              console.warn('Analyze via SF backend failed, falling back', err);
              if(window.FN_BASE){
                try{ ms=await analyzeOnBackend([pgn]); }
                catch(err2){ console.warn('Analyze via Functions failed, falling back to local', err2); ms=await analyzeManualLocal(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; setStatus(`Analyzing ${i}/${list.length} — mistakes found: ${all.length}`); }catch{} }); }
              } else {
                ms=await analyzeManualLocal(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; setStatus(`Analyzing ${i}/${list.length} — mistakes found: ${all.length}`); }catch{} });
              }
            }
          }
          else if(window.FN_BASE){ ms=await analyzeOnBackend([pgn]); }
          else { ms = await analyzeManualLocal(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; setStatus(`Analyzing ${i}/${list.length} — mistakes found: ${all.length}`); }catch{} }); }

          // Ensure PGN and game URL are attached regardless of backend
          try{
            const hdr = parsePGNHeaders(pgn);
            const urlHdr = hdr.Site || hdr.Link || '';
            ms.forEach(m => {
              if(!m.pgn) m.pgn = pgn;
              if(!m.gameUrl && urlHdr && /^https?:\/\//i.test(urlHdr)) m.gameUrl = urlHdr;
            });
          }catch{}

          // Update status: deep analysis phase for this game
          try{ if(phaseTimer){ clearTimeout(phaseTimer); phaseTimer=null; } }catch{}
          try{
            const deep = parseInt(window.getAnalysisDepth?.()||12,10)||12;
            setStatus(`Deep analysis at depth: ${deep} - Game ${i}/${list.length}`);
            await sleep(20);
          }catch{}

          // Apply user and severity filters
          ms = filterMistakesToUserOnly(ms).filter(m => (window.includeSeverity ? window.includeSeverity(m.severity) : true));
          if(ms.length){
            for(const m of ms){
              all.push(m);
              LAST_ANALYZED.mistakes = all.slice();
              try{ setMistakeCounter(all.length); }catch{}
              try{
                const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`;
                setStatus(`Analyzing ${i}/${list.length} — mistakes found: ${all.length}`);
              }catch{}
            }
          }
        }catch(e){ console.warn('Analyze failed:', e); }
      }
      if(all.length) addMistakes(all);

      const srcSet = new Set(imported.map(x => x.source || 'Imported'));
      const tagBase = (srcSet.size===1 ? Array.from(srcSet)[0] : 'Imported');
      const tagName = `${tagBase}${state.stop ? ' (partial)' : ''} ${new Date().toLocaleString()}`;

      // Cache last analyzed results for manual set creation and show button
      LAST_ANALYZED = { mistakes: all.slice(), suggestedName: tagName };
      try{
        const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo');
        const uniq=(new Set(all.map(keyOf))).size;
        if(btn){ btn.textContent = `Create set (${uniq} mistake${uniq!==1?'s':''})`; }
        if(info) info.textContent = uniq>0 ? `Ready: ${uniq} unique mistake(s) detected in last analysis.` : '-';
      }catch{}

      if(state.stop){
        setStatus(`Analysis stopped — mistakes found: ${all.length}`);
      }else{
        setStatus(`Done. Added ${all.length} user-mistake(s).`);
      }
    }

    // Single-layer analyzer (deep only)
    async function analyzeImportedSingleFlow(state){
      const imported = window.importedGames || [];
      const list = imported.filter(x => x && x.sel!==false).map(x => x.pgn);
      if(!list.length){ alert('No imported games found. Import games first.'); return; }
      inferUsernames();
      const all=[];
      let i=0;
      for(const pgn of list){
        if(state.stop) break;
        const idx = i+1;
        const deep = parseInt(window.getAnalysisDepth?.()||12,10)||12;
        try{ setStatus(`Deep analysis at depth: ${deep} - Game ${idx}/${list.length}`); setMistakeCounter(all.length); }catch{}
        let ms=[];
        try{
          if(window.SF_BACKEND_URL){
            try{
              ms = await analyzeOnServer(pgn, deep);
            }catch(err){
              console.warn('Analyze via SF backend failed, falling back', err);
              if(window.FN_BASE){
                try{ ms = await analyzeOnBackend([pgn]); }
                catch(err2){ console.warn('Analyze via Functions failed, falling back to local', err2); ms = await analyzeManualLocalSingle(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ setMistakeCounter(all.length); }catch{} }); }
              } else {
                ms = await analyzeManualLocalSingle(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ setMistakeCounter(all.length); }catch{} });
              }
            }
          } else if(window.FN_BASE){
            try{ ms = await analyzeOnBackend([pgn]); }
            catch(err2){ console.warn('Analyze via Functions failed, falling back to local', err2); ms = await analyzeManualLocalSingle(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ setMistakeCounter(all.length); }catch{} }); }
          } else {
            ms = await analyzeManualLocalSingle(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ setMistakeCounter(all.length); }catch{} });
          }
        }catch(e){ console.warn('Analyze failed:', e); }
        // Attach PGN and URL
        try{
          const hdr = parsePGNHeaders(pgn);
          const urlHdr = hdr.Site || hdr.Link || '';
          (ms||[]).forEach(m => { if(!m.pgn) m.pgn = pgn; if(!m.gameUrl && urlHdr && /^https?:\/\//i.test(urlHdr)) m.gameUrl = urlHdr; });
        }catch{}
        // Filter and accumulate
        ms = filterMistakesToUserOnly(ms).filter(m => (window.includeSeverity ? window.includeSeverity(m.severity) : true));
        for(const m of (ms||[])){
          all.push(m); LAST_ANALYZED.mistakes = all.slice();
          try{ setMistakeCounter(all.length); }catch{}
          try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; }catch{}
        }
        i++;
      }
      if(all.length) addMistakes(all);
      const srcSet = new Set(imported.map(x => x.source || 'Imported'));
      const tagBase = (srcSet.size===1 ? Array.from(srcSet)[0] : 'Imported');
      const tagName = `${tagBase}${state.stop ? ' (partial)' : ''} ${new Date().toLocaleString()}`;
      LAST_ANALYZED = { mistakes: all.slice(), suggestedName: tagName };
      try{ const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo'); const uniq=(new Set(all.map(keyOf))).size; if(btn){ btn.textContent = `Create set (${uniq} mistake${uniq!==1?'s':''})`; } if(info) info.textContent = uniq>0 ? `Ready: ${uniq} unique mistake(s) detected in last analysis.` : '-'; }catch{}
      setStatus(state.stop ? 'Analysis stopped' : 'Analysis finished');
    }

    // New two-step analyzer that uses backend scan + deep endpoints when available
    async function analyzeImportedWithBackendAbortable2(state){
      const imported = window.importedGames || [];
      const list = imported.filter(x => x && x.sel!==false).map(x => x.pgn);
      if(!list.length){ alert('No imported games found. Import games first.'); return; }
      inferUsernames();
      const all=[];
      let i=0;
      for(const pgn of list){
        if(state.stop) break;
        const idx = i+1;
        const fastDepth = (window.getFastDepth ? window.getFastDepth() : 12);
        setStatus(`Fast pass at depth: ${fastDepth} - Game ${idx}/${list.length}`);
        setMistakeCounter(all.length);
        let ms=[];
        try{
          if(window.SF_BACKEND_URL){
            let candidates=[];
            try{ candidates = await scanOnServer(pgn, fastDepth); }
            catch(e){ console.warn('scan failed; fallback to /analyze', e); ms = await analyzeOnServer(pgn, window.getAnalysisDepth ? window.getAnalysisDepth() : 12); }
            if(!ms.length && Array.isArray(candidates)){
              const deep = parseInt(window.getAnalysisDepth?.()||12,10)||12;
              setStatus(`Deep analysis at depth: ${deep} - Game ${idx}/${list.length}`);
              ms = await analyzeCandidatesOnServer(candidates, deep);
            }
          } else if(window.FN_BASE){
            ms = await analyzeOnBackend([pgn]);
          } else {
            ms = await analyzeManualLocal(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ setMistakeCounter(all.length); }catch{} });
          }
        }catch(e){ console.warn('Analyze failed:', e); }

        // Attach PGN and URL
        try{
          const hdr = parsePGNHeaders(pgn);
          const urlHdr = hdr.Site || hdr.Link || '';
          (ms||[]).forEach(m => { if(!m.pgn) m.pgn = pgn; if(!m.gameUrl && urlHdr && /^https?:\/\//i.test(urlHdr)) m.gameUrl = urlHdr; });
        }catch{}

        // Filter and accumulate
        ms = filterMistakesToUserOnly(ms).filter(m => (window.includeSeverity ? window.includeSeverity(m.severity) : true));
        for(const m of (ms||[])){
          all.push(m); LAST_ANALYZED.mistakes = all.slice();
          try{ setMistakeCounter(all.length); }catch{}
          try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; }catch{}
        }
        i++;
      }
      if(all.length) addMistakes(all);

      const srcSet = new Set(imported.map(x => x.source || 'Imported'));
      const tagBase = (srcSet.size===1 ? Array.from(srcSet)[0] : 'Imported');
      const tagName = `${tagBase}${state.stop ? ' (partial)' : ''} ${new Date().toLocaleString()}`;
      LAST_ANALYZED = { mistakes: all.slice(), suggestedName: tagName };
      try{ const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo'); if(btn){ btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; } if(info) info.textContent = all.length>0 ? `Ready: ${all.length} mistake(s) detected in last analysis.` : '-'; }catch{}

      setStatus(state.stop ? 'Analysis stopped' : 'Analysis finished');
    }

    // Local fallback (two-pass)
    async function analyzeManualLocal(pgn, onFound){
      const clRead = ChessLite();
      const seq = clRead.loadPGN(pgn).filter(x=>x.san);
      const game = ChessLite(); game.reset();
      const mistakes = [];
      const sideWanted = userSideForPGN(pgn);
      const depth = parseInt(window.getAnalysisDepth?.()||12,10)||12;
      const depthFast = (window.getFastDepth ? parseInt(window.getFastDepth(),10)||12 : 12);

      // Pass 1: shallow scan to find candidates
      const candidates = [];
      for(const mv of seq){
        const fenBefore = game.fen();
        const side = game.turn();
        if(sideWanted && side !== sideWanted){
          const skipUci = game.parseSANtoMove(mv.san); if(skipUci) game.moveUci(skipUci);
          continue;
        }
        const { cp: cpBefore1, bestmove: best1 } = await Engine.analyze(fenBefore, depthFast);
        const playedUci = game.parseSANtoMove(mv.san); if(!playedUci) continue;
        game.moveUci(playedUci);
        const fenAfter = game.fen();
        if(playedUci === best1) { continue; }
        const { cp: cpAfter1 } = await Engine.analyze(fenAfter, depthFast);
        const sev1 = severityFromScores(cpBefore1, cpAfter1);
        if(sev1){
          candidates.push({ fenBefore, fenAfter, side, san: mv.san, uci: playedUci });
        }
      }

      // Pass 2: deep analysis on candidates only
      try{ setStatus(`Deep analysis at depth: ${depth}`); await sleep(10); }catch{}
      for(const c of candidates){
        const { cp: cpBefore2, bestmove: best2 } = await Engine.analyze(c.fenBefore, depth);
        if(c.uci === best2) { continue; }
        const { cp: cpAfter2 } = await Engine.analyze(c.fenAfter, depth);
        const drop2 = Math.max(0, cpBefore2 + cpAfter2);
        const sev2 = severityFromScores(cpBefore2, cpAfter2);
        const include = (window.includeSeverity ? window.includeSeverity(sev2) : true);
        if(sev2 && include){
          const m = { id:uid(), fen:c.fenBefore, side:c.side, played:c.san, best:best2, deltaCp:drop2, deltaWp: Math.max(0, winProbFromCp(cpBefore2) - winProbFromCp(-cpAfter2)), cpBefore: cpBefore2, cpAfter: cpAfter2, severity:sev2, nextReview:nowTs(), ef:2.5, reps:0, interval:0, pgn };
          mistakes.push(m);
          try{ if(typeof onFound==='function') onFound(m); }catch{}
        }
      }
      return mistakes;
    }

    function adjustRightColWidth(){
      try{
        const rc = document.getElementById('trainRightCol'); if(!rc) return;
        const wrap = rc.querySelector('.mistake-actions-wrap') || rc.querySelector('.mistake-actions') || rc;
        const w = Math.ceil(wrap.getBoundingClientRect().width);
        // Include padding + borders of containing panel (.stroke)
        const box = wrap.closest('.stroke') || rc;
        let extra = 0;
        try{
          const cs = window.getComputedStyle(box);
          extra = (parseFloat(cs.paddingLeft)||0) + (parseFloat(cs.paddingRight)||0) + (parseFloat(cs.borderLeftWidth)||0) + (parseFloat(cs.borderRightWidth)||0);
        }catch{}
        // Small buffer to avoid fractional rounding clipping
        const target = w + Math.ceil(extra) + 8;
        rc.style.width = target + 'px';
      }catch{}
    }
    function setTrainFen(fen){
      try{
        const col=document.getElementById('trainFenCollapsed'); if(col) col.textContent = fen||'-';
        const full=document.getElementById('trainFenFull'); if(full) full.value = fen||'';
      }catch{}
    }
    function setTrainPgn(pgn){
      try{
        const col=document.getElementById('trainPgnCollapsed'); if(col) col.textContent = (pgn? (pgn.split('\n')[0]||'') : '-');
        const full=document.getElementById('trainPgnFull'); if(full) full.value = pgn||'';
      }catch{}
    }
    function inferGameUrlFromPGN(pgn){
      try{
        const h = parsePGNHeaders(pgn||'');
        const link = h.Link || '';
        const site = h.Site || '';
        if(/^https?:\/\//i.test(link)) return link;
        if(/^https?:\/\//i.test(site)) return site;
      }catch{}
      return '';
    }
    function updateTrainLink(m){
      try{
        const linkEl=document.getElementById('trainLink'); if(!linkEl) return;
        let url = m && m.gameUrl || '';
        if((!url || !/^https?:\/\//i.test(url)) && m && m.pgn){ url = inferGameUrlFromPGN(m.pgn); }
        if(url && /^https?:\/\//i.test(url)){
          linkEl.textContent='Open game'; linkEl.href=url;
        } else {
          linkEl.textContent='-'; linkEl.href='#';
        }
      }catch{}
    }
    // Local fallback single-layer (deep on every move)
    async function analyzeManualLocalSingle(pgn, onFound){
      const clRead = ChessLite();
      const seq = clRead.loadPGN(pgn).filter(x=>x.san);
      const game = ChessLite(); game.reset();
      const mistakes = [];
      const sideWanted = userSideForPGN(pgn);
      const depth = parseInt(window.getAnalysisDepth?.()||12,10)||12;
      for(const mv of seq){
        const fenBefore = game.fen();
        const side = game.turn();
        if(sideWanted && side !== sideWanted){
          const skipUci = game.parseSANtoMove(mv.san); if(skipUci) game.moveUci(skipUci);
          continue;
        }
        const { cp: cpBefore2, bestmove: best2 } = await Engine.analyze(fenBefore, depth);
        const playedUci = game.parseSANtoMove(mv.san); if(!playedUci) continue;
        if(playedUci === best2){ game.moveUci(playedUci); continue; }
        game.moveUci(playedUci);
        const fenAfter = game.fen();
        const { cp: cpAfter2 } = await Engine.analyze(fenAfter, depth);
        const drop2 = Math.max(0, cpBefore2 + cpAfter2);
        const sev2 = severityFromScores(cpBefore2, cpAfter2);
        const include = (window.includeSeverity ? window.includeSeverity(sev2) : true);
        if(sev2 && include){
          const m = { id:uid(), fen:fenBefore, side, played: mv.san, best:best2, deltaCp:drop2, deltaWp: Math.max(0, winProbFromCp(cpBefore2) - winProbFromCp(-cpAfter2)), cpBefore: cpBefore2, cpAfter: cpAfter2, severity:sev2, nextReview:nowTs(), ef:2.5, reps:0, interval:0, pgn };
          mistakes.push(m);
          try{ if(typeof onFound==='function') onFound(m); }catch{}
        }
      }
      return mistakes;
    }

    /********************************************************************
     * Importers
     ********************************************************************/
    async function fetchLichess(user, maxN){
      const n=Math.max(1, Math.min(50, parseInt(maxN,10)||5));
      const base=(window.FN_LICHESS_URL||`${window.FN_BASE||''}/fetchLichess`).replace(/\/$/,'');
      const url=`${base}?username=${encodeURIComponent(user)}&max=${n}`;
      const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error(`Lichess proxy failed (${res.status})`);
      const json=await res.json();
      let games=(json.games||[]).filter(g=>g&&g.pgn);
      // Ensure newest-first and limit to last N
      games.sort((a,b)=>((b.lastMoveAt||b.createdAt||0) - (a.lastMoveAt||a.createdAt||0)));
      games = games.slice(0, n);
      const out=games.map(g=>g.pgn);
      appendImportedGames(out,'Lichess'); return out;
    }

    async function fetchChesscom(user, maxN){
      const n=Math.max(1, Math.min(50, parseInt(maxN,10)||5));
      const base=(window.FN_CHESSCOM_URL||`${window.FN_BASE||''}/fetchChessCom`).replace(/\/$/,'');
      const url=`${base}?username=${encodeURIComponent(user)}&limit=${n}`;
      const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error(`Chess.com proxy failed (${res.status})`);
      const json=await res.json();
      let games=(json.games||[]).filter(g=>g&&g.pgn);
      // Ensure newest-first and limit to last N
      games.sort((a,b)=>((b.end_time||0)-(a.end_time||0)));
      games = games.slice(0, n);
      const out=games.map(g=>g.pgn);
      appendImportedGames(out,'Chess.com'); return out;
    }

    // List-only versions (do not mutate Imported Games). Used by unified import.
    async function fetchLichessList(user, maxN){
      const n=Math.max(1, Math.min(50, parseInt(maxN,10)||5));
      const base=(window.FN_LICHESS_URL||`${window.FN_BASE||''}/fetchLichess`).replace(/\/$/,'');
      const url=`${base}?username=${encodeURIComponent(user)}&max=${n}`;
      const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error(`Lichess proxy failed (${res.status})`);
      const json=await res.json();
      let games=(json.games||[]).filter(g=>g&&g.pgn);
      games.sort((a,b)=>((b.lastMoveAt||b.createdAt||0) - (a.lastMoveAt||a.createdAt||0)));
      games = games.slice(0, n);
      return games.map(g=>g.pgn);
    }

    async function fetchChesscomList(user, maxN){
      const n=Math.max(1, Math.min(50, parseInt(maxN,10)||5));
      const base=(window.FN_CHESSCOM_URL||`${window.FN_BASE||''}/fetchChessCom`).replace(/\/$/,'');
      const url=`${base}?username=${encodeURIComponent(user)}&limit=${n}`;
      const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error(`Chess.com proxy failed (${res.status})`);
      const json=await res.json();
      let games=(json.games||[]).filter(g=>g&&g.pgn);
      games.sort((a,b)=>((b.end_time||0)-(a.end_time||0)));
      games = games.slice(0, n);
      return games.map(g=>g.pgn);
    }

  /********************************************************************
   * Unified Import UI logic
   ********************************************************************/
  function getPrefs(){ try{ return JSON.parse(localStorage.getItem('pmtt_prefs')||'{}'); }catch{return {}} }
  function savePrefsLocal(p){ try{ const cur=getPrefs(); localStorage.setItem('pmtt_prefs', JSON.stringify({...cur, ...p})); }catch{} }
  function applyPrefsToUI(){
    try{
      const p=getPrefs();
      if($('#provLichess')) $('#provLichess').checked = (p.provLichess!==false);
      if($('#provChesscom')) $('#provChesscom').checked = (p.provChesscom!==false);
      if($('#modeTime')) $('#modeTime').checked = (p.importMode==='time');
      if($('#modeCount')) $('#modeCount').checked = (p.importMode!=='time');
      if($('#importCount')) $('#importCount').value = String(p.importCount||10);
      if($('#importCount2')) $('#importCount2').value = String(p.importCount||10);
      const pv = document.getElementById('periodValue'); if(pv) pv.value = String(p.periodValue ?? 30);
      const pu = document.getElementById('periodUnit'); if(pu) pu.value = p.periodUnit || 'days';
      if($('#accLichess')) $('#accLichess').value = p.lichessUser||'';
      if($('#accChessCom')) $('#accChessCom').value = p.chesscomUser||'';
      if($('#lichessUser')) $('#lichessUser').value = p.lichessUser||'';
      if($('#chesscomUser')) $('#chesscomUser').value = p.chesscomUser||'';
      if($('#modeTime') && $('#modeTime').checked){ $('#periodWrap').style.display='block'; $('#countWrap2').style.display='none'; }
      else { if($('#periodWrap')) $('#periodWrap').style.display='none'; if($('#countWrap2')) $('#countWrap2').style.display='block'; }
    }catch{}
  }
  try{ window.getPrefs = getPrefs; window.savePrefsLocal = savePrefsLocal; window.applyPrefsToUI = applyPrefsToUI; }catch{}

    function periodMsFromControls(){
      try{
        const valStr = (document.getElementById('periodValue')?.value || '0').trim();
        let v = parseFloat(valStr); if(!isFinite(v) || v < 0) v = 0;
        const unit = (document.getElementById('periodUnit')?.value || 'days');
        const msPer = { minutes:60*1000, hours:3600*1000, days:24*3600*1000, weeks:7*24*3600*1000, months:30*24*3600*1000 };
        const mult = msPer[unit] || msPer.days;
        return v * mult;
      }catch{ return 30*24*3600*1000; }
    }

  async function importUnified(){
    const provL = !!($('#provLichess') && $('#provLichess').checked);
    const provC = !!($('#provChesscom') && $('#provChesscom').checked);
    if(!provL && !provC){ alert('Select at least one provider'); return; }
    const modeTime = !!($('#modeTime') && $('#modeTime').checked);
    const count = Math.max(1, parseInt($('#importCount2')?.value||$('#importCount')?.value||'10',10)||10);
    const period = null; // deprecated; use periodValue + periodUnit
    const lichUser = ($('#accLichess')?.value||$('#lichessUser')?.value||'').trim();
    const chessUser = ($('#accChessCom')?.value||$('#chesscomUser')?.value||'').trim();
    const prefs = { provLichess:provL, provChesscom:provC, importMode: modeTime?'time':'count', importCount:count, periodValue: parseFloat(document.getElementById('periodValue')?.value||'30')||30, periodUnit: (document.getElementById('periodUnit')?.value||'days'), lichessUser:lichUser, chesscomUser:chessUser };
    try { (window.savePrefsLocal||savePrefsLocal)(prefs); } catch {}
    try{ if(fb()) fb().savePrefs(prefs).catch(()=>{}); }catch{}
    if(provL && !lichUser){ alert('Enter your Lichess username in Settings'); return; }
    if(provC && !chessUser){ alert('Enter your Chess.com username in Settings'); return; }
    setStatus('Fetching games...');
    const jobs = [];
    if(modeTime){
      const want = 200; // generous upper bound per provider
      if(provL) jobs.push(fetchLichessList(lichUser, want).then(arr=>arr.map(p=>({pgn:p, src:'Lichess'}))).catch(()=>[]));
      if(provC) jobs.push(fetchChesscomList(chessUser, want).then(arr=>arr.map(p=>({pgn:p, src:'Chess.com'}))).catch(()=>[]));
    } else {
      const want = Math.max(1, count); // fetch N from each selected provider (list-only)
      if(provL) jobs.push(fetchLichessList(lichUser, want).then(arr=>arr.map(p=>({pgn:p, src:'Lichess'}))).catch(()=>[]));
      if(provC) jobs.push(fetchChesscomList(chessUser, want).then(arr=>arr.map(p=>({pgn:p, src:'Chess.com'}))).catch(()=>[]));
    }
    const results = (await Promise.all(jobs)).flat();
    const withTs = results.map(r=>({ ...r, ms: pgnTimeMs(r.pgn) || 0 }));
    let chosen=[];
    if(modeTime){ const since = Date.now() - periodMsFromControls();
      chosen = withTs.filter(r=>r.ms>=since).sort((a,b)=>b.ms-a.ms);
    } else {
      chosen = withTs.sort((a,b)=>b.ms-a.ms).slice(0, count);
    }
    const gL=[], gC=[]; for(const r of chosen){ if(r.src==='Lichess') gL.push(r.pgn); else if(r.src==='Chess.com') gC.push(r.pgn); }
    if(gL.length) appendImportedGames(gL,'Lichess');
    if(gC.length) appendImportedGames(gC,'Chess.com');
    setStatus('Idle');
  }
  try{ window.importUnified = importUnified; }catch{}

    /********************************************************************
     * Trainer session (no SRS/Woodpecker)
     ********************************************************************/
    let ORIENT_WHITE_BOTTOM = true;

    // Build a list of mistakes for the active set (no SRS filtering)
    function listForActiveSet(){
      let list = loadMistakes();
      if(ACTIVE_SET_KEYS && ACTIVE_SET_KEYS.size){
        list = list.filter(m => {
          const ks = keysForMistake(m);
          for(const k of ks){ if(ACTIVE_SET_KEYS.has(k)) return true; }
          return false;
        });
      }
      return list;
    }

    // No SM-2 scheduling anymore

    const Session = (() => {
      let queue=[]; let mode='srs'; let active=null; let pendingFirstTry=true; let history=[];

      function startWoodpecker(N){
        history = [];
        let list = loadMistakes().slice();
        if(ACTIVE_SET_KEYS && ACTIVE_SET_KEYS.size){
          list = list.filter(m => {
            const ks = keysForMistake(m);
            for(const k of ks){ if(ACTIVE_SET_KEYS.has(k)) return true; }
            return false;
          });
        }
        list.sort((a,b) => {
          const rank = s => s==='blunder'?3 : s==='mistake'?2 : s==='inaccuracy'?1 : 0;
          const d = rank(b.severity) - rank(a.severity); if(d) return d;
          return (b.deltaCp||0) - (a.deltaCp||0);
        });
        queue = list.slice(0, Math.max(1,N)).map(m=>({...m}));
        mode='woodpecker'; next();
      }
      function startSRS(){ history = []; queue = pickDueSRS(); mode='srs'; next(); }
      function updateNavButtons(){
        try{ const b=$('#btnBack'); if(b) b.disabled = history.length===0; }catch{}
      }
      function next(){
      $('#yourMove').textContent='-'; $('#feedback').textContent='-';
      try{
        const both = formatBothDelta(m);
        $('#mInfo').innerHTML = `<span class="pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}">${m.severity}</span> � loss (cp | wp): ${both}`;
      }catch{}
      try{
        const both = formatBothDelta(m);
        $('#mInfo').innerHTML = `<span class="pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}">${m.severity}</span> � loss (cp | wp): ${both}`;
      }catch{}
        // clear arrows
        BOARD.arrows.user = null; BOARD.arrows.best = null; BOARD.arrows.showBest=false; renderArrows();
        try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
        if(queue.length===0){
          if(mode==='srs'){ queue = pickDueSRS(); if(queue.length===0){ $('#mInfo').textContent='No SRS items due now. ??'; active=null; drawBoardMain(null); return; } }
          else { $('#mInfo').textContent='Woodpecker set complete. ??'; active=null; drawBoardMain(null); return; }
        }
        if(active){ history.push({ item: active, pending: pendingFirstTry }); }
        active = queue.shift(); pendingFirstTry=true; loadMistakeOnBoard(active); updateNavButtons();
      }
      function answer(moveUci){
        if(!active) return;
        const correct = (moveUci === (active.best||''));
        const yourSan = uciToSAN(active.fen, moveUci);
        $('#yourMove').textContent = yourSan || moveUci || '—';

        // Do not auto-draw last-move arrow; keep arrows clear
        BOARD.arrows.user = null; BOARD.arrows.showBest=false; renderArrows();

        // Move the board tentatively so user can see result
        const tmp=ChessLite(); tmp.loadFEN(BOARD.current); const mv=tmp.moveUci(moveUci);
        if(mv.ok){ drawBoardMain(tmp.fen()); }

        if(correct){
          $('#feedback').innerHTML = '?? Correct (best move)';
          const list = loadMistakes(); const idx=list.findIndex(m=>m.id===active.id);
          if(idx>=0){ const q=(mode==='srs') ? (pendingFirstTry?5:3) : (pendingFirstTry?5:4); sm2Update(list[idx], q); saveMistakes(list); }
          logAttempt(active.id, true, moveUci);
          // DO NOT auto-advance; user presses Next
        }else{
          const bestSan = uciToSAN(active.fen, active.best);
          $('#feedback').innerHTML = `? Not the best. <span class="mono">Best = ${bestSan || active.best}</span>`;
          logAttempt(active.id, false, moveUci);
          pendingFirstTry=false;
          if(mode==='woodpecker') queue.push(active);
        }
      }
      function back(){
        if(history.length===0) return;
        if(active){ queue.unshift(active); }
        const prev = history.pop();
        active = prev.item; pendingFirstTry = !!prev.pending;
        loadMistakeOnBoard(active);
        $('#yourMove').textContent='-'; $('#feedback').textContent='-';
        try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
        BOARD.arrows.user=null; BOARD.arrows.showBest=false; renderArrows();
        updateNavButtons();
      }
      return { startWoodpecker, startSRS, next, back, answer, get active(){return active;} }
    })();

    // Simplified training session without SRS/Woodpecker scheduling
    const TrainSession = (() => {
      let queue = [];
      let active = null;
      let history = [];

      function updateNavButtons(){
        try{ const b=$('#btnBack'); if(b) b.disabled = history.length===0; }catch{}
      }
      function buildQueue(){
        const list = (typeof listForActiveSet === 'function') ? listForActiveSet() : loadMistakes();
        const ranked = list.slice().sort((a,b)=>{
          const rank = s => s==='blunder'?3 : s==='mistake'?2 : s==='inaccuracy'?1 : 0;
          const d = rank(b.severity) - rank(a.severity); if(d) return d;
          return (b.deltaCp||0) - (a.deltaCp||0);
        });
        return ranked.map(m=>({...m}));
      }
      function start(){
        history = [];
        queue = buildQueue();
        next();
      }
      function next(){
        $('#yourMove').textContent='-'; $('#feedback').textContent='-';
        BOARD.arrows.user = null; BOARD.arrows.best = null; BOARD.arrows.showBest=false; renderArrows();
        try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
        if(queue.length===0){ $('#mInfo').textContent='Set complete.'; active=null; drawBoardMain(null); updateNavButtons(); return; }
        if(active){ history.push({ item: active }); }
        active = queue.shift();
        loadMistakeOnBoard(active); updateNavButtons();
      }
      function back(){
        if(history.length===0) return;
        if(active){ queue.unshift(active); }
        const prev = history.pop();
        active = prev.item;
        loadMistakeOnBoard(active);
        $('#yourMove').textContent='-'; $('#feedback').textContent='-';
        try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
        BOARD.arrows.user=null; BOARD.arrows.showBest=false; renderArrows();
        updateNavButtons();
      }
      function answer(moveUci){
        if(!active) return;
        const correct = (moveUci === (active.best||''));
        const yourSan = uciToSAN(active.fen, moveUci);
        $('#yourMove').textContent = yourSan || moveUci || '�';
        if(correct){
          $('#feedback').innerHTML = '? Correct (best move)';
          try{ logAttempt(active.id, true, moveUci); }catch{}
        } else {
          const bestSan = uciToSAN(active.fen, active.best);
          $('#feedback').innerHTML = `? Not the best. <span class="mono">Best = ${bestSan || active.best}</span>`;
          try{ logAttempt(active.id, false, moveUci); }catch{}
        }
      }
      return { start, next, back, answer, get active(){ return active; } };
    })();

    /********************************************************************
     * Board rendering + arrows + DnD
     ********************************************************************/
    const VS15 = '\uFE0E'; // force text (non-emoji) glyphs
    const PIECES = {
      'P':'?'+VS15,'N':'?'+VS15,'B':'?'+VS15,'R':'?'+VS15,'Q':'?'+VS15,'K':'?'+VS15,
      'p':'?'+VS15,'n':'?'+VS15,'b':'?'+VS15,'r':'?'+VS15,'q':'?'+VS15,'k':'?'+VS15
    };
    const BOARD = { current:null, selected:null, highlights:new Set(), chess:ChessLite(), arrows:{ user:null, best:null, engine:null, showBest:false }, lastFromTo:null };
    const CB = { main:null, extras:{} };
    // Evaluation bar state
    const EVALBAR = { lastCpWhite: 0 };

    function ensureEvalBar(){ try{ const bar=document.getElementById('evalBar'); if(!bar) return null; const outer=document.getElementById('trainBoard'); if(!outer) return bar; const r=outer.getBoundingClientRect(); bar.style.height = r.height+'px'; return bar; }catch{ return null; } }
    function evalBarVisible(on){ const bar=ensureEvalBar(); if(!bar) return; bar.style.display = on ? 'block' : 'none'; }
    // White-centric proportion of the bar (0..1); 0.5 = equal
    function cpToPercentWhite(cpWhite){ const RANGE=1000; let p = 0.5 + (Math.max(-RANGE, Math.min(RANGE, cpWhite)) / (2*RANGE)); return Math.max(0, Math.min(1, p)); }
    function updateEvalBar(cpWhite){
      EVALBAR.lastCpWhite = cpWhite;
      const bar=ensureEvalBar(); if(!bar) return;
      const fill=bar.querySelector('.eval-fill'); if(!fill) return;
      const p = cpToPercentWhite(cpWhite);
      // Height reflects white advantage proportion; anchor to the side of the white pieces
      fill.style.height = Math.round(p*100)+'%';
      if(ORIENT_WHITE_BOTTOM){ fill.style.bottom = '0'; fill.style.top = ''; }
      else { fill.style.top = '0'; fill.style.bottom = ''; }
    }

    function ensureArrowCanvas(){
      const outer = document.getElementById('trainBoard'); if(!outer) return null;
      let cv = document.getElementById('boardArrows');
      if(!cv){ cv=document.createElement('canvas'); cv.id='boardArrows'; Object.assign(cv.style,{position:'absolute', inset:'0', pointerEvents:'none'}); outer.appendChild(cv); }
      const rect = outer.getBoundingClientRect();
      const dpr = Math.min(2, (window.devicePixelRatio || 1));
      cv.width = Math.max(1, Math.floor(rect.width*dpr)); cv.height = Math.max(1, Math.floor(rect.height*dpr)); cv.style.width=rect.width+'px'; cv.style.height=rect.height+'px';
      try{ const bar=document.getElementById('evalBar'); if(bar){ bar.style.height = rect.height+'px'; } }catch{}
      return { cv, dpr, rect };
    }
    function sqCenterPx(sq, rectW, rectH, dpr){
      const files='abcdefgh'; const f=files.indexOf(sq[0]); const r=parseInt(sq[1],10)-1;
      let col=f, row=7-r;
      if(!ORIENT_WHITE_BOTTOM){ col=7-col; row=7-row; }
      const cellW=rectW/8, cellH=rectH/8; return { x:dpr*((col+0.5)*cellW), y:dpr*((row+0.5)*cellH) };
    }
    function drawArrow(ctx,dpr,from,to,color, dashed, alpha, scale, align, headScale){
      const outer=document.getElementById('trainBoard'); if(!outer) return;
      const rect=outer.getBoundingClientRect();
      const a=sqCenterPx(from, rect.width, rect.height, dpr);
      const c=sqCenterPx(to, rect.width, rect.height, dpr); // desired centroid location for the head triangle
      ctx.save();
      if(dashed && ctx.setLineDash) ctx.setLineDash([10*dpr, 8*dpr]);
      // Make arrows semi-transparent; allow caller override per arrow
      ctx.globalAlpha = (typeof alpha==='number') ? alpha : 0.7;
      const k = (typeof scale==='number' && isFinite(scale) && scale>0) ? scale : 1;
      const kHead = (typeof headScale==='number' && isFinite(headScale) && headScale>0) ? headScale : k;
      ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=(6*dpr)*k; ctx.lineCap='round'; ctx.lineJoin='round';
      // Compute arrowhead geometry and shorten shaft so tip sits at the end
      const ang=Math.atan2(c.y-a.y,c.x-a.x);
      const ux=Math.cos(ang), uy=Math.sin(ang);
      const headLen=(12*dpr)*kHead; // shorter head so tip stays within target square
      const headWidth=(14*dpr)*kHead; // slightly narrower head for balance
      const px=-uy, py=ux; // unit perpendicular
      // Place triangle so a chosen point along its axis aligns to the square center.
      // Let P be the alignment point along [B..T] with fraction p (0=base midpoint, 1=tip).
      // Then B = P - p*L*u and T = P + (1-p)*L*u.
      const pAlign = (typeof align==='number' && isFinite(align)) ? Math.max(0, Math.min(1, align)) : 1.0; // default: tip aligns to square center
      const bx = c.x - ux*(pAlign*headLen), by = c.y - uy*(pAlign*headLen); // base midpoint
      const tx = c.x + ux*((1-pAlign)*headLen), ty = c.y + uy*((1-pAlign)*headLen); // tip
      const lx=bx+px*(headWidth/2), ly=by+py*(headWidth/2);
      const rx=bx-px*(headWidth/2), ry=by-py*(headWidth/2);
      // Draw shaft only up to base midpoint
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(bx,by); ctx.stroke();
      // Draw head with centroid at c
      ctx.beginPath(); ctx.moveTo(tx,ty); ctx.lineTo(lx,ly); ctx.lineTo(rx,ry); ctx.closePath(); ctx.fill();
      ctx.restore();
    }
    function renderArrows(){
      const info=ensureArrowCanvas(); if(!info) return;
      const {cv,dpr}=info; const ctx=cv.getContext('2d'); if(!ctx) return; ctx.clearRect(0,0,cv.width,cv.height);
      const red = getComputedStyle(document.documentElement).getPropertyValue('--arrow-user').trim()||'#ff5c5c';
      const green = getComputedStyle(document.documentElement).getPropertyValue('--arrow-best').trim()||'#2ecc71';
      const cyan = getComputedStyle(document.documentElement).getPropertyValue('--arrow-engine').trim()||'#00bcd4';
      const u=BOARD.arrows.user; if(u){ drawArrow(ctx,dpr,u.slice(0,2),u.slice(2,4),red,false); }
      const b=BOARD.arrows.best; if(b && BOARD.arrows.showBest){ drawArrow(ctx,dpr,b.slice(0,2),b.slice(2,4),green,false); }
      const e=BOARD.arrows.engine;
      if(Array.isArray(e) && e.length){
        const n=e.length; const maxA=0.85, minA=0.30; // best least transparent
        const maxS=2.00, minS=0.80; // best ~2x thicker/longer; weakest thinner
        // Draw weakest first so best ends up on top
        for(let i=n-1;i>=0;i--){
          const mv=e[i]||''; if(!mv || mv.length<4) continue;
          const a = (n===1) ? maxA : (maxA - (i*(maxA-minA)/(n-1)));
          const s = (n===1) ? maxS : (maxS - (i*(maxS-minS)/(n-1)));
          // Align arrow tip to the target square center for all engine arrows
          const align = 1.0;
          // Use slightly smaller head than shaft scale for clarity
          const h = (i===0) ? (s*0.8) : (s*0.9);
          drawArrow(ctx,dpr,mv.slice(0,2),mv.slice(2,4),cyan,false,a,s,align,h);
        }
      } else if(e){
        // Backward-compat: single engine arrow string
        drawArrow(ctx,dpr,e.slice(0,2),e.slice(2,4),cyan,false,0.85,2.00,1.0,2.00*0.8);
      }
    }

    function drawBoardInto(rootId, fen, whiteBottom){
      const el = document.getElementById(rootId); if(!el) return;
      if(!CB.extras[rootId]){
        CB.extras[rootId] = Chessboard(el, {
          draggable: false,
          showNotation: false,
          orientation: (whiteBottom ? 'white' : 'black'),
          position: fen || 'empty',
          pieceTheme: '/chessboardjs/img/chesspieces/wikipedia/{piece}.png',
          onMoveEnd: (oldPos, newPos) => { highlightLastMoveFromDiff(`#${rootId}`, oldPos, newPos); }
        });
      } else {
        CB.extras[rootId].orientation(whiteBottom ? 'white' : 'black');
        if(!fen) CB.extras[rootId].clear(true); else CB.extras[rootId].position(fen, false);
      }
      clearLastMoveHighlights(`#${rootId}`);
      // Ensure layout after visibility changes (e.g., viewer toggled)
      try { CB.extras[rootId].resize(); } catch {}
      setTimeout(()=>{ try{ CB.extras[rootId].resize(); }catch{} }, 0);
      setBoardFonts();
    }

    function setBoardFonts(){ renderArrows(); }

    // Last-move highlight helpers (for chessboard.js boards)
    function clearLastMoveHighlights(rootSel){
      try{ document.querySelectorAll(`${rootSel} [data-square].last-move`).forEach(el=>el.classList.remove('last-move')); }catch{}
    }
    function addLastMoveSquare(rootSel, sq){
      try{ const el = document.querySelector(`${rootSel} [data-square="${sq}"]`); if(el) el.classList.add('last-move'); }catch{}
    }
    function highlightLastMoveFromDiff(rootSel, oldPos, newPos){
      try{
        const o = oldPos||{}; const n = newPos||{};
        const squares = new Set([...Object.keys(o), ...Object.keys(n)]);
        const fromCandidates=[], toCandidates=[];
        for(const s of squares){
          const ov=o[s], nv=n[s];
          if(ov===nv) continue;
          if(ov && !nv) { fromCandidates.push(s); continue; }
          if(!ov && nv) { toCandidates.push(s); continue; }
          // changed piece (capture, move into occupied, etc.) => count as both
          fromCandidates.push(s); toCandidates.push(s);
        }
        let from=null, to=null;
        if(fromCandidates.length===1 && toCandidates.length===1){ from=fromCandidates[0]; to=toCandidates[0]; }
        else{
          // try pair by color/type similarity
          let best=null;
          for(const t of toCandidates){
            const np=n[t]; if(!np) continue;
            for(const f of fromCandidates){
              const op=o[f]; if(!op) continue;
              const sameColor = np[0]===op[0];
              const sameType  = np[1]===op[1];
              const score = (sameColor?1:0)+(sameType?2:0);
              const isKingDest = np && (np[1]==='K' || np[1]==='k');
              if(!best || score>best.score || (score===best.score && isKingDest)) best={from:f,to:t,score};
            }
          }
          if(best){ from=best.from; to=best.to; }
          else { from=fromCandidates[0]||null; to=toCandidates[0]||null; }
        }
        clearLastMoveHighlights(rootSel);
        if(from) addLastMoveSquare(rootSel, from);
        if(to) addLastMoveSquare(rootSel, to);
      }catch{}
    }

    function ensureMainBoard(){
      if(CB.main) return CB.main;
      const el = document.getElementById('board'); if(!el) return null;
      CB.main = Chessboard(el, {
        draggable: true,
        showNotation: false,
        orientation: ORIENT_WHITE_BOTTOM ? 'white' : 'black',
        position: 'empty',
        pieceTheme: '/chessboardjs/img/chesspieces/wikipedia/{piece}.png',
        onMoveEnd: (oldPos, newPos) => {
          // After animation, mark last moved squares
          highlightLastMoveFromDiff('#board', oldPos, newPos);
        },
        // Defer DOM sync until after snap completes to avoid ghost piece
        onSnapEnd: () => {
          try{
            CB.main.orientation(ORIENT_WHITE_BOTTOM ? 'white' : 'black');
            CB.main.position(BOARD.current || 'start', false);
            // Re-apply last-move square highlights after DOM sync
            clearLastMoveHighlights('#board');
            const lm = BOARD.lastFromTo; if(lm){ addLastMoveSquare('#board', lm.from); addLastMoveSquare('#board', lm.to); }
          }catch{}
        },
        onDragStart: (source, piece) => {
          try{
            const turn = BOARD.chess.turn();
            if((turn==='w' && piece[0] !== 'w') || (turn==='b' && piece[0] !== 'b')) return false;
          }catch{}
          return true;
        },
        onDrop: (source, target, piece, newPos, oldPos) => {
          try{
            if(source===target) return 'snapback';
            let uci = source + target;
            try{
              const legal = BOARD.chess.moves().filter(m=>m.from===source && m.to===target);
              if(legal.length){ let move=legal[0]; const q=legal.find(m=>m.promotion==='q'); if(q) move=q; if(move.promotion) uci+=move.promotion; }
            }catch{}
            const tmp=ChessLite(); tmp.loadFEN(BOARD.current); const mv=tmp.moveUci(uci);
            if(!mv.ok) return 'snapback';
            const nextFen = tmp.fen();
            try{ console.log('[Train]', new Date().toISOString(), 'onDrop move', { uci, nextFen }); }catch{}
            BOARD.chess.loadFEN(nextFen); BOARD.current=nextFen;
            // Remember last move squares for highlight re-application
            BOARD.lastFromTo = { from: source, to: target };
            try{ if($('#engineToggle')?.checked){ console.log('[EngineLive]', new Date().toISOString(), 'schedule analyzeDebounced after onDrop'); EngineLive.analyzeDebounced(nextFen); } }catch{}
            try{ $('#sideToMove').textContent = BOARD.chess.turn()==='w'?'White':'Black'; }catch{}
            try{ setTrainFen && setTrainFen(nextFen); }catch{}
            BOARD.arrows.showBest=false; BOARD.arrows.user=null; renderArrows();
            try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
            try{ TrainSession.answer(uci); }catch{}
          }catch(e){
            try{ console && console.warn && console.warn('onDrop error', e); }catch{}
            return 'snapback';
          }
        }
      });
      return CB.main;
    }

    function drawBoardMain(fen){
      try{ console.log('[Train]', new Date().toISOString(), 'drawBoardMain()', { fen, engineToggle: !!document.getElementById('engineToggle')?.checked }); }catch{}
      const board = ensureMainBoard(); if(!board) return;
      if(!fen){
        try{ setTrainFen && setTrainFen(''); }catch{}
        BOARD.current=null;
        BOARD.arrows.engine=null; try{ const el=$('#engineLines'); if(el) el.textContent=''; }catch{}
        board.clear(true);
        clearLastMoveHighlights('#board');
        setBoardFonts(); renderArrows(); return;
      }
      BOARD.chess.loadFEN(fen); BOARD.current=fen; $('#sideToMove').textContent = BOARD.chess.turn()==='w'?'White':'Black';
      try{ setTrainFen && setTrainFen(fen); }catch{}
      board.orientation(ORIENT_WHITE_BOTTOM ? 'white' : 'black');
      board.position(fen, false);
      clearLastMoveHighlights('#board');
      try{ board.resize(); }catch{}
      BOARD.selected=null; BOARD.highlights.clear(); setBoardFonts(); renderArrows();
      try{ updateEvalBar(EVALBAR.lastCpWhite||0); }catch{}
      try{ if($('#engineToggle')?.checked) EngineLive.analyzeDebounced(fen); }catch{}
    }

    function showHints(){
      $$('#board .sq').forEach(el=>el.classList.remove('sel','hl','hint'));
      if(!BOARD.current) return;
      const legal=BOARD.chess.moves();
      if(BOARD.selected!==null){
        const fromSq=BOARD.chess.idxToSq(BOARD.selected);
        $$('#board .sq').forEach(el=>{ if(parseInt(el.dataset.index,10)===BOARD.selected) el.classList.add('sel'); });
        for(const m of legal){ if(m.from===fromSq){ const el=$(`#board .sq[data-square="${m.to}"]`); if(el) el.classList.add('hint'); } }
      }
    }

    function onSquareClick(e){
      const idx=parseInt(e.currentTarget.dataset.index,10);
      if(BOARD.selected===null){
        const all=BOARD.chess.moves(); const sq=BOARD.chess.idxToSq(idx);
        if(all.some(m=>m.from===sq)){ BOARD.selected=idx; showHints(); }
      }else{
        const from=BOARD.chess.idxToSq(BOARD.selected); const to=e.currentTarget.dataset.square;
        if(from===to){ BOARD.selected=null; showHints(); return; } // deselect if same square
        let uci = from+to;
        const legal=BOARD.chess.moves().filter(m=>m.from===from && m.to===to);
        if(legal.length){ let move=legal[0]; if(legal.length>1){ const q=legal.find(m=>m.promotion==='q'); if(q) move=q; } if(move.promotion) uci+=move.promotion; }
        const tmp=ChessLite(); tmp.loadFEN(BOARD.current); const mv=tmp.moveUci(uci);
        // Always exit selection; only register + draw if legal
        if(mv.ok){
          drawBoardMain(tmp.fen());
          // clear old arrows, then answer
          BOARD.arrows.showBest=false; BOARD.arrows.user=null; renderArrows();
          try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
          try{ TrainSession.answer(uci); }catch{}
        }
        BOARD.selected=null; showHints();
      }
    }

    // Drag & Drop support
    let DRAG_FROM=null;
    function onDragStart(ev){
      const parent = ev.target.closest('.sq');
      DRAG_FROM = parent?.dataset.square || null;

      // Mark selected and show legal-move dots during drag
      try{
        if(DRAG_FROM){
          BOARD.selected = BOARD.chess.sqToIdx(DRAG_FROM);
          showHints();
        }
      }catch{}

      // Use a custom drag image to avoid dotted placeholders
      try{
        if(ev.dataTransfer){
          const ghost = ev.target.cloneNode(true);
          ghost.style.position='absolute'; ghost.style.top='-1000px';
          document.body.appendChild(ghost);
          ev.dataTransfer.setDragImage(ghost, ghost.offsetWidth/2, ghost.offsetHeight/2);
          setTimeout(()=>document.body.removeChild(ghost),0);
          ev.dataTransfer.setData('text/plain', DRAG_FROM||'');
        }
      }catch{}
    }
    function onDragEnd(){
      DRAG_FROM=null;
      // Clear selection/hints after drag
      BOARD.selected=null; showHints();
    }
    function onDragOver(ev){ ev.preventDefault(); }
    function onDrop(ev){
      ev.preventDefault();
      const to = ev.currentTarget.dataset.square;
      const from = DRAG_FROM || (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || null;
      if(!from || !to) return;
      if(from===to){ BOARD.selected=null; showHints(); return; } // deselect on same-square drop
      let uci = from+to;
      const legal=BOARD.chess.moves().filter(m=>m.from===from && m.to===to);
      if(legal.length){ let move=legal[0]; if(legal.length>1){ const q=legal.find(m=>m.promotion==='q'); if(q) move=q; } if(move.promotion) uci+=move.promotion; }
      const tmp=ChessLite(); tmp.loadFEN(BOARD.current); const mv=tmp.moveUci(uci);
      if(mv.ok){
        drawBoardMain(tmp.fen());
        BOARD.arrows.showBest=false; BOARD.arrows.user=null; renderArrows();
        try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
        try{ TrainSession.answer(uci); }catch{}
      }
      BOARD.selected=null; showHints();
    }

    function loadMistakeOnBoard(m){
      try{ console.log('[Train]', new Date().toISOString(), 'loadMistakeOnBoard()', { fen: m && m.fen, id: m && m.id, side: m && m.side }); }catch{}
      if(!m){ drawBoardMain(null); return; }
      gvHide();
      try{
        const deltaTxt = formatDeltaForDisplay(m);
        const label = (getClassifier()==='wp'?'win prob drop':'centipawn loss');
        $('#mInfo').innerHTML = `<span class=\"pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}\">${m.severity}</span> � ${label}: ${deltaTxt}`;
      }catch{}
      $('#mInfo').innerHTML = `<span class="mono">${m.fen.split(' ').slice(0,4).join(' ')}</span> · <span class="pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}">${m.severity}</span> · ?cp ${Math.round(m.deltaCp)}`;
      $('#yourMove').textContent='—'; $('#feedback').textContent='—';
      ORIENT_WHITE_BOTTOM = (m.side==='w');
      try{ initTrainViewFromMistake(m); }catch{}
      drawBoardMain(m.fen);
      try{
        const deltaTxt = formatDeltaForDisplay(m);
        const label = (getClassifier()==='wp'?'win prob drop':'centipawn loss');
        $('#mInfo').innerHTML = `<span class=\"pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}\">${m.severity}</span> � ${label}: ${deltaTxt}`;
      }catch{}
      try{ const both = formatBothDelta(m); $('#mInfo').innerHTML = `<span class=\"pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}\">${m.severity}</span> - loss (cp | wp): ${both}`; }catch{}
      // Arrows start clean; will draw on attempt/reveal
      BOARD.arrows.user = null; BOARD.arrows.best = m.best || null; BOARD.arrows.showBest = false; renderArrows();
      try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}

      // Update info
      try{
        setTrainFen(m.fen||'');
        setTrainPgn(m.pgn||'');
        updateTrainLink(m);
      }catch{}
      try{ adjustRightColWidth && adjustRightColWidth(); }catch{}
    }

    // Reveal, Show mistake & Next buttons
    $('#btnReveal').addEventListener('click', () => {
      const a=TrainSession.active; if(!a) return;
      const btn=$('#btnReveal');
      const isOn=!!BOARD.arrows.showBest;
      if(isOn){
        BOARD.arrows.showBest=false; renderArrows();
        btn && btn.setAttribute('aria-pressed','false');
        const fb=$('#feedback'); if(fb) fb.textContent='-';
      }else{
        // Revert to original mistake position, then show best arrow
        drawBoardMain(a.fen);
        const bestSan=uciToSAN(a.fen, a.best);
        $('#feedback').innerHTML = `Best move: <b class="mono">${bestSan || a.best}</b>`;
        BOARD.arrows.user=null; BOARD.arrows.best=a.best; BOARD.arrows.showBest=true; renderArrows();
        btn && btn.setAttribute('aria-pressed','true');
        const other=$('#btnShowMistake'); other && other.setAttribute('aria-pressed','false');
      }
    });
    // NEW: Show mistake arrow (red) for the move actually played in the game (toggle)
    $('#btnShowMistake').addEventListener('click', () => {
      const a=TrainSession.active; if(!a) return;
      const btn=$('#btnShowMistake');
      const cl=ChessLite(); cl.loadFEN(a.fen);
      const uci=cl.parseSANtoMove(a.played||'');
      if(!uci){ $('#feedback').textContent='Could not parse recorded mistake.'; return; }
      if(BOARD.arrows.user === uci){
        // toggle off
        BOARD.arrows.user=null; renderArrows();
        btn && btn.setAttribute('aria-pressed','false');
        const fb=$('#feedback'); if(fb) fb.textContent='-';
      }else{
        // toggle on (reset position to original mistake)
        drawBoardMain(a.fen);
        BOARD.arrows.best=null; // only show the user's (mistake) arrow
        BOARD.arrows.user=uci; BOARD.arrows.showBest=false; renderArrows();
        $('#feedback').innerHTML = `Mistake played: <b class="mono">${a.played}</b>`;
        btn && btn.setAttribute('aria-pressed','true');
        const other=$('#btnReveal'); other && other.setAttribute('aria-pressed','false');
      }
    });

    $('#btnBack')?.addEventListener('click', () => TrainSession.back());
    $('#btnNext').addEventListener('click', () => { try{ console.log('[Train]', new Date().toISOString(), 'Next clicked'); }catch{} TrainSession.next(); });
    $('#btnFlip').addEventListener('click', () => {
      ORIENT_WHITE_BOTTOM = !ORIENT_WHITE_BOTTOM;
      if(TRAINVIEW && TRAINVIEW.fens && TRAINVIEW.fens.length){
        const i = Math.max(0, Math.min(TRAINVIEW.idx||0, TRAINVIEW.fens.length-1));
        drawBoardMain(TRAINVIEW.fens[i]);
      } else if(TrainSession.active){
        drawBoardMain(TrainSession.active.fen);
      }
    });
    
    $('#btnExitTrain').addEventListener('click', () => {
      showSection('train');
      showTrainSelectionMode();
      renderTrainSelectList();
    });
    
    /********************************************************************
     * Mistake list + Stats
     ********************************************************************/
    // Stats page: set-filtered mistakes list + summary + preview board
    let STATS_SELECTED_SET_ID = null;
    let STATS_CURRENT_LIST = [];
    function renderStatsSetOptions(){
      const sel = $('#statsSetSelect'); if(!sel) return;
      const sets = sortSetsByCreated(loadSets());
      sel.innerHTML = '';
      const opt0 = document.createElement('option'); opt0.value=''; opt0.textContent='Select a set…'; sel.appendChild(opt0);
      for(const s of sets){ const o=document.createElement('option'); o.value=s.id; o.textContent=`${s.name} (${s.keys.length})`; sel.appendChild(o);
      }
      if(STATS_SELECTED_SET_ID){ sel.value = STATS_SELECTED_SET_ID; }
      else if(sets.length){ STATS_SELECTED_SET_ID = sets[0].id; sel.value = STATS_SELECTED_SET_ID; }
      sel.onchange = ()=>{ STATS_SELECTED_SET_ID = sel.value || null; renderStatsMistakeList(); renderStatsSummary(); drawBoardInto('statsBoard', null, true); $('#statsMInfo').textContent='-'; $('#statsSideToMove').textContent='-'; $('#statsBest').textContent='-'; $('#statsDelta').textContent='-'; };
    }

    function renderStatsMistakeList(){
      const tb=$('#statsMistakeTBody'); if(!tb) return;
      try{ const thCp=document.querySelector('#statsMistakeTable thead th:nth-child(6)'); if(thCp) thCp.textContent='loss (cp | wp)'; }catch{}
      tb.innerHTML='';
      const sets = loadSets(); const target = sets.find(s=>s.id===STATS_SELECTED_SET_ID);
      if(!target){ STATS_CURRENT_LIST=[]; $('#statsTotal') && ($('#statsTotal').textContent='0'); return; }
      const keySet = expandKeys(target.keys||[]);
      const all=loadMistakes();
      let list=all.filter(m => {
        const ks = keysForMistake(m);
        for(const k of ks){ if(keySet.has(k)) return true; }
        return false;
      });
      // Fallback to set snapshot items if mistakes not yet synced
      if((!list || list.length===0) && Array.isArray(target.items) && target.items.length){
        list = target.items.slice();
        // Opportunistically wait for remote mistakes then re-render
        try{ ensureMistakesForSet(target, 8000).then(()=>{ try{ renderStatsMistakeList(); renderStatsSummary(); }catch{} }); }catch{}
      }
      STATS_CURRENT_LIST = list;
      try{ console.debug('[client] stats list sample', (list||[]).slice(0,5).map(m=>({cp:m.deltaCp, wp:m.deltaWp, cpB:m.cpBefore, cpA:m.cpAfter}))); }catch{}
      list.forEach((m,i)=>{
        const bestSan = m.best ? uciToSAN(m.fen, m.best) : '-';
        const tr=document.createElement('tr');
      tr.innerHTML=`
          <td class="mono tiny">${i+1}</td>
          <td>${m.severity ? `<span class="pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}">${m.severity}</span>` : '-'}</td>
          <td>${m.side==='w'?'White':'Black'}</td>
          <td class="mono tiny">${m.played}</td>
          <td class="mono tiny">${bestSan}</td>
          <td class="mono tiny">${formatBothDelta(m)}</td>`;
        tr.addEventListener('click', ()=>{ loadMistakeOnStatsBoard(m); });
        tb.appendChild(tr);
      });
      const totalEl=$('#statsTotal'); if(totalEl) totalEl.textContent=list.length;
    }

    function renderStatsSummary(){
      const att=getAttempts(); const n=att.length; const correct=att.filter(a=>a.correct).length; const acc=n?Math.round(100*correct/n):0;
      $('#statsAcc') && ($('#statsAcc').textContent = n ? `${acc}% (${correct}/${n})` : '-');
      $('#statsReviews') && ($('#statsReviews').textContent = String(n));

      const counts={inaccuracy:0,mistake:0,blunder:0};
      for(const m of (STATS_CURRENT_LIST||[])){ if(counts[m.severity]!==undefined) counts[m.severity]++; }
      const canvas=$('#statsSevChart'); if(!canvas) return; const ctx=canvas.getContext('2d'); const W=canvas.width,H=canvas.height;
      ctx.clearRect(0,0,W,H); ctx.fillStyle='#0d0f15'; ctx.fillRect(0,0,W,H);
      const labels=['Inacc','Mistake','Blunder'], keys=['inaccuracy','mistake','blunder']; const maxv=Math.max(1, ...keys.map(k=>counts[k])); const barW=Math.floor((W-80)/3);
      for(let i=0;i<3;i++){ const x=40+i*(barW+20); const v=counts[keys[i]]; const h=Math.round((H-40)*(v/maxv)); ctx.fillStyle=i===0?'#2f9e44':(i===1?'#f2c94c':'#ff6b6b'); ctx.fillRect(x,H-20-h,barW,h); ctx.fillStyle='#9aa4b2'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.fillText(labels[i],x+barW/2,H-6); ctx.fillText(String(v),x+barW/2,H-28-h); }
    }

    function loadMistakeOnStatsBoard(m){
      if(!m){ drawBoardInto('statsBoard', null, true); return; }
      $('#statsMInfo').textContent = m.fen.split(' ').slice(0,4).join(' ');
      $('#statsSideToMove').textContent = (m.side==='w')?'White':'Black';
      const bestSan = m.best ? uciToSAN(m.fen, m.best) : '-';
      $('#statsBest').textContent = bestSan || m.best || '-';
      try{ const lbl=$('#statsDelta')?.parentElement?.querySelector('b'); if(lbl) lbl.textContent='loss (cp | wp):'; }catch{}
      $('#statsDelta').textContent = formatBothDelta(m);
      try{
        const sideUser = userSideForPGN(m.pgn||'');
        const whiteBottom = sideUser ? (sideUser==='w') : true;
        drawBoardInto('statsBoard', m.fen, whiteBottom);
      }catch{
        const whiteBottom = (m.side==='w');
        drawBoardInto('statsBoard', m.fen, whiteBottom);
      }
    }

    /********************************************************************
     * Import controls & toggles
     ********************************************************************/
    let ANALYZE_STATE = { stop:false };
    let LAST_ANALYZED = { mistakes: [], suggestedName: '' };
    const btnAnalyze = $('#btnAnalyzeImported');
    btnAnalyze?.addEventListener('click', async () => {
      if(btnAnalyze.dataset.state!=='running'){
        // start analysis
        btnAnalyze.dataset.state='running';
        btnAnalyze.textContent='Stop analysis';
        btnAnalyze.classList.remove('btn-green'); btnAnalyze.classList.add('btn-red');
        ANALYZE_STATE={stop:false};
        // reset create-set affordance while (re)running (keep visible)
        try{
          LAST_ANALYZED = { mistakes: [], suggestedName: '' };
          const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo');
          if(btn) btn.textContent='Create set (0 mistakes)';
          if(info) info.textContent='-';
        }catch{}
        try{
          const mode = (window.getAnalysisMode ? window.getAnalysisMode() : 'double');
          if(mode !== 'single'){
            const fd = (window.getFastDepth ? window.getFastDepth() : 12);
            setStatus(`Fast pass at depth: ${fd}`);
          } else {
            const deep = parseInt(window.getAnalysisDepth?.()||12,10)||12;
            setStatus(`Deep analysis at depth: ${deep}`);
          }
          setMistakeCounter(0);
        }catch{}
        try{
          const mode = (window.getAnalysisMode ? window.getAnalysisMode() : 'double');
          const fn = (mode==='single') ? analyzeImportedSingleFlow : (window.analyzeImportedWithBackendAbortable2 ? analyzeImportedWithBackendAbortable2 : analyzeImportedWithBackendAbortable);
          await fn(ANALYZE_STATE);
        }catch(e){ setStatus('Error: '+(e?.message||e)); }
        // ensure button reset (in case stop wasn't pressed)
        btnAnalyze.dataset.state='idle';
        btnAnalyze.textContent='Analyse mistakes';
        btnAnalyze.classList.remove('btn-red'); btnAnalyze.classList.add('btn-green');
      }else{
        // stop analysis - immediately revert UI as requested
        ANALYZE_STATE.stop=true;
        btnAnalyze.dataset.state='idle';
        btnAnalyze.textContent='Analyse mistakes';
        btnAnalyze.classList.remove('btn-red'); btnAnalyze.classList.add('btn-green');
      }
    });

    // Create set from last analysis (manual)
    $('#btnCreateSetFromLast')?.addEventListener('click', () => {
      const n = (LAST_ANALYZED && Array.isArray(LAST_ANALYZED.mistakes)) ? LAST_ANALYZED.mistakes.length : 0;
      if(!n){ alert('No mistakes available from the last analysis.'); return; }
      const defName = (LAST_ANALYZED && LAST_ANALYZED.suggestedName) ? LAST_ANALYZED.suggestedName : `Imported ${new Date().toLocaleString()}`;
      const name = prompt(`Enter set name (${n} mistake${n!==1?'s':''})`, defName || 'New Set');
      if(!name) return;
      const set = createSetFromMistakes(LAST_ANALYZED.mistakes, name.trim());
      setStatus(`Created set "${set.name}" with ${set.keys.length} mistake(s).`);
      try{ const info=$('#createSetInfo'); if(info) info.textContent = `Created set "${set.name}" with ${set.keys.length} mistake(s).`; }catch{}
      renderSets(); renderSetsForTrain();
    });

    $('#btnClearImports')?.addEventListener('click', () => {
      const toRemove = new Set((window.importedGames||[]).map(r=>r.pgn));

      // NEW: Ask user; default is to KEEP mistakes (recommended)
      if(toRemove.size){
        const drop = window.confirm('Also remove mistakes created from these imports?\n\nRecommended: Choose "Cancel" to keep mistakes so saved sets continue to work.');
        if(drop){
          let list = loadMistakes();
          list = list.filter(m => !toRemove.has(m.pgn));
          saveMistakes(list);
        }
      }

      // Clear table + viewer + state
      window.importedGames = [];
      try{ if(fb()) fb().clearImportsRemote().catch(()=>{}); }catch{}
      rebuildImportedTable();
      const help=$('#importHelp'); if(help) help.textContent='Imported games cleared.';
      gvHide();

      // leave LAST_ANALYZED as-is
      try{
        LAST_ANALYZED = { mistakes: LAST_ANALYZED.mistakes || [], suggestedName: LAST_ANALYZED.suggestedName || '' };
      }catch{}
    });

    $('#btnFetchLichess').addEventListener('click', async () => {
      const u=$('#lichessUser').value.trim(); if(!u) return alert('Enter a Lichess username');
      try{ const n=parseInt($('#lichessCount')?.value,10)||5; setStatus(`Fetching Lichess games (N=${n})…`); await fetchLichess(u,n); setStatus('Idle'); }catch(e){ setStatus('Error: '+(e?.message||e)); }
    });

    $('#btnFetchChesscom').addEventListener('click', async () => {
      const u=$('#chesscomUser').value.trim(); if(!u) return alert('Enter a Chess.com username');
      try{ const n=parseInt($('#chesscomCount')?.value,10)||5; setStatus(`Fetching Chess.com games (N=${n})…`); await fetchChesscom(u,n); setStatus('Idle'); }catch(e){ setStatus('Error: '+(e?.message||e)); }
    });


    // Unified import controls
    $('#btnImportUnified')?.addEventListener('click', async () => { try{ const fn=(window.importUnified||importUnified); await fn(); }catch(e){ setStatus('Error: '+(e?.message||e)); } });
    $('#btnImportSettings')?.addEventListener('click', () => {
      const box = document.getElementById('importSettingsBox'); if(!box) return;
      box.style.display = (box.style.display==='none' || !box.style.display) ? 'block' : 'none';
      try{ (window.applyPrefsToUI||applyPrefsToUI)(); }catch{}
    });
    $('#modeCount')?.addEventListener('change', ()=>{ if($('#modeCount').checked){ $('#periodWrap').style.display='none'; $('#countWrap2').style.display='block'; (window.savePrefsLocal||savePrefsLocal)({importMode:'count'}); try{ fb()&&fb().savePrefs({importMode:'count'}); }catch{} } });
    $('#modeTime')?.addEventListener('change', ()=>{ if($('#modeTime').checked){ $('#periodWrap').style.display='block'; $('#countWrap2').style.display='none'; (window.savePrefsLocal||savePrefsLocal)({importMode:'time'}); try{ fb()&&fb().savePrefs({importMode:'time'}); }catch{} } });
    $('#importCount')?.addEventListener('change', ()=>{ const v=parseInt($('#importCount')?.value||'10',10)||10; if($('#importCount2')) $('#importCount2').value=String(v); (window.savePrefsLocal||savePrefsLocal)({importCount:v}); try{ fb()&&fb().savePrefs({importCount:v}); }catch{} });
    $('#importCount2')?.addEventListener('change', ()=>{ const v=parseInt($('#importCount2')?.value||'10',10)||10; if($('#importCount')) $('#importCount').value=String(v); (window.savePrefsLocal||savePrefsLocal)({importCount:v}); try{ fb()&&fb().savePrefs({importCount:v}); }catch{} });
    document.getElementById('periodValue')?.addEventListener('change', ()=>{ const v=document.getElementById('periodValue')?.value; (window.savePrefsLocal||savePrefsLocal)({periodValue:parseFloat(v)||30}); try{ fb()&&fb().savePrefs({periodValue:parseFloat(v)||30}); }catch{} });
    document.getElementById('periodUnit')?.addEventListener('change', ()=>{ const u=document.getElementById('periodUnit')?.value; (window.savePrefsLocal||savePrefsLocal)({periodUnit:u}); try{ fb()&&fb().savePrefs({periodUnit:u}); }catch{} });
    $('#provLichess')?.addEventListener('change', ()=>{ const on=$('#provLichess').checked; (window.savePrefsLocal||savePrefsLocal)({provLichess:on}); try{ fb()&&fb().savePrefs({provLichess:on}); }catch{} });
    $('#provChesscom')?.addEventListener('change', ()=>{ const on=$('#provChesscom').checked; (window.savePrefsLocal||savePrefsLocal)({provChesscom:on}); try{ fb()&&fb().savePrefs({provChesscom:on}); }catch{} });
    $('#accLichess')?.addEventListener('change', ()=>{ const v=$('#accLichess').value.trim(); (window.savePrefsLocal||savePrefsLocal)({lichessUser:v}); try{ fb()&&fb().savePrefs({lichessUser:v}); }catch{}; if($('#lichessUser')) $('#lichessUser').value=v; });
    $('#accChessCom')?.addEventListener('change', ()=>{ const v=$('#accChessCom').value.trim(); (window.savePrefsLocal||savePrefsLocal)({chesscomUser:v}); try{ fb()&&fb().savePrefs({chesscomUser:v}); }catch{}; if($('#chesscomUser')) $('#chesscomUser').value=v; });
    window.addEventListener('firebase:prefsUpdated', applyPrefsToUI);
    $('#btnSaveImportSettings')?.addEventListener('click', async ()=>{
      try{
        const prefs = {
          provLichess: !!($('#provLichess') && $('#provLichess').checked),
          provChesscom: !!($('#provChesscom') && $('#provChesscom').checked),
          importMode: ($('#modeTime') && $('#modeTime').checked) ? 'time' : 'count',
          importCount: parseInt($('#importCount2')?.value||'10',10)||10,
          periodValue: parseFloat(document.getElementById('periodValue')?.value||'30')||30,
          periodUnit: (document.getElementById('periodUnit')?.value||'days'),
          lichessUser: ($('#accLichess')?.value||'').trim(),
          chesscomUser: ($('#accChessCom')?.value||'').trim(),
        };
        (window.savePrefsLocal||savePrefsLocal)(prefs);
        try{ fb() && await fb().savePrefs(prefs); }catch{}
        setStatus('Settings saved.');
        try{ const box=document.getElementById('importSettingsBox'); if(box) box.style.display='none'; }catch{}
      }catch(e){ setStatus('Error: '+(e?.message||e)); }
    });
    $('#btnLinkChessCom')?.addEventListener('click', async ()=>{
      const v=($('#accChessCom')?.value||'').trim(); if(!v) { alert('Enter Chess.com username'); return; }
      (window.savePrefsLocal||savePrefsLocal)({chesscomUser:v}); try{ fb()&&await fb().savePrefs({chesscomUser:v}); }catch{}
      if($('#chesscomUser')) $('#chesscomUser').value=v;
      setStatus('Chess.com account linked.');
    });
    $('#btnLinkLichess')?.addEventListener('click', async ()=>{
      const v=($('#accLichess')?.value||'').trim(); if(!v) { alert('Enter Lichess username'); return; }
      (window.savePrefsLocal||savePrefsLocal)({lichessUser:v}); try{ fb()&&await fb().savePrefs({lichessUser:v}); }catch{}
      if($('#lichessUser')) $('#lichessUser').value=v;
      setStatus('Lichess account linked.');
    });

    // Game viewer controls
    $('#gvPrev')?.addEventListener('click', () => { if(GAMEVIEW.idx>0){ GAMEVIEW.idx--; setTimeout(()=>{ drawBoardInto('gvBoard', GAMEVIEW.fens[GAMEVIEW.idx], GAMEVIEW.whiteBottom); gvUpdate(); }, 0); } });
    $('#gvNext')?.addEventListener('click', () => { if(GAMEVIEW.idx+1<GAMEVIEW.fens.length){ GAMEVIEW.idx++; setTimeout(()=>{ drawBoardInto('gvBoard', GAMEVIEW.fens[GAMEVIEW.idx], GAMEVIEW.whiteBottom); gvUpdate(); }, 0); } });
    $('#gvStart')?.addEventListener('click', () => { GAMEVIEW.idx=0; setTimeout(()=>{ drawBoardInto('gvBoard', GAMEVIEW.fens[GAMEVIEW.idx], GAMEVIEW.whiteBottom); gvUpdate(); }, 0); });
    $('#gvEnd')?.addEventListener('click', () => { GAMEVIEW.idx=Math.max(0,GAMEVIEW.fens.length-1); setTimeout(()=>{ drawBoardInto('gvBoard', GAMEVIEW.fens[GAMEVIEW.idx], GAMEVIEW.whiteBottom); gvUpdate(); }, 0); });

    // Train viewer controls (operate on main board, ignore explored lines)
    $('#tvPrev')?.addEventListener('click', () => {
      if(!TRAINVIEW.fens.length) return;
      if(TRAINVIEW.idx>0){ TRAINVIEW.idx--; }
      else { return; }
      setTimeout(()=>{ drawBoardMain(TRAINVIEW.fens[TRAINVIEW.idx]); tvUpdate(); resetTrainToggles(); }, 0);
    });
    $('#tvNext')?.addEventListener('click', () => {
      if(!TRAINVIEW.fens.length) return;
      if(TRAINVIEW.idx+1<TRAINVIEW.fens.length){ TRAINVIEW.idx++; }
      else { return; }
      setTimeout(()=>{ drawBoardMain(TRAINVIEW.fens[TRAINVIEW.idx]); tvUpdate(); resetTrainToggles(); }, 0);
    });
    $('#tvStart')?.addEventListener('click', () => {
      if(!TRAINVIEW.fens.length) return;
      TRAINVIEW.idx=0;
      setTimeout(()=>{ drawBoardMain(TRAINVIEW.fens[TRAINVIEW.idx]); tvUpdate(); resetTrainToggles(); }, 0);
    });
    $('#tvEnd')?.addEventListener('click', () => {
      if(!TRAINVIEW.fens.length) return;
      TRAINVIEW.idx=Math.max(0, TRAINVIEW.fens.length-1);
      setTimeout(()=>{ drawBoardMain(TRAINVIEW.fens[TRAINVIEW.idx]); tvUpdate(); resetTrainToggles(); }, 0);
    });

    /********************************************************************
     * Session start buttons
     ********************************************************************/
    const __btnStart = document.getElementById('btnStart');
    __btnStart && __btnStart.addEventListener('click', async () => {
      // Ensure a set is active; default to first
      let s = ACTIVE_SET;
      if(!s){ const sets = loadSets(); if(sets.length){ s = sets[0]; setActiveSet(s); } }
      if(!s){ alert('Create or select a set first.'); return; }

      // Enter training mode and wait for mistakes to be available
      enterTrainingMode();
      renderActiveSetInfo();
      try{ const info=document.getElementById('mInfo'); if(info) info.textContent='Loading set.'; }catch{}
      await hydrateMistakesFromSet(s);
      try{ await ensureMistakesForSet(s, 10000); }catch{}

      TrainSession.start();
    });
    // Mode selector removed

    /********************************************************************
     * Init + preferences + nav
     ********************************************************************/
    (async function init(){
      // prefs
      try{
        const bs = localStorage.getItem('pmtt_board_size');
        const curDefault = parseInt((getComputedStyle(document.documentElement).getPropertyValue('--board-size')||'520').replace('px',''))||520;
        const cur = bs ? parseInt(bs,10) : curDefault;
        applyBoardSize(cur);
      }catch{}

      // apply unified import prefs
      try{ (window.applyPrefsToUI||applyPrefsToUI)(); }catch{}

      rebuildImportedTable();
      renderStatsSetOptions(); renderStatsMistakeList(); renderStatsSummary(); renderSets(); renderSetsForTrain(); renderActiveSetInfo();
      // One-time backfill:
      // 1) Add snapshot items to old sets that have none
      // 2) Ensure all snapshot items carry severity (compute from deltaCp when missing)
      try{
        const sets = loadSets();
        let changed = false;
        const all = loadMistakes();
        for(const s of sets){
          if(!Array.isArray(s.items)){
            const items = [];
            const keySet = expandKeys(s.keys||[]);
            for(const m of all){
              const ks = keysForMistake(m);
              for(const k of ks){ if(keySet.has(k)){ items.push(snapshotMistake(m)); break; } }
            }
            s.items = items;
            s.version = 2;
            changed = true;
          } else {
            // Backfill severity for existing items
            let touched = false;
            for(let i=0;i<s.items.length;i++){
              const it = s.items[i] || {};
              if(typeof it.severity === 'undefined' || it.severity === null){
                try{ it.severity = severityFromDrop(it.deltaCp); touched = true; }catch{ it.severity = null; }
              }
            }
            if(touched){ changed = true; }
          }
        }
        if(changed) saveSets(sets);
      }catch{}
      drawBoardMain(null);
      try{ setTrainNavEnabled(false); tvUpdate(); }catch{}
      setStatus('Loading engine…'); await Engine.ensure(); setStatus('Idle');
      // Setup Game Info expanders (FEN/PGN)
      try{
        function setupExpander(rootId, textId, copyBtnId){
          const root=document.getElementById(rootId); if(!root) return;
          const collapsed = root.querySelector('.exp-collapsed');
          const ta = document.getElementById(textId);
          const btn = document.getElementById(copyBtnId);
          const open = ()=>{ root.classList.add('open'); try{ ta && ta.focus(); }catch{} };
          const close = ()=>{ root.classList.remove('open'); };
          collapsed && collapsed.addEventListener('click', open);
          collapsed && collapsed.setAttribute('tabindex','0');
          collapsed && collapsed.addEventListener('keydown', (e)=>{ if(e.key==='Enter'||e.key===' '){ e.preventDefault(); open(); }});
          document.addEventListener('click', (e)=>{ if(!root.contains(e.target)) close(); });
          ta && ta.addEventListener('keydown', (e)=>{ if(e.key==='Escape') close(); });
          btn && btn.addEventListener('click', ()=>{ try{ navigator.clipboard.writeText(ta?.value||''); setStatus('Copied'); }catch{} });
        }
        setupExpander('fenField','trainFenFull','copyFen');
        setupExpander('pgnField','trainPgnFull','copyPgn');
      }catch{}

      // keep boards/arrows sized when window resizes
      window.addEventListener('resize', ()=>{
        try{ CB.main && CB.main.resize(); }catch{}
        try{ Object.values(CB.extras||{}).forEach(b=>{ try{ b && b.resize && b.resize(); }catch{} }); }catch{}
        setBoardFonts();
        try{ adjustRightColWidth && adjustRightColWidth(); }catch{}
      });

      // Enable board drag-resize via the corner handle
      setupBoardResizeHandle();
      // Engine toggle handlers
      try{
        const tog=$('#engineToggle');
        tog && tog.addEventListener('change', ()=>{
          try{ console.log('[EngineLive]', new Date().toISOString(), 'toggle change ->', tog.checked ? 'ON' : 'OFF'); }catch{}
          if(tog.checked){ EngineLive.enable(); if(BOARD.current) EngineLive.analyzeDebounced(BOARD.current); }
          else { EngineLive.disable(); }
        });
        const btnRestart=$('#btnRestartEngine');
        btnRestart && btnRestart.addEventListener('click', ()=>{ try{ console.log('[EngineLive]', new Date().toISOString(), 'manual restart'); }catch{}; try{ EngineLive.restart && EngineLive.restart(); }catch{} });
        // MultiPV stepper
// Removed inline Lines +/- controls; configure via Engine settings modal
      }catch{}
    })();

    // Board size preference
    function applyBoardSize(v){
      // Allow large sizes so fullscreen resizing isn't capped artificially
      const hi = 2400; // upper bound; final width still limited by layout (min(100%, var(--board-size)))
      let size = Math.max(320, Math.min(hi, parseInt(v,10)||520));
      // Snap to nearest multiple of 8 to avoid leftover grey borders from rounding
      size = size - (size % 8);
      document.documentElement.style.setProperty('--board-size', size+'px');
      const lbl=$('#boardSizeVal'); if(lbl) lbl.textContent = `(${size})`;
      localStorage.setItem('pmtt_board_size', String(size));
      try{ CB.main && CB.main.resize(); }catch{}
      try{ Object.values(CB.extras||{}).forEach(b=>{ try{ b && b.resize && b.resize(); }catch{} }); }catch{}
      setBoardFonts();
      renderArrows();
    }
    // Ensure main board width snaps to 8px grid even when constrained by layout (e.g., window resize)
    function snapMainBoardToGrid(){
      try{
        const outer = document.getElementById('trainBoard'); if(!outer) return;
        const avail = Math.floor(outer.parentElement ? outer.parentElement.clientWidth : outer.clientWidth);
        if(!avail) return;
        const snapped = avail - (avail % 8);
        if(snapped>0){
          const curr = getComputedStyle(document.documentElement).getPropertyValue('--board-size').trim();
          const currPx = parseInt(curr||'0',10)||0;
          if(currPx !== snapped){ document.documentElement.style.setProperty('--board-size', snapped+'px'); }
          try{ CB.main && CB.main.resize(); }catch{}
        }
      }catch{}
    }
    // Train page: selection list (click to start training)
    function renderTrainSelectList(){
      const tb = $('#trainSelectTBody'); if(!tb) return;
      tb.innerHTML='';
      const sets = sortSetsByCreated(loadSets()); let i=0;
      for(const s of sets){
        const tr = document.createElement('tr');
        tr.style.cursor='pointer';
        tr.innerHTML = `<td>${++i}</td><td>${s.name}</td><td>${s.keys.length}</td><td><button class="ghost" data-id="${s.id}">Train</button></td>`;
        const start = async ()=>{ setActiveSet(s); enterTrainingMode(); renderActiveSetInfo(); try{ const info=document.getElementById('mInfo'); if(info) info.textContent='Loading set.'; }catch{}; await hydrateMistakesFromSet(s); try{ await ensureMistakesForSet(s, 10000); }catch{}; TrainSession.start(); };
        tr.addEventListener('click', (ev)=>{ if((ev.target && ev.target.tagName==='BUTTON')) return; start(); });
        tr.querySelector('button')?.addEventListener('click', (ev)=>{ ev.stopPropagation(); start(); });
        tb.appendChild(tr);
      }
    }

    function enterTrainingMode(){
      const sec = document.getElementById('trainSection'); if(!sec) return;
      sec.classList.add('training-mode');
      try{ gvHide(); }catch{}
      setTimeout(()=>{ try{ ensureMainBoard(); snapMainBoardToGrid(); CB.main && CB.main.resize(); }catch{} setBoardFonts(); renderArrows(); }, 0);
    }
    function showTrainSelectionMode(){
      const sec = document.getElementById('trainSection'); if(!sec) return;
      sec.classList.remove('training-mode');
      try{ drawBoardMain(null); }catch{}
      try{ setTrainNavEnabled(false); tvUpdate(); }catch{}
    }
    // Pointer-based resize on the corner handle
    function setupBoardResizeHandle(){
      const handle = document.getElementById('resizeHandle');
      const boardEl = document.getElementById('trainBoard');
      if(!handle || !boardEl) return;
      let startRect=null, active=false, mode='corner';
      const CORNER=12; // px inside bottom-right corner considered resizable zone

      const onMove = (ev)=>{
        if(!active) return;
        const t = ev.touches && ev.touches[0];
        const clientX = (t ? t.clientX : ev.clientX) ?? 0;
        const clientY = (t ? t.clientY : ev.clientY) ?? 0;
        const r = startRect || boardEl.getBoundingClientRect();
        let targetPx = 0;
        if(mode==='right') targetPx = clientX - r.left;
        else if(mode==='bottom') targetPx = clientY - r.top;
        else targetPx = Math.max(clientX - r.left, clientY - r.top);
        const next = Math.round(targetPx);
        applyBoardSize(next);
      };
      const end = ()=>{
        if(!active) return;
        active=false;
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', end);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', end);
        try{ document.body.style.userSelect=''; document.body.style.cursor=''; boardEl.classList.remove('resize-corner-hover'); }catch{}
      };
      handle.addEventListener('pointerdown', (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        active=true;
        startRect = boardEl.getBoundingClientRect(); mode='corner';
        try{ handle.setPointerCapture && handle.setPointerCapture(ev.pointerId); }catch{}
        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', end, {passive:false});
        try{ document.body.style.userSelect='none'; document.body.style.cursor='nwse-resize'; }catch{}
      });
      // Basic touch support
      handle.addEventListener('touchstart', (ev)=>{
        const t = ev.touches && ev.touches[0]; if(!t) return;
        ev.preventDefault(); ev.stopPropagation(); active=true;
        startRect = boardEl.getBoundingClientRect(); mode='corner';
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', end);
        try{ document.body.style.userSelect='none'; document.body.style.cursor='nwse-resize'; }catch{}
      }, {passive:false});

      // Only allow grabbing from the very bottom-right corner
      const zoneAt = (clientX, clientY)=>{
        const r = boardEl.getBoundingClientRect();
        const nearRight = (r.right - clientX) >= 0 && (r.right - clientX) <= CORNER;
        const nearBottom = (r.bottom - clientY) >= 0 && (r.bottom - clientY) <= CORNER;
        const inside = clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom;
        if(inside && nearRight && nearBottom) return 'corner';
        return null;
      };
      // Disable outside-board initiation
      const zoneAtExtended = (_x, _y)=> null;
      const hoverCheck = (ev)=>{
        if(active) return;
        const cx = ev.clientX ?? 0, cy = ev.clientY ?? 0;
        if(zoneAt(cx, cy)) boardEl.classList.add('resize-corner-hover');
        else boardEl.classList.remove('resize-corner-hover');
      };
      const startFromCorner = (ev)=>{
        const t = ev.touches && ev.touches[0];
        const cx = (t ? t.clientX : ev.clientX) ?? 0;
        const cy = (t ? t.clientY : ev.clientY) ?? 0;
        const z = zoneAt(cx, cy); if(!z) return;
        ev.preventDefault(); ev.stopPropagation();
        active=true; mode=z; startRect = boardEl.getBoundingClientRect();
        try{ boardEl.setPointerCapture && boardEl.setPointerCapture(ev.pointerId); }catch{}
        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', end, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', end);
        try{ document.body.style.userSelect='none'; document.body.style.cursor='nwse-resize'; }catch{}
      };
      // Use capture to intercept before piece drag begins
      boardEl.addEventListener('pointermove', hoverCheck, true);
      boardEl.addEventListener('pointerleave', ()=> boardEl.classList.remove('resize-corner-hover'));
      boardEl.addEventListener('pointerdown', startFromCorner, true);
      boardEl.addEventListener('touchstart', startFromCorner, {passive:false, capture:true});
      boardEl.addEventListener('dragstart', (ev)=>{ if(active) { ev.preventDefault(); ev.stopPropagation(); } }, true);

      // Also listen on the document to catch clicks just outside the board corner/edges
      const docStart = (ev)=>{
        if(active) return;
        const t = ev.touches && ev.touches[0];
        const cx = (t ? t.clientX : ev.clientX) ?? 0;
        const cy = (t ? t.clientY : ev.clientY) ?? 0;
        const z = zoneAtExtended(cx, cy);
        if(!z) return;
        ev.preventDefault(); ev.stopPropagation();
        active=true; mode=z; startRect = boardEl.getBoundingClientRect();
        try{ document.body.style.userSelect='none'; document.body.style.cursor='nwse-resize'; }catch{}
        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', end, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', end);
      };
      document.addEventListener('pointerdown', docStart, true);
      document.addEventListener('touchstart', docStart, {passive:false, capture:true});
    }

  </script>

  <script>
    // Analysis settings modal
    (function(){
      const LS_DEPTH = 'pmtt_an_depth';
      const LS_FAST = 'pmtt_an_fast_depth';
      const LS_MODE = 'pmtt_an_mode';
      const LS_FLAGS = 'pmtt_sev_flags'; // {inacc:boolean, mistake:boolean, blunder:boolean}
      const LS_SEV = 'pmtt_sev'; // thresholds object {inacc, mistake, blunder}
      const LS_SEV_WP = 'pmtt_sev_wp'; // thresholds for win probability drop (percent)
      const LS_CLASS = 'pmtt_classifier'; // 'cp' | 'wp'

      function loadDepth(){
        try{
          const v = localStorage.getItem(LS_DEPTH);
          if(v!=null) return Math.max(6, Math.min(40, parseInt(v,10)||12));
        }catch{}
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          const d = p && p.analysisDepth;
          if(d!=null) return Math.max(6, Math.min(40, parseInt(d,10)||12));
        }catch{}
        return 12;
      }
      function saveDepth(n){ try{ localStorage.setItem(LS_DEPTH, String(Math.max(6, Math.min(40, parseInt(n,10)||12)))); }catch{} }
      function loadFastDepth(){
        try{
          const v = localStorage.getItem(LS_FAST);
          if(v!=null) return Math.max(6, Math.min(40, parseInt(v,10)||12));
        }catch{}
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          const d = p && (p.analysisFastDepth ?? p.fastDepth);
          if(d!=null) return Math.max(6, Math.min(40, parseInt(d,10)||12));
        }catch{}
        return 12;
      }
      function saveFastDepth(n){ try{ localStorage.setItem(LS_FAST, String(Math.max(6, Math.min(40, parseInt(n,10)||12)))); }catch{} }
      function loadMode(){
        try{
          const v = localStorage.getItem(LS_MODE);
          if(v) return (v==='single'?'single':'double');
        }catch{}
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          const m = p && p.analysisMode;
          if(m) return (m==='single'?'single':'double');
        }catch{}
        return 'double';
      }
      function saveMode(m){ try{ localStorage.setItem(LS_MODE, (m==='single'?'single':'double')); }catch{} }
      function loadClassifier(){ try{ const v=localStorage.getItem(LS_CLASS); return (v==='wp')?'wp':'cp'; }catch{ return 'cp'; } }
      function saveClassifier(v){ try{ localStorage.setItem(LS_CLASS, (v==='wp')?'wp':'cp'); }catch{} }
      function loadFlags(){
        try{
          const o=JSON.parse(localStorage.getItem(LS_FLAGS)||'{}');
          return { inacc: o.inacc!==false, mistake: o.mistake!==false, blunder: o.blunder!==false };
        }catch{}
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          const o = p && p.analysisInclude;
          if(o && typeof o==='object') return { inacc: o.inacc!==false, mistake: o.mistake!==false, blunder: o.blunder!==false };
        }catch{}
        return {inacc:true, mistake:true, blunder:true};
      }
      function saveFlags(f){ try{ localStorage.setItem(LS_FLAGS, JSON.stringify({ inacc:!!f.inacc, mistake:!!f.mistake, blunder:!!f.blunder })); }catch{} }
      function loadSev(){
        try{
          const d=JSON.parse(localStorage.getItem(LS_SEV)||'{}');
          const base = { inacc: Number.isFinite(d.inacc)?d.inacc:50, mistake: Number.isFinite(d.mistake)?d.mistake:150, blunder: Number.isFinite(d.blunder)?d.blunder:300 };
          return base;
        }catch{}
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          const t = p && p.analysisThresholds;
          if(t && typeof t==='object') return { inacc: Number.isFinite(t.inacc)?t.inacc:50, mistake: Number.isFinite(t.mistake)?t.mistake:150, blunder: Number.isFinite(t.blunder)?t.blunder:300 };
        }catch{}
        return {inacc:50, mistake:150, blunder:300};
      }
      function saveSev(t){ try{ localStorage.setItem(LS_SEV, JSON.stringify({ inacc:Math.max(0,parseInt(t.inacc,10)||50), mistake:Math.max(0,parseInt(t.mistake,10)||150), blunder:Math.max(0,parseInt(t.blunder,10)||300) })); }catch{} }
      function loadSevWp(){
        try{
          const d=JSON.parse(localStorage.getItem(LS_SEV_WP)||'{}');
          const base = { inacc: Number.isFinite(d.inacc)?d.inacc:10, mistake: Number.isFinite(d.mistake)?d.mistake:20, blunder: Number.isFinite(d.blunder)?d.blunder:30 };
          return base;
        }catch{}
        return { inacc:10, mistake:20, blunder:30 };
      }
      function saveSevWp(t){ try{ localStorage.setItem(LS_SEV_WP, JSON.stringify({ inacc:Math.max(0,parseInt(t.inacc,10)||10), mistake:Math.max(0,parseInt(t.mistake,10)||20), blunder:Math.max(0,parseInt(t.blunder,10)||30) })); }catch{} }

      function includeSeverity(sev){
        try{
          const f = loadFlags();
          if(sev==='inaccuracy') return !!f.inacc;
          if(sev==='mistake') return !!f.mistake;
          if(sev==='blunder') return !!f.blunder;
          return true;
        }catch{ return true; }
      }
      window.includeSeverity = includeSeverity;

      // Modal DOM
      const modal = document.createElement('div');
      modal.id = 'anSettingsModal';
      modal.style.display = 'none';
      modal.innerHTML = `
        <div id="anSettingsBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:50"></div>
        <div style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:51">
          <div class="card" style="width:min(560px, 95vw); max-height:90vh; overflow:auto">
            <div style="display:flex;align-items:center;gap:10px;justify-content:space-between">
              <h2>Analysis Settings</h2>
              <button id="anSettingsClose" class="ghost" title="Close">?</button>
            </div>
            <div class="row" style="margin-top:8px; gap:12px; align-items:flex-end">
              <div style="min-width:180px">
                <label>Mode</label>
                <select id="anMode">
                  <option value="double">Two-layer (fast + deep)</option>
                  <option value="single">Single layer</option>
                </select>
              </div>
              <div style="min-width:200px">
                <label>Classifier</label>
                <select id="anClassifier">
                  <option value="cp">Centipawn loss</option>
                  <option value="wp">Win probability drop</option>
                </select>
              </div>
              <div id="anDepthFastWrap" style="max-width:120px">
                <label>L1 depth</label>
                <input id="anDepthFast" type="number" min="6" max="40" value="12" />
              </div>
              <div id="anDepthL2Wrap" style="max-width:120px">
                <label id="anDepthL2Label">L2 depth</label>
                <input id="anDepth" type="number" min="6" max="40" value="12" />
              </div>
              <div class="stroke" style="flex:1">
                <div class="small"><b id="sevPanelTitle">Classify by centipawn loss</b></div>
                <div class="grid-2" style="margin-top:6px; gap:10px">
                  <div>
                    <label>Inaccuracy =</label>
                    <input id="sevInacc" type="number" min="0" step="1" value="50" />
                  </div>
                  <div>
                    <label>Mistake =</label>
                    <input id="sevMistake" type="number" min="0" step="1" value="150" />
                  </div>
                  <div>
                    <label>Blunder =</label>
                    <input id="sevBlunder" type="number" min="0" step="1" value="300" />
                  </div>
                </div>
              </div>
            </div>
            <div id="infoMovesWrap" style="display:grid; grid-template-columns: 1fr 220px; gap:10px; align-items:stretch; margin-top:10px">
              <div id="infoCol">
                <div class="stroke">
              <div class="small"><b>Include severities</b></div>
              <div class="row" style="margin-top:6px">
                <label style="display:flex;align-items:center;gap:6px"><input id="incInacc" type="checkbox" checked /> Inaccuracies</label>
                <label style="display:flex;align-items:center;gap:6px"><input id="incMistake" type="checkbox" checked /> Mistakes</label>
                <label style="display:flex;align-items:center;gap:6px"><input id="incBlunder" type="checkbox" checked /> Blunders</label>
              </div>
            </div>
            <div class="row" style="margin-top:12px; justify-content:flex-end">
              <button id="anSettingsReset" class="ghost">Reset</button>
              <button id="anSettingsSave" class="secondary">Save</button>
            </div>
          </div>
        </div>`;
      document.body.appendChild(modal);

      function applyModeVisuals(mode){
        try{
          const fastWrap=document.getElementById('anDepthFastWrap');
          const l2Lbl=document.getElementById('anDepthL2Label');
          if(fastWrap && l2Lbl){
            if(mode==='single'){
              fastWrap.style.display='none';
              l2Lbl.textContent='Depth';
            }else{
              fastWrap.style.display='block';
              l2Lbl.textContent='L2 depth';
            }
          }
        }catch{}
      }
      function fillFromPrefs(){
        try{
          const depth = loadDepth();
          const fast = loadFastDepth();
          const mode = loadMode();
          const cls = loadClassifier();
          const t = cls==='wp' ? loadSevWp() : loadSev();
          const f = loadFlags();
          const modeEl=document.getElementById('anMode'); if(modeEl) modeEl.value = mode;
          const clsEl=document.getElementById('anClassifier'); if(clsEl) clsEl.value = cls;
          const dEl=document.getElementById('anDepth'); if(dEl) dEl.value=String(depth);
          const dfEl=document.getElementById('anDepthFast'); if(dfEl) dfEl.value=String(fast);
          applyModeVisuals(mode);
          try{ const cloud=document.getElementById('anSettingsCloud'); if(cloud) cloud.style.display='none'; }catch{}
          const si=document.getElementById('sevInacc'); if(si) si.value=String(t.inacc);
          const sm=document.getElementById('sevMistake'); if(sm) sm.value=String(t.mistake);
          const sb=document.getElementById('sevBlunder'); if(sb) sb.value=String(t.blunder);
          try{
            const lbl=document.getElementById('sevPanelTitle');
            if(lbl) lbl.textContent = (cls==='wp' ? 'Classify by win probability drop' : 'Classify by centipawn loss');
            const all=[si,sm,sb].filter(Boolean);
            all.forEach(inp=>{ if(cls==='wp'){ inp.min='0'; inp.max='100'; inp.step='1'; } else { inp.min='0'; inp.removeAttribute('max'); inp.step='1'; } });
          }catch{}
          const ci=document.getElementById('incInacc'); if(ci) ci.checked=!!f.inacc;
          const cm=document.getElementById('incMistake'); if(cm) cm.checked=!!f.mistake;
          const cb=document.getElementById('incBlunder'); if(cb) cb.checked=!!f.blunder;
        }catch{}
      }
      let prefsListener=null;
      function updateCloudStatus(){ /* Cloud UI removed */ }
      function open(){
        fillFromPrefs();
        // No cloud UI in this modal
        modal.style.display = 'block';
        try{ document.getElementById('anMode')?.addEventListener('change', ()=>{
          const sel = document.getElementById('anMode');
          const val = sel && (sel.value==='single' ? 'single' : 'double');
          applyModeVisuals(val||'double');
        }); }catch{}
        try{ document.getElementById('anClassifier')?.addEventListener('change', ()=>{
          const sel = document.getElementById('anClassifier');
          const val = (sel && sel.value==='wp') ? 'wp' : 'cp';
          const t = (val==='wp') ? loadSevWp() : loadSev();
          const si=document.getElementById('sevInacc'); const sm=document.getElementById('sevMistake'); const sb=document.getElementById('sevBlunder');
          if(si) si.value=String(t.inacc);
          if(sm) sm.value=String(t.mistake);
          if(sb) sb.value=String(t.blunder);
          const lbl=document.getElementById('sevPanelTitle'); if(lbl) lbl.textContent = (val==='wp') ? 'Classify by win probability drop' : 'Classify by centipawn loss';
          [si,sm,sb].forEach(inp=>{ if(!inp) return; if(val==='wp'){ inp.min='0'; inp.max='100'; inp.step='1'; } else { inp.min='0'; inp.removeAttribute('max'); inp.step='1'; } });
        }); }catch{}
      }
      function close(){
        modal.style.display = 'none';
        try{ if(prefsListener){ window.removeEventListener('firebase:prefsUpdated', prefsListener); prefsListener=null; } }catch{}
      }
      function reset(){ try{ localStorage.removeItem(LS_DEPTH); localStorage.removeItem(LS_FAST); localStorage.removeItem(LS_MODE); localStorage.removeItem(LS_FLAGS); localStorage.removeItem(LS_SEV); localStorage.removeItem(LS_SEV_WP); localStorage.removeItem(LS_CLASS); }catch{} open(); }
      function save(){
        const modeSel = document.getElementById('anMode');
        const mode = (modeSel && modeSel.value==='single') ? 'single' : 'double';
        saveMode(mode);
        const depth = parseInt(document.getElementById('anDepth').value,10)||12; saveDepth(depth);
        const dFastEl = document.getElementById('anDepthFast');
        const depthFast = dFastEl ? (parseInt(dFastEl.value,10)||12) : 12; saveFastDepth(depthFast);
        const clsSel = document.getElementById('anClassifier');
        const cls = (clsSel && clsSel.value==='wp') ? 'wp' : 'cp';
        saveClassifier(cls);
        const t = { inacc: parseInt(document.getElementById('sevInacc').value,10)|| (cls==='wp'?10:50),
                    mistake: parseInt(document.getElementById('sevMistake').value,10)|| (cls==='wp'?20:150),
                    blunder: parseInt(document.getElementById('sevBlunder').value,10)|| (cls==='wp'?30:300) };
        if(cls==='wp') saveSevWp(t); else saveSev(t);
        const f = { inacc: !!document.getElementById('incInacc').checked,
                    mistake: !!document.getElementById('incMistake').checked,
                    blunder: !!document.getElementById('incBlunder').checked };
        saveFlags(f);
        // Persist to unified prefs in Firestore as well (only if signed in)
        try{
          const payload = { analysisMode: mode, analysisDepth: depth, analysisFastDepth: depthFast, analysisThresholds: (cls==='wp'? undefined : t), analysisInclude: f };
          if(window.savePrefsLocal) window.savePrefsLocal(payload);
          if(window.firebaseAPI && window.firebaseAPI.ready && window.firebaseAPI.savePrefs){ window.firebaseAPI.savePrefs(payload).catch(()=>{}); }
        }catch{}
        close();
      }
      document.getElementById('btnAnalyzeSettings')?.addEventListener('click', open);
      document.getElementById('anSettingsBackdrop')?.addEventListener('click', close);
      document.getElementById('anSettingsClose')?.addEventListener('click', close);
      document.getElementById('anSettingsReset')?.addEventListener('click', reset);
      document.getElementById('anSettingsSave')?.addEventListener('click', save);

      // Expose helpers used below
      window.getAnalysisDepth = loadDepth;
      window.getFastDepth = loadFastDepth;
      window.getAnalysisMode = loadMode;
    })();

    // PGN Import modal (paste or load .pgn/.txt)
    (function(){
      function buildModal(){
        const modal=document.createElement('div');
        modal.id='pgnImportModal';
        modal.style.display='none';
        modal.innerHTML = `
          <div id="pgnBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:70"></div>
          <div style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:71">
            <div class="card" style="width:min(720px,95vw); max-height:90vh; overflow:auto">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
                <h2>Import PGN</h2>
                <button id="pgnClose" class="ghost" title="Close">�</button>
              </div>
              <div class="tiny muted" style="margin:6px 0 10px 0">Paste one or more complete PGN games below, or load a .pgn file. Multiple games supported.</div>
              <textarea id="pgnText" rows="14" style="width:100%; font-family:ui-monospace, SFMono-Regular, Menlo, Consolas, 'Liberation Mono', monospace"></textarea>
              <input type="file" id="pgnFile" accept=".pgn,.PGN,.txt" multiple style="display:none" />
              <div class="row" style="margin-top:10px; justify-content:space-between; align-items:center">
                <div class="tiny muted">Tip: Each game should include header tags like [Event "�"].</div>
                <div>
                  <button id="pgnLoadBtn" class="ghost" style="margin-right:8px">Load file�</button>
                  <button id="pgnCancel" class="ghost">Cancel</button>
                  <button id="pgnImport" class="secondary">Import</button>
                </div>
              </div>
            </div>
          </div>`;
        document.body.appendChild(modal);
        return modal;
      }
      let modalEl=null;
      function ensure(){ if(!modalEl) modalEl=buildModal(); return modalEl; }
      function open(){ const m=ensure(); m.style.display='block'; }
      function close(){ try{ ensure().style.display='none'; }catch{} }

      function splitPgns(text){
        try{
          const s=String(text||'').replace(/\r/g,'').trim();
          if(!s) return [];
          const out=[]; const re=/(\s*\[[^\]]+\]\s*)+([\s\S]*?)(?=(\s*\[[^\]]+\]\s*)+|$)/g;
          let m; while((m=re.exec(s))){ const block=(m[0]||'').trim(); if(block) out.push(block); }
          if(!out.length) return [s];
          return out;
        }catch{ return []; }
      }

      function wire(){
        ensure();
        const $g=id=>document.getElementById(id);
        $g('pgnBackdrop')?.addEventListener('click', close);
        $g('pgnClose')?.addEventListener('click', close);
        $g('pgnCancel')?.addEventListener('click', close);
        $g('pgnLoadBtn')?.addEventListener('click', ()=>{ $g('pgnFile')?.click(); });
        $g('pgnFile')?.addEventListener('change', async (ev)=>{
          try{
            const files=Array.from(ev.target.files||[]);
            if(!files.length) return;
            const texts=await Promise.all(files.map(f=>f.text().catch(()=>'')));
            const cur=$g('pgnText').value||'';
            const add=texts.filter(Boolean).join('\n\n');
            $g('pgnText').value = (cur? (cur.replace(/\s+$/,'')+'\n\n') : '') + add;
          }catch{}
        });
        $g('pgnImport')?.addEventListener('click', ()=>{
          try{
            const raw=$g('pgnText')?.value||'';
            const games=splitPgns(raw).filter(g=>/\[Event\s+\"/.test(g)||/\[Site\s+\"/.test(g));
            if(!games.length){ try{ setStatus('No PGN games found to import.'); }catch{} close(); return; }
            appendImportedGames(games, 'Imported');
            try{ setStatus(`Imported ${games.length} game${games.length!==1?'s':''}.`); }catch{}
          }catch(e){ try{ setStatus('Import failed: '+(e?.message||e)); }catch{} }
          close();
        });
      }
      document.getElementById('btnOpenPGN')?.addEventListener('click', ()=>{ open(); wire(); });
    })();

    // Add-to-existing-set modal
    (function(){
      const LS_SETS = 'pmtt_sets';
      const loadSetsLocal = () => { try{ return JSON.parse(localStorage.getItem(LS_SETS)||'[]'); }catch{return [];} };
      const saveSetsLocal = (arr) => {
        try{
          // Normalize: ensure snapshot items exist and have severity
          const norm = (arr||[]).map(s=>{
            const out = {...s};
            if(!Array.isArray(out.items)) out.items = [];
            // Backfill severity on items
            for(let i=0;i<out.items.length;i++){
              const it = out.items[i] || {};
              if(typeof it.severity === 'undefined' || it.severity === null){
                try{ it.severity = severityFromDrop(it.deltaCp); }catch{ it.severity = null; }
              }
            }
            out.version = 2;
            return out;
          });
          localStorage.setItem(LS_SETS, JSON.stringify(norm));
          try{ window.firebaseAPI && window.firebaseAPI.saveAllSets && window.firebaseAPI.saveAllSets(norm).catch(()=>{}); }catch{}
        }catch{}
        try{ renderSets && renderSets(); renderSetsForTrain && renderSetsForTrain(); renderTrainSelectList && renderTrainSelectList(); }catch{}
      };
      const keyOf = (m) => ((m&&m.fen)||'' ) + '|' + ((m&&m.played)||'');

      // Modal DOM
      const modal = document.createElement('div');
      modal.id = 'addToSetModal';
      modal.style.display = 'none';
      modal.innerHTML = `
        <div id="atsBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:50"></div>
        <div style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:51">
          <div class="card" style="width:min(620px,95vw); max-height:90vh; overflow:auto">
            <div style="display:flex;align-items:center;gap:10px;justify-content:space-between">
              <h2>Add to existing set</h2>
              <button id="atsClose" class="ghost" title="Close">?</button>
            </div>
            <div id="atsInfo" class="tiny muted" style="margin-top:6px">-</div>
            <div style="max-height:50vh;overflow:auto;border:1px dashed var(--border);border-radius:10px;margin-top:8px">
              <table style="width:100%">
                <thead><tr><th>Name</th><th>Count</th><th>Add</th></tr></thead>
                <tbody id="atsTBody"></tbody>
              </table>
            </div>
            <div class="row" style="margin-top:10px; justify-content:flex-end">
              <button id="atsCancel" class="ghost">Cancel</button>
            </div>
          </div>
        </div>`;
      document.body.appendChild(modal);

      function close(){ modal.style.display='none'; }
      // Choose source mistakes: prefer LAST_ANALYZED; fallback to mistakes linked to current imports; else all mistakes
      function getAddCandidates(){
        try{
          const la = (window.LAST_ANALYZED && Array.isArray(window.LAST_ANALYZED.mistakes)) ? window.LAST_ANALYZED.mistakes : [];
          if(la.length) return la;
          const all = (typeof loadMistakes==='function') ? loadMistakes() : [];
          const imports = Array.isArray(window.importedGames) ? window.importedGames : [];
          const importPgns = new Set(imports.map(r=>r && r.pgn).filter(Boolean));
          const byImport = all.filter(m => m && m.pgn && importPgns.has(m.pgn));
          if(byImport.length) return byImport;
          return all;
        }catch{ return []; }
      }
      function open(){
        const cand = getAddCandidates();
        const n = cand.length;
        const info = document.getElementById('atsInfo');
        if(info){
          if(n){
            const laCount = (window.LAST_ANALYZED && Array.isArray(window.LAST_ANALYZED.mistakes)) ? window.LAST_ANALYZED.mistakes.length : 0;
            info.textContent = laCount ? `Last analysis: ${n} mistake(s) ready to add.` : `Using detected mistakes: ${n} item(s).`;
          } else {
            info.textContent = 'No mistakes available. Run Analyse mistakes first.';
          }
        }
        const tb = document.getElementById('atsTBody'); if(tb) tb.innerHTML='';
        const sets = loadSetsLocal();
        if(!sets.length){
          const tr=document.createElement('tr'); tr.innerHTML='<td colspan="3" class="tiny muted">No sets found. Create a set first.</td>'; tb && tb.appendChild(tr);
        } else {
          const newKeys = new Set(cand.map(keyOf));
          for(const s of sets){
            const existing = new Set((s.keys||[]));
            let addCount=0; for(const k of newKeys){ if(!existing.has(k)) addCount++; }
            const tr=document.createElement('tr');
            tr.innerHTML = `<td>${s.name}</td><td>${(s.keys||[]).length}</td><td><button class="ghost" data-setid="${s.id}" ${(!n||addCount===0)?'disabled':''}>Add to set${addCount?` (+${addCount})`:''}</button></td>`;
            tr.querySelector('button')?.addEventListener('click', ()=>{
              const sets2 = loadSetsLocal();
              const idx = sets2.findIndex(x=>x.id===s.id);
              if(idx<0) return;
              const setObj = sets2[idx] || {};
              const ex = new Set((setObj.keys||[]));
              let added=0; for(const k of newKeys){ if(!ex.has(k)){ ex.add(k); added++; } }
              setObj.keys = Array.from(ex);
              // Ensure snapshot items include new keys with severity
              if(!Array.isArray(setObj.items)) setObj.items = [];
              const itemKeys = new Set(setObj.items.map(keyOf));
              const finalKeys = new Set(setObj.keys||[]);
              // Prefer current candidates, fallback to all mistakes
              const pool = Array.isArray(cand) && cand.length ? cand : (typeof loadMistakes==='function' ? loadMistakes() : []);
              const byKey = new Map();
              try{ for(const m of pool){ byKey.set(keyOf(m), m); } }catch{}
              for(const k of finalKeys){
                if(!itemKeys.has(k)){
                  let m = byKey.get(k);
                  if(!m && typeof loadMistakes==='function'){
                    try{ m = loadMistakes().find(x=>keyOf(x)===k); }catch{}
                  }
                  if(m){ setObj.items.push(snapshotMistake(m)); itemKeys.add(k); }
                }
              }
              setObj.version = 2;
              sets2[idx] = setObj;
              saveSetsLocal(sets2);
              setStatus(`Added ${added} item(s) to set "${sets2[idx].name}".`);
              try{ const el=document.getElementById('createSetInfo'); if(el) el.textContent = `Added ${added} item(s) to "${sets2[idx].name}"`; }catch{}
              close();
            });
            tb && tb.appendChild(tr);
          }
        }
        modal.style.display='block';
      }

      document.getElementById('btnAddToExistingSet')?.addEventListener('click', open);
      document.getElementById('atsBackdrop')?.addEventListener('click', close);
      document.getElementById('atsClose')?.addEventListener('click', close);
      document.getElementById('atsCancel')?.addEventListener('click', close);
    })();
    // Simple SPA nav
    function showSection(which){
      const map = { home:'homeSection', analyze:'analyzeSection', stats:'statsSection', sets:'setsSection', train:'trainSection' };
      Object.values(map).forEach(id => document.getElementById(id)?.classList.remove('active'));
      document.getElementById(map[which]||'homeSection')?.classList.add('active');
      document.getElementById('navHome')?.classList.toggle('active', which==='home');
      document.getElementById('navAnalyze')?.classList.toggle('active', which==='analyze');
      document.getElementById('navStats')?.classList.toggle('active', which==='stats');
      document.getElementById('navSets')?.classList.toggle('active', which==='sets');
      document.getElementById('navTrain')?.classList.toggle('active', which==='train');
      if(which==='train' || which==='stats'){
        setTimeout(()=>{
          try{ ensureMainBoard(); CB.main && CB.main.resize(); if(BOARD.current) CB.main.position(BOARD.current, false); else CB.main.clear(true); }catch{}
          try{ Object.values(CB.extras||{}).forEach(b=>{ try{ b && b.resize && b.resize(); }catch{} }); }catch{}
          setBoardFonts();
          renderArrows();
        }, 50);
      }
    }
    document.getElementById('navHome')?.addEventListener('click', (e)=>{ e.preventDefault(); showSection('home'); });
    document.getElementById('brandHome')?.addEventListener('click', (e)=>{ e.preventDefault(); showSection('home'); });
    document.getElementById('navAnalyze')?.addEventListener('click', (e)=>{ e.preventDefault(); showSection('analyze'); });
    document.getElementById('navStats')?.addEventListener('click', (e)=>{ e.preventDefault(); renderStatsSetOptions(); renderStatsMistakeList(); renderStatsSummary(); showSection('stats'); try{ const lbl=document.querySelector('#statsDelta')?.parentElement?.querySelector('b'); if(lbl) lbl.textContent='loss (cp | wp):'; }catch{} });
    // Re-render stats when cloud data arrives
    try{
      window.addEventListener('firebase:mMistakesUpdated', ()=>{ try{ renderStatsSetOptions(); renderStatsMistakeList(); renderStatsSummary(); backfillWinProbForLegacyMistakes(20, 8); }catch{} });
      window.addEventListener('firebase:setsUpdated', ()=>{ try{ renderStatsSetOptions(); renderStatsMistakeList(); renderStatsSummary(); }catch{} });
    }catch{}
    document.getElementById('navSets')?.addEventListener('click', (e)=>{ e.preventDefault(); renderSets(); showSection('sets'); });
    document.getElementById('navTrain')?.addEventListener('click', (e)=>{
      e.preventDefault();
      showSection('train');
      showTrainSelectionMode();
      renderTrainSelectList();
    });
    document.getElementById('btnGoAnalyze')?.addEventListener('click', ()=> showSection('analyze'));

    // Global keyboard navigation for viewers (left/right arrows)
    (function(){
      function clickFirstEnabled(ids){
        for(const id of ids){
          try{
            const btn = document.getElementById(id);
            if(btn && btn.offsetParent !== null){
              if(!(btn.hasAttribute && btn.hasAttribute('disabled'))){
                // click works for buttons and generic elements
                btn.click();
                return true;
              }
            }
          }catch{}
        }
        return false;
      }
      document.addEventListener('keydown', (ev)=>{
        try{
          const t = ev.target || null;
          const tag = (t && t.tagName ? String(t.tagName).toLowerCase() : '');
          if(tag==='input' || tag==='textarea' || tag==='select' || (t && t.isContentEditable)) return;
          if(ev.metaKey || ev.ctrlKey || ev.altKey) return;
          const anyViewer = !!(document.getElementById('tvControls') || document.getElementById('gvPrev') || document.getElementById('gvNext'));
          let handled=false;
          if(ev.key==='ArrowLeft') handled = clickFirstEnabled(['tvPrev','gvPrev']);
          else if(ev.key==='ArrowRight') handled = clickFirstEnabled(['tvNext','gvNext']);
          else if(ev.key==='ArrowUp') { if(anyViewer){ ev.preventDefault(); ev.stopPropagation(); } handled = clickFirstEnabled(['tvStart','gvStart']); }
          else if(ev.key==='ArrowDown') { if(anyViewer){ ev.preventDefault(); ev.stopPropagation(); } handled = clickFirstEnabled(['tvEnd','gvEnd']); }
          if(handled){ ev.preventDefault(); ev.stopPropagation(); }
        }catch{}
      });
      // Snap board to grid on window resize to avoid leftover background
      try{ window.addEventListener('resize', ()=>{ snapMainBoardToGrid(); }); }catch{}
    })();

    // Sets page actions (create empty set, de-duped by name+content)
    document.getElementById('btnCreateEmptySet')?.addEventListener('click', ()=>{
      const el=document.getElementById('newSetName');
      const name=(el && el.value ? el.value.trim() : '') || `Set ${new Date().toLocaleString()}`;
      createSetFromMistakes([], name); renderSets();
    });
    // Initialize sort UI for sets list
    try{ initSetsSortUI(); }catch{}
    // Kick off a small backfill batch so WP shows for legacy data
    try{ backfillWinProbForLegacyMistakes(20, 8); }catch{}
  </script>
</body>
</html>





























      
