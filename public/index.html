<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Personal Chess Mistake Trainer</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script>
    // Replace mojibake em/en dash sequences that can appear as "â€”" / "â€“"
    (function(){
      function sanitizeNodeText(root){
        try{
          var walker = document.createTreeWalker(root || document.body, NodeFilter.SHOW_TEXT);
          var node;
          while((node = walker.nextNode())){
            var t = node.nodeValue;
            if(!t) continue;
            var nt = t.replace(/â€”/g, '-').replace(/â€“/g, '-');
            if(nt !== t) node.nodeValue = nt;
          }
        }catch{}
      }
      document.addEventListener('DOMContentLoaded', function(){
        sanitizeNodeText(document.body);
        try{
          var mo = new MutationObserver(function(muts){
            for(var i=0;i<muts.length;i++){
              var m = muts[i];
              if(m.type==='childList'){
                m.addedNodes && m.addedNodes.forEach && m.addedNodes.forEach(function(n){
                  if(n && n.nodeType===1) sanitizeNodeText(n);
                  else if(n && n.nodeType===3) sanitizeNodeText(n.parentNode||document.body);
                });
              } else if(m.type==='characterData'){
                sanitizeNodeText(m.target.parentNode||document.body);
              }
            }
          });
          mo.observe(document.body, { childList:true, subtree:true, characterData:true });
        }catch{}
      });
    })();
    try{ window.EngineLive = EngineLive; }catch{}
  </script>
  <!--
    Personal Chess Mistake Trainer (single-file app)

    ? Single HTML file: all HTML, CSS, and JS are inline (one file only).
    ? Works offline once loaded (except for fetching online games).
    ? No frameworks used.

    This build addresses your latest requests:
      â€¢ Board-size slider works even in fullscreen (width uses min(100%, var(--board-size))).
      â€¢ Black pieces are truly black; forced non-emoji (solid) glyphs.
      â€¢ Added "Show mistake" button; shows red arrow for the played mistake; clears on Reveal Best or on move.
      â€¢ Dragging shows legal-move dots; removed dotted/focus square when dragging/lifting.
      â€¢ Imports stack across sources (Lichess + Chess.com + Manual) and analyse runs over the full stack.
      â€¢ Stop analysis immediately resets the button; partial results still saved and a set is created if >0 mistakes.

    MIT-style: extend/adapt freely.
  -->
  <style>
    :root{
      /* Layout */
      --bg:#0f1115;
      --panel:#171a21;
      --card:#1b1f27;
      --text:#e6edf3;
      --muted:#9aa4b2;
      --acc:#4f8cff;
      --good:#2ecc71;
      --bad:#ff5c5c;
      --warn:#f1c40f;

      /* Board look */
      --sq-light:#f0d9b5;
      --sq-dark:#b58863;
      --sq-hl:#ffd54f;
      --sq-sel:#7bdff6;
      --arrow-user:#ff5c5c; /* red */
      --arrow-best:#2ecc71; /* green */

      /* Train sizing */
      --board-size: 520px; /* main board target width */
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      background:var(--bg);
      color:var(--text);
      font:14px/1.45 system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, "Apple Color Emoji","Segoe UI Emoji";
    }
    h1,h2,h3{margin:0 0 .5rem}
    a{color:var(--acc);text-decoration:none}
    .wrap{max-width:1100px;margin:0 auto;padding:18px}

    .grid{
      display:grid;
      grid-template-columns: 1.1fr .9fr;
      gap:18px;
    }

    /* Train page grid (fixed split; pane-split slider removed) */
    .train-grid{
      display:grid;
      grid-template-columns: 1.15fr .85fr;
      gap:18px;
    }

    /* Training view layout: hide sets pane; keep board left + info right */
    #trainSection.training-mode .train-grid{ grid-template-columns:1fr; }
    #trainSection.training-mode .train-grid > .card:nth-of-type(2){ display:none; }
    /* Hide the top select-a-set panel while training */
    #trainSection.training-mode #trainSelectView{ display:none; }
    /* Show only selection view when not training */
    #trainSection:not(.training-mode) .train-grid{ display:none; }
    .train-center{ display:flex; flex-direction:column; align-items:center; gap:12px }
    .train-block{ width:min(100%, var(--board-size)); margin:0 auto }

    /* Hide training legend badges */
    #trainSection .legend.tiny{ display:none !important; }

    /* Toggle switch for engine */
    .switch{ position:relative; display:inline-block; width:44px; height:24px; vertical-align:middle }
    .switch input{ opacity:0; width:0; height:0 }
    .slider{ position:absolute; cursor:pointer; inset:0; background:#3a445a; transition:.2s; border-radius:24px }
    .slider:before{ content:""; position:absolute; height:18px; width:18px; left:3px; bottom:3px; background:#fff; transition:.2s; border-radius:50% }
    .switch input:checked + .slider{ background:var(--acc) }
    .switch input:checked + .slider:before{ transform:translateX(20px) }

    /* Compact toggle specifically for Engine panel */
    #enginePanel .switch{ width:32px; height:20px }
    #enginePanel .slider:before{ width:14px; height:14px; left:3px; bottom:3px }
    /* When ON, knob travels flush to the right edge */
    #enginePanel .switch input:checked + .slider:before{ transform:translateX(15px) }

    /* Engine arrow color (cyan-ish) */
    :root{ --arrow-engine:#00bcd4 }

    @media (max-width:1000px){
      .grid, .train-grid{grid-template-columns:1fr}
    }

    .card{
      background:var(--panel);
      border:1px solid #232836;
      border-radius:12px;
      padding:14px;
      box-shadow:0 8px 24px rgba(0,0,0,.25), inset 0 1px 0 rgba(255,255,255,.02);
    }
    .row{display:flex;gap:12px;flex-wrap:wrap;align-items:center}
    .row > *{flex:1}
    label{display:block;margin:.25rem 0 .35rem;color:var(--muted);font-size:.85rem}
    input[type="text"], textarea, select, input[type="number"], input[type="range"]{
      width:100%;background:#11141a;border:1px solid #2a3142;color:var(--text);
      border-radius:10px;padding:10px 12px;font-size:14px;outline:none;
    }
    input[type="range"]{padding:6px 8px}
    textarea{min-height:120px;resize:vertical}
    /* Input with prefix (e.g., 'chess.com/' inside the field) */
    .input-prefix{display:flex;align-items:center;background:#11141a;border:1px solid #2a3142;color:var(--text);border-radius:10px}
    .input-prefix .prefix{padding:10px 10px;color:var(--muted);border-right:1px solid #2a3142;white-space:nowrap}
    .input-prefix input{flex:1;background:transparent;border:0;color:var(--text);padding:10px 12px;outline:none}

    button{
      appearance:none;border:0;background:var(--acc);color:white;
      padding:10px 14px;border-radius:10px;font-weight:600;cursor:pointer;
      box-shadow:0 6px 18px rgba(79,140,255,.35)
    }
    button.secondary{background:#30374a;box-shadow:none}
    button.ghost{background:transparent;border:1px solid #2a3142;color:var(--text)}
    .btn-green{background:var(--good)}
    .btn-red{background:var(--bad)}
    .muted{color:var(--muted)}
    .mono{font-family: ui-monospace, SFMono-Regular, Menlo, Consolas, "Liberation Mono", monospace}
    .small{font-size:.9rem}
    .tiny{font-size:.8rem}
    .success{color:var(--good)}
    .danger{color:var(--bad)}
    .warn{color:var(--warn)}
    .right{float:right}

    /* Board containers */
    .board-wrap{display:flex;gap:14px;align-items:flex-start}
    .board{
      /* board width controlled via --board-size; stays square */
      width: min(100%, var(--board-size));
      aspect-ratio:1 / 1; /* always square */
      background:#ddd;border-radius:12px;overflow:hidden;border:1px solid #c7cdd8;position:relative
    }
    /* Evaluation bar (left of main board) */
    .eval-bar{ width:14px; border-radius:10px; overflow:hidden; border:1px solid #2a3142; background:#0a0a0a; flex:0 0 14px; display:none; position:relative }
    .eval-bar .eval-fill{ position:absolute; left:0; right:0; bottom:0; height:50%; background:#f5f5f5 }
    .eval-bar .tick{ position:absolute; left:0; right:0; top:50%; height:1px; background:#2a3142; opacity:.6 }
    /* Cursor hint when hovering near corner */
    .board.resize-corner-hover{ cursor:nwse-resize; }
    /* Drag handle for resizing the main board */
    .resize-handle{
      position:absolute; right:8px; bottom:8px;
      width:18px; height:18px; border-radius:4px;
      background:
        linear-gradient(135deg, rgba(255,255,255,.9) 2px, transparent 2px) no-repeat,
        linear-gradient(135deg, rgba(255,255,255,.6) 2px, transparent 2px) no-repeat,
        linear-gradient(135deg, rgba(255,255,255,.35) 2px, transparent 2px) no-repeat;
      background-size: 100% 100%, 12px 12px, 8px 8px;
      background-position: right bottom, right 2px bottom 2px, right 6px bottom 6px;
      border:1px solid #2a3142; cursor: nwse-resize; z-index:6; opacity:.9;
      box-shadow:0 2px 8px rgba(0,0,0,.25);
    }
    /* Game Viewer mini board: fills available width responsively (no cramping) */
    .board-mini{
      width:100%;
      max-width:540px;
      aspect-ratio:1 / 1;
      background:#ddd;border-radius:12px;overflow:hidden;border:1px solid #c7cdd8;position:relative
    }

    /* Ensure chessboard.js containers fill their wrappers */
    #board, #gvBoard, #statsBoard{ width:100%; height:100%; }
    /* Legacy custom grid (no longer used for main rendering) */
    .grid8{ display:grid; grid-template-columns:repeat(8, minmax(0,1fr)); grid-template-rows:repeat(8, minmax(0,1fr)); width:100%; height:100%; contain: content; }
    .sq{
      display:flex;align-items:center;justify-content:center;
      user-select:none;position:relative;transition:background .08s ease;
      overflow:hidden; /* if glyph gets large, don't distort grid */
      font-size:var(--cell-font, 36px); /* set by JS per board size */
    }
    .sq.light{background:var(--sq-light)}
    .sq.dark{background:var(--sq-dark)}
    /* coords removed */
    .sq.hint::after{
      content:"";position:absolute;width:26%;height:26%;border-radius:50%;
      background:rgba(0,0,0,.25)
    }
    .sq.sel{outline:3px solid var(--sq-sel);z-index:2}
    .sq.hl{outline:3px solid var(--sq-hl)}

    /* Crisp readable pieces â€” force monochrome (non-emoji) solid glyphs */
    .piece{
      filter:drop-shadow(0 2px 2px rgba(0,0,0,.25));
      opacity:1 !important; font-weight:900; letter-spacing:0;
      pointer-events:auto;
      /* Prefer symbol fonts, force text presentation to avoid color/emoji glyphs (purple pawns etc.) */
      font-family:"Noto Sans Symbols 2","DejaVu Sans","Segoe UI Symbol","Symbola","Noto Sans","Arial Unicode MS",system-ui,-apple-system,"Segoe UI",Roboto,Ubuntu,Cantarell,Arial;
      font-variant-emoji:text;
    }
    .piece.w{color:#ffffff;text-shadow:0 1px 0 #000, 0 0 4px rgba(0,0,0,.5)}
    .piece.b{color:#111111;text-shadow:0 1px 0 #ffffff, 0 0 3px rgba(255,255,255,.15)} /* true black */

    /* Remove dotted focus rectangles when dragging/lifting */
    .sq:focus, .piece:focus { outline: none; }
    .sq, .piece { -webkit-tap-highlight-color: transparent; }

    .legend{display:flex;gap:8px;flex-wrap:wrap}
    .legend span{padding:4px 8px;background:#0f1320;border-radius:999px;border:1px solid #2a3142}
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:10px}
    @media (max-width:800px){
      .board-wrap{flex-direction:column}
    }

    table{width:100%;border-collapse:collapse}
    th,td{padding:8px;border-bottom:1px dashed #2a3142;text-align:left;vertical-align:top}
    th{color:var(--muted);font-weight:600}
    tr:hover td{background:#121622}
    tr.selected td{background:#1a2233}

    .bar{height:140px;background:#121622;border-radius:10px;margin-top:8px;position:relative}
    .bar canvas{width:100%;height:100%}

    .pill{padding:2px 8px;border-radius:999px;font-weight:700;font-size:.75rem}
    .pill.inacc{background:#264f2f;color:#a2f5be;border:1px solid #2f9e44}
    .pill.mist{background:#5b4a27;color:#ffe8a1;border:1px solid #f2c94c}
    .pill.blun{background:#4f1e24;color:#ffb3bd;border:1px solid #ff6b6b}
    .stroke{border:1px dashed #2a3142;border-radius:10px;padding:10px}
  </style>
  <!-- chessboard.js CSS (local) -->
  <link rel="stylesheet" href="/chessboardjs/css/chessboard-1.0.0.min.css" />
  <style>
    .topnav{background:#11141a;border-bottom:1px solid #232836;position:sticky;top:0;z-index:5}
    .topnav .navwrap{max-width:1100px;margin:0 auto;display:flex;gap:12px;align-items:center;padding:10px 18px}
    .topnav a{color:#cbd5e1;padding:6px 10px;border-radius:8px}
    .topnav a.active{background:#1b2130;color:#fff}
    .section{display:none}
    .section.active{display:block}

    /* Last-move highlight for chessboard.js squares */
    #board [data-square].last-move,
    #gvBoard [data-square].last-move,
    #statsBoard [data-square].last-move{
      /* slightly transparent yellow to reduce intensity */
      background: rgba(255, 213, 79, 0.6) !important;
    }
    /* Prevent native browser drag on chessboard piece images */
    #board img, #gvBoard img, #statsBoard img {
      -webkit-user-drag: none; /* vendor-prefixed; JS handler also prevents native drag */
    }
  </style>
</head>
<body>
  <div class="topnav">
    <div class="navwrap">
      <div style="font-weight:700;color:#e6edf3">?? PMT</div>
      <a href="#" data-sec="home" id="navHome" class="active">Home</a>
      <a href="#" data-sec="analyze" id="navAnalyze">Import</a>
      <a href="#" data-sec="stats" id="navStats">Stats</a>
      <a href="#" data-sec="sets" id="navSets">Sets</a>
      <a href="#" data-sec="train" id="navTrain">Train</a>
      <div style="margin-left:auto"></div>
      <span id="authUserName" class="small" style="color:#cbd5e1;margin-right:8px;max-width:220px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;display:none"></span>
      <button id="btnAuth" class="ghost small" title="Sign in to sync">Sign in</button>
    </div>
  </div>

  <!-- Auth modal -->
  <div id="authModal" style="display:none">
    <div id="authBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:50"></div>
    <div class="card" style="position:fixed;left:50%;top:50%;transform:translate(-50%,-50%);width:min(92%,640px);z-index:51;padding:20px 22px 18px;border-radius:14px">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
        <div style="font-size:1.25rem;font-weight:700">Welcome back</div>
        <button id="authClose" class="ghost" style="padding:6px 10px">?</button>
      </div>
      <div class="muted" style="margin-bottom:12px">Sign in to sync your data across devices.</div>
      <div style="display:flex;flex-direction:column;gap:10px">
        <button id="btnGoogle" class="ghost" style="display:flex;gap:10px;align-items:center;justify-content:center;border:1px solid #2a3142;padding:10px;border-radius:10px">
          <img alt="" src="https://www.gstatic.com/firebasejs/ui/2.0.0/images/auth/google.svg" style="width:20px;height:20px"/>
          <span>Continue with Google</span>
        </button>
        <div class="muted" style="text-align:center">or</div>
        <input id="authEmail" type="email" placeholder="Email" autocomplete="email" />
        <input id="authPass" type="password" placeholder="Password" autocomplete="current-password" />
        <div class="row" style="gap:10px">
          <button id="btnEmailPrimary" style="flex:1">Sign in</button>
          <button id="btnReset" class="secondary" style="flex:1">Reset password</button>
        </div>
        <div id="authError" class="small" style="color:var(--bad);min-height:18px"></div>
        <div class="small" style="text-align:center">
          <a href="#" id="linkToggleMode">New here? Create an account</a>
        </div>
      </div>
    </div>
  </div>

  <!-- Home -->
  <div class="wrap section active" id="homeSection">
    <h1>Welcome to Personal Chess Mistake Trainer</h1>
    <p class="muted small">Import games from Lichess/Chess.com, extract mistakes with Stockfish, and train them using Woodpecker or SM-2 spaced repetition.</p>
    <div class="card" style="margin-top:12px">
      <h2>Get Started</h2>
      <ul>
        <li>Go to <b>Import</b> to fetch your recent games.</li>
        <li>Analyse mistakes to create a Set automatically.</li>
        <li>Open Sets to rename or start training a set.</li>
      </ul>
      <button id="btnGoAnalyze">Go to Import</button>
    </div>
  </div>

  <!-- Import -->
  <div class="wrap section" id="analyzeSection">
    <h1>Import games & prepare analysis</h1>
    <p class="muted small">Import games ? then press <b>Analyse mistakes</b> to run Stockfish (server) and extract mistakes. All data stays in your browser (plus Firestore sync).</p>

    <div class="grid" style="margin-top:14px">
      <!-- LEFT COLUMN -->
      <div class="card">
        <h2>1) Import Games</h2>
        <!-- Unified import controls -->
        <!-- Settings (visible) -->
        <div id="importSettingsBox" class="tiny" style="display:block; margin-top:8px">
          <div class="row" style="align-items:flex-end">
            <div>
              <label>Providers</label>
              <div class="row" style="gap:10px">
                <label class="tiny"><input type="checkbox" id="provLichess" checked> Lichess</label>
                <label class="tiny"><input type="checkbox" id="provChesscom" checked> Chess.com</label>
              </div>
            </div>
          </div>
          <div class="row">
            <div>
              <label>Mode</label>
              <div>
                <label class="tiny"><input type="radio" name="importMode" id="modeCount" checked> By most recent</label>
                <label class="tiny" style="margin-left:10px"><input type="radio" name="importMode" id="modeTime"> By period</label>
              </div>
            </div>
            <div id="countWrap2" style="max-width:140px">
              <label>Games</label>
              <input id="importCount2" type="number" min="1" max="100" value="10" />
            </div>
            <div id="periodWrap" style="display:none; max-width:320px">
              <label>Period</label>
              <div style="display:flex; gap:8px; align-items:center">
                <input id="periodValue" type="number" step="0.1" min="0" value="30" style="max-width:120px"/>
                <select id="periodUnit">
                  <option value="minutes">minutes</option>
                  <option value="hours">hours</option>
                  <option value="days" selected>days</option>
                  <option value="weeks">weeks</option>
                  <option value="months">months</option>
                </select>
              </div>
            </div>
          </div>
          <div class="row" style="margin-top:8px; flex-direction:column; align-items:stretch; gap:8px">
            <div>
              <label>Link Chess.com username</label>
              <div style="display:flex; gap:8px; align-items:center">
                <div class="input-prefix" style="flex:1">
                  <span class="prefix">chess.com/</span>
                  <input id="accChessCom" type="text" placeholder="username" />
                </div>
                <button id="btnLinkChessCom" class="ghost">Link</button>
              </div>
            </div>
            <div>
              <label>Link Lichess username</label>
              <div style="display:flex; gap:8px; align-items:center">
                <div class="input-prefix" style="flex:1">
                  <span class="prefix">lichess.org/</span>
                  <input id="accLichess" type="text" placeholder="username" />
                </div>
                <button id="btnLinkLichess" class="ghost">Link</button>
              </div>
            </div>
          </div>
          <div class="tiny muted">Usernames and preferences are saved to your account.</div>
          <div style="display:flex; justify-content:flex-end; margin-top:8px"><button id="btnOpenPGN" class="ghost" style="margin-right:8px">Import PGN</button><button id="btnImportUnified">Import</button></div>
        </div>
        <div id="legacyLichessRow" class="row" style="margin-top:6px; display:none">
          <div>
            <label>Lichess username</label>
            <input id="lichessUser" type="text" placeholder="e.g., lox123" />
          </div>
          <div style="max-width:120px">
            <label>Games</label>
            <input id="lichessCount" type="number" min="1" max="50" value="5" />
          </div>
          <div style="max-width:220px">
            <label>&nbsp;</label>
            <button id="btnFetchLichess">Fetch (Lichess)</button>
          </div>
        </div>
        <div id="legacyChesscomRow" class="row" style="display:none">
          <div>
            <label>Chess.com username</label>
            <input id="chesscomUser" type="text" placeholder="e.g., lox123" />
          </div>
          <div style="max-width:120px">
            <label>Games</label>
            <input id="chesscomCount" type="number" min="1" max="50" value="5" />
          </div>
          <div style="max-width:220px">
            <label>&nbsp;</label>
            <button id="btnFetchChesscom">Fetch (Chess.com)</button>
          </div>
        </div>
        <!-- PGN area removed: now uses popup --></div>

        <!-- Status panel removed; messages moved to Imported Games header -->

        <div class="stroke tiny" id="importedBox" style="margin-top:10px">
          <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
            <b>Imported Games</b>
            <span class="tiny muted" id="importHelp">Fetched games will appear here.</span>
            <span class="tiny mono" id="importMistakes" style="color:#cbd5e1">Mistakes: 0</span>
            <span style="margin-left:auto"></span>
            <button id="btnClearImports" class="ghost" title="Clear imported games & their mistakes">Clear imports</button>
            <button id="btnAnalyzeImported" class="btn-green" title="Analyse mistakes (server)">Analyse mistakes</button>
            <button id="btnAnalyzeSettings" class="ghost" title="Analysis settings" style="padding:4px 8px">⚙</button>
          </div>
          <div style="max-height:220px;overflow:auto;border:1px dashed #2a3142;border-radius:10px;margin-top:6px">
            <table id="importTable" style="width:100%">
              <thead>
                <tr>
                  <th>#</th>
                  <th>White</th>
                  <th>Black</th>
                  <th>Res</th>
                  <th>Date</th>
                  <th>Source</th>
                  <th>Analyse</th>
                </tr>
              </thead>
              <tbody id="importTBody"></tbody>
            </table>
          </div>$insertion<!-- Game Viewer with fully responsive board -->
          <!-- Create-set actions moved below the list (left-aligned) -->
          <div id="createSetRow" class="tiny" style="margin-top:8px; display:flex; align-items:center; gap:8px">
            <button id="btnCreateSetFromLast" class="secondary" title="Create a set from the last analysis results">Create set (0 mistakes)</button>
            <button id="btnAddToExistingSet" class="ghost" title="Add analyzed mistakes to an existing set">Add to existing set</button>
            <span id="createSetInfo" class="muted">-</span>
          </div>
          
          <!-- Game Viewer with fully responsive board -->
          <div id="gameViewer" class="stroke tiny" style="margin-top:10px; display:none">
            <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap">
              <b>Game Viewer</b>
              <span id="gvStatus" class="mono">-</span>
              <div style="margin-left:auto;display:flex;gap:6px">
                <button id="gvStart" class="ghost" title="Start">«</button>
                <button id="gvPrev" class="ghost" title="Prev">‹</button>
                <button id="gvNext" class="ghost" title="Next">›</button>
                <button id="gvEnd" class="ghost" title="End">»</button>
              </div>
            </div>
            <div class="board-mini" style="margin-top:8px">
              <div id="gvBoard" aria-label="game-viewer-board"></div>
            </div>
          </div>
        </div>

        <hr style="border:none;border-top:1px solid #242a39;margin:16px 0">
        <div class="stroke tiny" style="margin-top:8px">
          Trainer has moved to its own page. Use the <b>Train</b> tab in the top navigation to start a session.
        </div>
      </div>

      
    </div>
  </div>

  <!-- Sets Page -->
  <div class="wrap section" id="setsSection">
    <h1>Sets</h1>
    <div class="card" style="margin-top:10px">
      <div class="row" style="align-items:flex-end">
        <div>
          <label>New set name</label>
          <input id="newSetName" type="text" placeholder="e.g., Blitz mistakes Aug" />
        </div>
        <div style="max-width:220px">
          <label>&nbsp;</label>
          <button id="btnCreateEmptySet" class="ghost">Create empty set</button>
        </div>
      </div>
      <div style="margin-top:10px;max-height:360px;overflow:auto;border:1px dashed #2a3142;border-radius:10px">
        <table style="width:100%">
          <thead>
            <tr>
              <th>#</th><th>Name</th><th>Count</th><th>Created</th><th>Actions</th>
            </tr>
          </thead>
          <tbody id="setsTBody"></tbody>
        </table>
      </div>
    </div>
  </div>

  <!-- Stats Page -->
  <div class="wrap section" id="statsSection">
    <h1>Stats</h1>
    <div class="grid" style="margin-top:12px">
      <!-- LEFT: Mistake list filtered by set -->
      <div class="card">
        <h2>Mistake List</h2>
        <div class="row" style="align-items:flex-end;margin-top:6px">
          <div>
            <label>Set</label>
            <select id="statsSetSelect"></select>
          </div>
        </div>
        <div class="tiny muted" style="margin:6px 0 10px">Select a set to view its mistakes. Click a row to preview on the right.</div>
        <div style="max-height:360px;overflow:auto;border:1px dashed #2a3142;border-radius:10px">
          <table id="statsMistakeTable">
            <thead>
              <tr>
                <th>#</th>
                <th>Severity</th>
                <th>Side</th>
                <th>Played</th>
                <th>Best</th>
                <th>?cp</th>
                <th>Next review</th>
              </tr>
            </thead>
            <tbody id="statsMistakeTBody"></tbody>
          </table>
        </div>
      </div>

      <!-- RIGHT: Board + Summary -->
      <div class="card">
        <h2>Preview</h2>
        <div class="board-mini" style="margin-top:8px">
          <div id="statsBoard" aria-label="stats-board"></div>
        </div>
        <div class="stroke tiny" style="margin-top:10px">
          <div class="small"><b>Selected mistake</b></div>
          <div class="tiny mono" id="statsMInfo">-</div>
          <div class="tiny"><b>Side to move:</b> <span id="statsSideToMove">-</span></div>
          <div class="tiny"><b>Best:</b> <span id="statsBest">-</span></div>
          <div class="tiny"><b>?cp:</b> <span id="statsDelta">-</span></div>
        </div>

        <hr style="border:none;border-top:1px solid #242a39;margin:16px 0">
        <h2>Summary</h2>
        <div class="grid-2" style="margin-top:8px">
          <div class="stroke">
            <div class="small"><b>Accuracy:</b> <span id="statsAcc">-</span></div>
            <div class="small"><b>Reviews done:</b> <span id="statsReviews">0</span></div>
          </div>
          <div class="stroke">
            <div class="small"><b>Total mistakes:</b> <span id="statsTotal">0</span></div>
            <div class="small"><b>Due now (SRS):</b> <span id="statsDue">0</span></div>
          </div>
        </div>
        <div style="margin-top:10px">
          <div class="small"><b>Severity distribution</b></div>
          <div class="bar"><canvas id="statsSevChart" width="600" height="180"></canvas></div>
        </div>
      </div>
    </div>
  </div>

  <!-- Train Page -->
  <div class="wrap section" id="trainSection">
    <h1>Train</h1>

    <!-- View 1: Select a set to train -->
    <div id="trainSelectView" class="card" style="margin-top:12px">
      <h2>Select a set</h2>
      <div class="tiny muted" style="margin-top:6px">Click a set to start training. You can also press Train in Actions.</div>
      <div style="max-height:420px;overflow:auto;border:1px dashed #2a3142;border-radius:10px;margin-top:8px">
        <table style="width:100%">
          <thead>
            <tr><th>#</th><th>Name</th><th>Count</th><th>Actions</th></tr>
          </thead>
          <tbody id="trainSelectTBody"></tbody>
        </table>
      </div>
    </div>

    <div class="train-grid" style="margin-top:12px">
      <div class="card">
        <h2>Board</h2>
        <div class="board-wrap" style="margin-top:10px">
          <div id="evalBar" class="eval-bar" aria-hidden="true"><div class="eval-fill"></div><div class="tick"></div></div>
          <div class="board" id="trainBoard">
            <div id="board" aria-label="chessboard"></div>
            <div id="resizeHandle" class="resize-handle" title="Drag to resize"></div>
          </div>
          <div style="flex:1;min-width:260px">
            <div class="legend tiny">
              <span>Drag to move</span>
              <span>?? correct = best move</span>
              <span>? otherwise</span>
            </div>
            <div class="stroke" style="margin-top:10px">
              <div class="small"><b>Current Mistake</b></div>
              <div class="tiny muted" id="mInfo">â€”</div>
              <div class="tiny" style="margin-top:6px"><b>Goal:</b> find the best move from this position.</div>
              <div class="tiny"><b>Side to move:</b> <span id="sideToMove">â€”</span></div>
              <div class="tiny"><b>Your attempt:</b> <span id="yourMove">â€”</span></div>
              <div class="tiny"><b>Feedback:</b> <span id="feedback">â€”</span></div>
              <div class="row" style="margin-top:8px; gap:8px">
                <!-- NEW: Show mistake button (left of Reveal best) -->
                <button id="btnShowMistake" class="ghost">Show mistake</button>
                <button id="btnReveal" class="secondary">Reveal best</button>
                <button id="btnNext" class="ghost">Next</button>
                <button id="btnFlip" class="ghost">Flip board</button>
              </div>
            </div>
            <div class="stroke tiny" style="margin-top:10px">
              <div><b>Game Info</b></div>
              <div class="tiny mono" id="trainFen">FEN: -</div>
              <div class="tiny mono" id="trainPgn" style="word-break:break-word">PGN: -</div>
              <div class="tiny">Link: <a id="trainLink" href="#" target="_blank" rel="noopener">-</a></div>
            </div>
            <!-- Engine Analysis panel moved below Game Info -->
            <div class="stroke tiny" style="margin-top:10px" id="enginePanel">
              <div class="row" style="align-items:center; justify-content:space-between; gap:10px; width:100%">
                <div style="display:flex; align-items:center; gap:8px; flex:1; flex-wrap:wrap">
                  <b>Engine</b>
                  <span id="engineStateLive" class="tiny muted">off</span>
                  <span id="engineMeta" class="tiny mono muted">-</span>
                  <span id="enginePerf" class="tiny mono muted" title="nodes per second">0 kn/s</span>
                  <span id="engineDepth" class="tiny mono muted" title="depth">depth: -/-</span>
                </div>
                <div style="display:flex; align-items:center; gap:10px">
                  <button id="engineSettingsBtn" class="ghost" title="Engine settings" style="padding:2px 8px">⚙</button>
                  <label class="switch" title="Toggle engine analysis">
                    <input type="checkbox" id="engineToggle">
                    <span class="slider"></span>
                  </label>
                </div>
              </div>
              <div id="engineLines" class="mono" style="margin-top:6px; white-space:pre-wrap"></div>
            </div>
            <div class="row" style="margin-top:10px">
              <button id="btnExitTrain" class="ghost">Exit</button>
            </div>

          </div>
        </div>
      </div>
      <div class="card">
        <h2>Sets</h2>
        <div class="tiny muted">Click a set to activate then Start.</div>
        <div style="max-height:380px;overflow:auto;border:1px dashed #2a3142;border-radius:10px;margin-top:6px">
          <table style="width:100%">
            <thead>
              <tr><th>#</th><th>Name</th><th>Count</th></tr>
            </thead>
            <tbody id="trainSetsTBody"></tbody>
          </table>
        </div>
        <div class="row" style="margin-top:10px">
          <div class="grid-2">
            <div>
              <label>Mode</label>
              <select id="modeSel">
                <option value="woodpecker">Woodpecker</option>
                <option value="srs" selected>Spaced Repetition (SM-2)</option>
              </select>
            </div>
            <div id="wpCountWrap">
              <label>Woodpecker count (N)</label>
              <input id="wpCount" type="number" min="1" value="10" />
            </div>
          </div>
          <div style="max-width:220px">
            <label>&nbsp;</label>
            <button id="btnStart">Start session</button>
          </div>
        </div>
        <div class="tiny muted" id="activeSetInfo" style="margin-top:6px">Active set: â€”</div>
      </div>
    </div>
  </div>

  <!-- Firebase (App + Analytics) -->
  <script type="module">
    import { initializeApp } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-app.js';

    // Use the Firebase Hosting "firebaseapp.com" domain as authDomain to
    // match the Google provider's authorized redirect URIs and avoid
    // redirect_uri_mismatch. (web.app works too if added in console.)
    const AUTH_DOMAIN = 'chessmistaketrainer.firebaseapp.com';
    const firebaseConfig = {
      apiKey: "AIzaSyB_VkTkQXOgc4Q0jithJk9iwzRv2OLLIE0",
      authDomain: AUTH_DOMAIN,
      projectId: "chessmistaketrainer",
      storageBucket: "chessmistaketrainer.firebasestorage.app",
      messagingSenderId: "283045516917",
      appId: "1:283045516917:web:c0d57f12aceb33a16d4a3c",
      measurementId: "G-86S4RMVDR3"
    };

    const app = initializeApp(firebaseConfig);
    try{ console.debug('[Auth] Using authDomain =', AUTH_DOMAIN); }catch{}
    window.firebaseApp = app;
    const REGION = 'europe-west2';
    const PROJECT_ID = firebaseConfig.projectId || (app && app.options && app.options.projectId) || 'chessmistaketrainer';
    window.FN_BASE = `https://${REGION}-${PROJECT_ID}.cloudfunctions.net`;
    window.FN_LICHESS_URL = window.FN_LICHESS_URL || `${window.FN_BASE}/fetchLichess`;
    window.FN_CHESSCOM_URL = window.FN_CHESSCOM_URL || `${window.FN_BASE}/fetchChessCom`;
    window.SF_BACKEND_URL = window.SF_BACKEND_URL || 'https://sf-backend-283045516917.europe-west2.run.app';

    // Analytics disabled to avoid env errors unless explicitly enabled
    const ENABLE_ANALYTICS = false;
    if (ENABLE_ANALYTICS) {
      (async () => {
        try {
          const mod = await import('https://www.gstatic.com/firebasejs/10.12.4/firebase-analytics.js');
          const supported = await mod.isSupported();
          if (supported) mod.getAnalytics(app);
        } catch {}
      })();
    }
  </script>

  <!-- Firebase Auth + Firestore sync (module) -->
  <script type="module">
    import { getAuth, onAuthStateChanged, signInAnonymously } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js';
    import {
      getFirestore,
      enableIndexedDbPersistence,
      enableMultiTabIndexedDbPersistence,
      collection, doc, getDocs, onSnapshot, writeBatch, addDoc, query, orderBy
    } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-firestore.js';

    const fbApp = window.firebaseApp;
    const fbAuth = getAuth(fbApp);
    const db = getFirestore(fbApp);

    // Prefer single-tab persistence and fallback to multi-tab when needed
    enableIndexedDbPersistence(db).catch(async (err)=>{
      console.warn('[Firestore] enableIndexedDbPersistence failed; attempting multi-tab persistence.', err?.code || err);
      try{
        await enableMultiTabIndexedDbPersistence(db);
        console.info('[Firestore] Multi-tab persistence enabled.');
      }catch(e){
        console.warn('[Firestore] Multi-tab persistence failed; using memory cache only.', e?.code || e);
      }
    });

    // Use fbAuth instead of auth in this module
    const mistakeId = (m) => {
      const key = `${m.fen}|${m.played}`;
      try { return btoa(unescape(encodeURIComponent(key))).replace(/=+$/,''); }
      catch { return key.replace(/[^a-zA-Z0-9_-]/g,'_'); }
    };

    const api = {
      ready:false, user:null, db,
      async saveAllMistakes(arr){
        if(!api.user) return;
        const col = collection(db, 'users', api.user.uid, 'mistakes');
        const snap = await getDocs(col);
        const curIds = new Set(); snap.forEach(d => curIds.add(d.id));
        const nextIds = new Set(arr.map(m => mistakeId(m)));
        const batch = writeBatch(db);
        for(const m of arr){ batch.set(doc(col, mistakeId(m)), m, { merge:true }); }
        for(const id of curIds){ if(!nextIds.has(id)) batch.delete(doc(col, id)); }
        await batch.commit();
      },
      async addMistakesRemote(newOnes){
        if(!api.user || !newOnes.length) return;
        const col = collection(db, 'users', api.user.uid, 'mistakes');
        const batch = writeBatch(db);
        for(const m of newOnes){ batch.set(doc(col, mistakeId(m)), m, { merge:true }); }
        await batch.commit();
      },
      async clearAllRemote(){
        if(!api.user) return;
        const mCol = collection(db, 'users', api.user.uid, 'mistakes');
        const aCol = collection(db, 'users', api.user.uid, 'attempts');
        const mSnap = await getDocs(mCol);
        const aSnap = await getDocs(aCol);
        const batch = writeBatch(db);
        mSnap.forEach(d => batch.delete(doc(mCol, d.id)));
        aSnap.forEach(d => batch.delete(doc(aCol, d.id)));
        await batch.commit();
      },
      async logAttemptRemote(mId, correct, ts, move){
        if(!api.user) return;
        const aCol = collection(db, 'users', api.user.uid, 'attempts');
        await addDoc(aCol, { id:mId, correct:!!correct, ts:ts||Date.now(), move: move||null });
      },
      async getAttemptsRemote(){
        if(!api.user) return [];
        const aCol = collection(db, 'users', api.user.uid, 'attempts');
        const q = query(aCol, orderBy('ts','asc'));
        const snap = await getDocs(q);
        const arr=[]; snap.forEach(d=>arr.push(d.data())); return arr;
      },
      // Sets sync
      async saveAllSets(sets){
        if(!api.user) return;
        const sCol = collection(db, 'users', api.user.uid, 'sets');
        const batch = writeBatch(db);
        for(const s of (sets||[])) batch.set(doc(sCol, s.id), s, { merge:true });
        await batch.commit();
      },
      async deleteSetRemote(id){
        if(!api.user || !id) return;
        const sCol = collection(db, 'users', api.user.uid, 'sets');
        const b = writeBatch(db); b.delete(doc(sCol, id)); await b.commit();
      },
      async updateSetName(id, name){
        if(!api.user || !id) return;
        const sCol = collection(db, 'users', api.user.uid, 'sets');
        const b = writeBatch(db); b.set(doc(sCol, id), { name }, { merge:true }); await b.commit();
      },
      // Imports sync
      // Stable, short ID for imports to avoid oversized Firestore doc IDs
      importId(rec){
        try{
          const s = String(rec?.pgn || '');
          let h1 = 0, h2 = 0;
          for(let i=0;i<s.length;i++){
            const c = s.charCodeAt(i);
            h1 = (h1 * 31 + c) | 0;
            h2 = (h2 * 131 + c) | 0;
          }
          const id = 'p' + (h1>>>0).toString(36) + (h2>>>0).toString(36);
          return id;
        }catch{
          return 'p' + Date.now().toString(36);
        }
      },
      async appendImports(pgns, source){
        if(!api.user) return;
        const iCol = collection(db, 'users', api.user.uid, 'imports');
        const batch = writeBatch(db);
        const now = Date.now(); let idx=0;
        for(const pgn of (pgns||[])){
          if(!pgn) continue;
          const rec = { pgn, source: source||'Imported', ts: now + (idx++) };
          const id = api.importId(rec);
          batch.set(doc(iCol, id), rec, { merge:true });
        }
        try{ await batch.commit(); }
        catch(e){ try{ console.warn('[Imports] Firestore save failed:', e?.code||e); }catch{} }
      },
      async clearImportsRemote(){
        if(!api.user) return;
        const iCol = collection(db, 'users', api.user.uid, 'imports');
        const snap = await getDocs(iCol);
        const batch = writeBatch(db);
        snap.forEach(d => batch.delete(doc(iCol, d.id)));
        await batch.commit();
      },
      async savePrefs(p){
        if(!api.user || !p) return;
        const ref = doc(db, 'users', api.user.uid, 'prefs', 'app');
        const b = writeBatch(db); b.set(ref, p, { merge:true }); await b.commit();
      }
    };

    window.firebaseAPI = api;

    // Cloud sync is optional; avoid automatic sign-in to prevent console errors
    // when Anonymous auth is not enabled. Call firebaseAPI.initAuth() to start.
    api.initAuth = async function(){ try { await signInAnonymously(fbAuth); } catch {} };
    if (window.ENABLE_CLOUD_SYNC) { api.initAuth(); }
    onAuthStateChanged(fbAuth, async (user) => {
      api.user = user || null; api.ready = !!user; window.firebaseUser = user || null;
      try { window.setAuthUIUser && window.setAuthUIUser(user || null); } catch {}

      // Detach previous listeners if any
      try{ if(api._unsubs){ Object.values(api._unsubs).forEach(fn=>{ try{ fn&&fn(); }catch{} }); } }catch{}
      api._unsubs = {};

      if(!user){
        // Wipe local session data on sign-out
        try{
          localStorage.removeItem('pmtt_mistakes');
          localStorage.removeItem('pmtt_attempts');
          localStorage.removeItem('pmtt_sets');
        }catch{}
        try{ window.importedGames = []; }catch{}
        try{ window.LAST_ANALYZED = { mistakes: [], suggestedName: '' }; }catch{}
        try{ window.dispatchEvent(new CustomEvent('firebase:mMistakesUpdated')); }catch{}
        try{ window.dispatchEvent(new CustomEvent('firebase:attemptsUpdated')); }catch{}
        try{ window.dispatchEvent(new CustomEvent('firebase:setsUpdated')); }catch{}
        try{ window.dispatchEvent(new CustomEvent('firebase:importsUpdated')); }catch{}
        return;
      }

      // live sync mistakes -> local
      const mCol = collection(db, 'users', user.uid, 'mistakes');
      api._unsubs.mistakes = onSnapshot(mCol, (snap) => {
        const arr=[]; snap.forEach(d=>arr.push(d.data()));
        try{ localStorage.setItem('pmtt_mistakes', JSON.stringify(arr)); }catch{}
        window.dispatchEvent(new CustomEvent('firebase:mMistakesUpdated'));
      });

      // live sync attempts -> local
      try{
        const aCol = collection(db, 'users', user.uid, 'attempts');
        const qA = query(aCol, orderBy('ts','asc'));
        api._unsubs.attempts = onSnapshot(qA, (snap) => {
          const arr=[]; snap.forEach(d=>arr.push(d.data()));
          try{ localStorage.setItem('pmtt_attempts', JSON.stringify(arr)); }catch{}
          window.dispatchEvent(new CustomEvent('firebase:attemptsUpdated'));
        });
      }catch{}

      // live sync sets -> local
      const sCol = collection(db, 'users', user.uid, 'sets');
      api._unsubs.sets = onSnapshot(sCol, (snap) => {
        const arr=[]; snap.forEach(d=>arr.push(d.data()));
        try{ localStorage.setItem('pmtt_sets', JSON.stringify(arr)); }catch{}
        window.dispatchEvent(new CustomEvent('firebase:setsUpdated'));
      });

      // live sync imports -> merge remote into local to avoid flicker/erase on slow writes
      const iCol = collection(db, 'users', user.uid, 'imports');
      api._unsubs.imports = onSnapshot(iCol, (snap) => {
        const remote=[]; snap.forEach(d=>remote.push(d.data()));
        try{
          const local = Array.isArray(window.importedGames) ? window.importedGames : [];
          // If remote is temporarily empty right after a local add, avoid clearing UI
          const justLocallyUpdated = (Date.now() - (window._importsLocalBump||0)) < 4000;
          if(justLocallyUpdated && remote.length < local.length){
            // keep local as-is; remote will merge on next snapshot
            window.dispatchEvent(new CustomEvent('firebase:importsUpdated'));
            return;
          }
          const map = new Map();
          for(const r of local){ if(r && r.pgn){ if(typeof r.sel==='undefined') r.sel=true; map.set(r.pgn, r); } }
          for(const r of remote){
            if(r && r.pgn){
              const prev = map.get(r.pgn);
              const sel = prev && typeof prev.sel !== 'undefined' ? prev.sel : true;
              map.set(r.pgn, {...r, sel});
            }
          }
          window.importedGames = Array.from(map.values());
        }catch{ window.importedGames = remote; }
        try{ window.dispatchEvent(new CustomEvent('firebase:importsUpdated')); }catch{}
      });
      
      // live sync prefs -> local
      try{
        const pRef = doc(db, 'users', user.uid, 'prefs', 'app');
        api._unsubs.prefs = onSnapshot(pRef, (snap)=>{
          const d = (snap && snap.data && snap.data()) ? snap.data() : {};
          try{ localStorage.setItem('pmtt_prefs', JSON.stringify(d)); }catch{}
          try{ window.dispatchEvent(new CustomEvent('firebase:prefsUpdated')); }catch{}
        });
      }catch{}
    });
  </script>

  <!-- Auth modal logic (Google + email/password) -->
  <script type="module">
    import {
      getAuth, GoogleAuthProvider, signInWithPopup, signInWithRedirect, getRedirectResult,
      signInWithEmailAndPassword, createUserWithEmailAndPassword,
      sendPasswordResetEmail, signOut, onAuthStateChanged
    } from 'https://www.gstatic.com/firebasejs/10.12.4/firebase-auth.js';

    const auth = getAuth(window.firebaseApp);
    const provider = new GoogleAuthProvider();
    provider.setCustomParameters({ prompt: 'select_account' });
    // Prefer redirect everywhere for consistency and fewer popup issues.
    // Allow override via window.AUTH_USE_POPUP=true for local debugging.
    const preferRedirect = (()=>{
      try{
        if (window.AUTH_USE_POPUP === true) return false;
        return true;
      }catch{ return true }
    })();

    const byId = (id)=> document.getElementById(id);
    const modal = byId('authModal');
    const backdrop = byId('authBackdrop');
    const closeBtn = byId('authClose');
    const openBtn = byId('btnAuth');
    const emailEl = byId('authEmail');
    const passEl = byId('authPass');
    const primaryBtn = byId('btnEmailPrimary');
    const resetBtn = byId('btnReset');
    const googleBtn = byId('btnGoogle');
    const toggleLink = byId('linkToggleMode');
    const errEl = byId('authError');

    let mode = 'signin';

    function nameForUser(u){
      if(!u) return '';
      return u.displayName || u.email || (u.isAnonymous ? 'Guest' : '');
    }

    function applyAuthUI(user){
      const openBtn = byId('btnAuth');
      const nameEl = byId('authUserName');
      if(openBtn){
        openBtn.textContent = user ? 'Sign out' : 'Sign in';
        openBtn.title = user ? nameForUser(user) : 'Sign in to sync';
      }
      if(nameEl){
        const nm = nameForUser(user);
        nameEl.textContent = user ? nm : '';
        nameEl.style.display = user ? 'inline' : 'none';
      }
    }
    // expose for other scripts
    window.setAuthUIUser = applyAuthUI;
    // Set initial UI state if auth already initialized
    try { applyAuthUI(auth.currentUser || null); } catch {}
    function setMode(m){
      mode = m === 'signup' ? 'signup' : 'signin';
      if(primaryBtn) primaryBtn.textContent = mode === 'signup' ? 'Create account' : 'Sign in';
      if(resetBtn) resetBtn.style.display = mode === 'signup' ? 'none' : 'inline-block';
      if(toggleLink) toggleLink.textContent = mode === 'signup' ? 'Have an account? Sign in' : 'New here? Create an account';
      if(errEl){ errEl.style.color='var(--bad)'; errEl.textContent = ''; }
    }
    setMode('signin');

    function openModal(){ if(modal){ modal.style.display = 'block'; } setMode('signin'); emailEl?.focus(); }
    function closeModal(){ if(modal){ modal.style.display = 'none'; } }

    openBtn?.addEventListener('click', async()=>{
      const user = auth.currentUser;
      // If signed in anonymously, open modal to upgrade instead of signing out.
      if(user && user.isAnonymous){ openModal(); return; }
      if(user){ try{ await signOut(auth); }catch{}; return; }
      openModal();
    });
    closeBtn?.addEventListener('click', closeModal);
    backdrop?.addEventListener('click', closeModal);
    toggleLink?.addEventListener('click', (e)=>{ e.preventDefault(); setMode(mode==='signup'?'signin':'signup'); });

    function showErr(e){
      if(!errEl) return;
      const code = (e && e.code)||'';
      const msg = (e && e.message)||'';
      const pretty = code.replace('auth/','').replace(/-/g,' ');
      errEl.textContent = pretty || msg || 'Error';
      errEl.style.color = 'var(--bad)';
    }

    // Handle redirect results on load (in case we used redirect flow)
    getRedirectResult(auth).then((res)=>{
      console.debug('[Auth] getRedirectResult resolved', !!res?.user);
      if(res && res.user){
        closeModal();
        setTimeout(()=>{ try{ applyAuthUI(auth.currentUser||null); }catch{} }, 0);
      }
    }).catch((e)=>{ console.debug('[Auth] getRedirectResult error', e?.code||e); });

    googleBtn?.addEventListener('click', async()=>{
      if(!googleBtn) return;
      googleBtn.disabled = true;
      try{
        console.debug('[Auth] Google click. preferRedirect=', preferRedirect);
        if (preferRedirect) {
          await signInWithRedirect(auth, provider);
          return; // navigation follows
        }
        await signInWithPopup(auth, provider);
        closeModal();
      } catch(e){
        console.warn('[Auth] Sign-in attempt failed, trying redirect', e?.code||e);
        try{ await signInWithRedirect(auth, provider); return; }catch{}
        showErr(e);
      } finally {
        try{ googleBtn.disabled = false; }catch{}
      }
    });

    primaryBtn?.addEventListener('click', async()=>{
      const email = (emailEl?.value||'').trim();
      const pass = (passEl?.value||'');
      if(!email || !pass){ if(errEl){ errEl.textContent = 'Enter email and password'; } return; }
      try{
        if(mode==='signup') await createUserWithEmailAndPassword(auth, email, pass);
        else await signInWithEmailAndPassword(auth, email, pass);
        closeModal();
      }catch(e){ showErr(e); }
    });
    resetBtn?.addEventListener('click', async()=>{
      const email = (emailEl?.value||'').trim();
      if(!email){ if(errEl){ errEl.textContent = 'Enter your email to reset password'; } return; }
      try{
        await sendPasswordResetEmail(auth, email);
        if(errEl){ errEl.style.color='var(--good)'; errEl.textContent='Password reset email sent'; setTimeout(()=>{ errEl.style.color='var(--bad)'; }, 1500); }
      }
      catch(e){ showErr(e); }
    });

    onAuthStateChanged(auth, (user)=>{
      console.debug('[Auth] state change =>', user ? (user.email || user.displayName || user.uid) : 'signed out');
      applyAuthUI(user);
      if(user){ closeModal(); }
    });
  </script>

  <!-- Stockfish WASM (local, project-relative path) -->
  <script src="engine/stockfish.js"></script>
  <!-- jQuery + chessboard.js (local) -->
  <script src="/vendor/jquery.min.js"></script>
  <script src="/chessboardjs/js/chessboard-1.0.0.min.js"></script>

  <script>
    /********************************************************************
     * Utils
     ********************************************************************/
    const $ = sel => document.querySelector(sel);
    const $$ = sel => Array.from(document.querySelectorAll(sel));
    const sleep = ms => new Promise(res => setTimeout(res, ms));
    const nowTs = () => Date.now();
    const days = n => n * 24 * 60 * 60 * 1000;
    const clamp = (x, lo, hi) => Math.max(lo, Math.min(hi, x));
    const uid = () => 'm_' + Math.random().toString(36).slice(2) + Date.now().toString(36);
    function tsToDate(ts){ try{ const d=new Date(ts); return d.toLocaleDateString()+' '+d.toLocaleTimeString(); }catch{return '-';} }
    function setStatus(msg){
      try{
        if(typeof msg === 'string'){
          // Suppress legacy per-mistake messages; also update counter if present
          if(/mistakes found:\s*(\d+)/i.test(msg)){
            try{ const m = msg.match(/mistakes found:\s*(\d+)/i); if(m) setMistakeCounter(parseInt(m[1],10)||0); }catch{}
            return;
          }
          if(/^Analyzing\s+\d+\/\d+/.test(msg)) return;
          if(/^Done\. Added\s+/i.test(msg)) msg = 'Analysis finished';
        }
        const h=document.getElementById('importHelp'); if(h) h.textContent=msg;
      }catch{}
    }
    function setMistakeCounter(n){ try{ const el=document.getElementById('importMistakes'); if(el) el.textContent = `Mistakes: ${n}`; }catch{} }

    // Disable native HTML5 drag inside chess boards (we use chessboard.js's own drag)
    document.addEventListener('dragstart', function (e) {
      const t = e.target;
      if (t && t.tagName === 'IMG' && (t.closest('#board') || t.closest('#gvBoard') || t.closest('#statsBoard'))) {
        e.preventDefault();
      }
    }, true);

    // Engine Settings modal (PV, Depth)
    (function(){
      function buildModal(){
        const modal = document.createElement('div');
        modal.id = 'engineSettingsModal';
        modal.style.display = 'none';
        modal.innerHTML = `
          <div id="engSetBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:70"></div>
          <div style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:71">
            <div class="card" style="width:min(480px, 95vw); max-height:90vh; overflow:auto">
              <div style="display:flex;align-items:center;justify-content:space-between;gap:10px">
                <h2>Engine Settings</h2>
                <button id="engSetClose" class="ghost" title="Close">×</button>
              </div>
              <div class="row" style="margin-top:10px">
                <div style="max-width:140px">
                  <label>PV (lines)</label>
                  <input id="engPvInput" type="number" min="1" max="10" value="3" />
                </div>
                <div class="stroke" style="flex:1">
                  <div class="small"><b>Depth</b> <span id="engDepthVal" class="mono muted" style="margin-left:6px">16</span></div>
                  <input id="engDepthInput" type="range" min="1" max="100" value="16" style="width:100%; margin-top:8px" />
                </div>
              </div>
              <div class="row" style="margin-top:12px; justify-content:flex-end">
                <button id="engSetCancel" class="ghost">Cancel</button>
                <button id="engSetSave" class="secondary">Save</button>
              </div>
            </div>
          </div>`;
        document.body.appendChild(modal);
        return modal;
      }
      let modalEl = null;
      function ensureModal(){ if(!modalEl) modalEl = buildModal(); return modalEl; }
      function open(){
        const m = ensureModal();
        // preload values from EngineLive
        try{
          const LS_PV='pmtt_eng_pv', LS_DEPTH='pmtt_eng_depth';
          let pv = (window.EngineLive && window.EngineLive.getMultiPV) ? window.EngineLive.getMultiPV() : null;
          let d  = (window.EngineLive && window.EngineLive.getDepth) ? window.EngineLive.getDepth() : null;
          if(pv==null){ try{ pv = Math.max(1, Math.min(10, parseInt(localStorage.getItem(LS_PV)||'',10)||3)); }catch{ pv=3; } }
          if(d==null){ try{ d  = Math.max(1, Math.min(100, parseInt(localStorage.getItem(LS_DEPTH)||'',10)||16)); }catch{ d=16; } }
          const pvEl = document.getElementById('engPvInput'); if(pvEl) pvEl.value = String(pv);
          const dEl = document.getElementById('engDepthInput'); if(dEl) dEl.value = String(d);
          const dvEl= document.getElementById('engDepthVal'); if(dvEl) dvEl.textContent = String(d);
        }catch{}
        m.style.display = 'block';
      }
      function close(){ try{ const m=ensureModal(); m.style.display='none'; }catch{} }
      let wiredOnce = false;
      function wire(){
        if(wiredOnce) return; wiredOnce = true;
        ensureModal();
        document.getElementById('engSetBackdrop')?.addEventListener('click', close);
        document.getElementById('engSetClose')?.addEventListener('click', close);
        document.getElementById('engSetCancel')?.addEventListener('click', close);
        const dEl = document.getElementById('engDepthInput');
        if(dEl){ dEl.addEventListener('input', ()=>{ const dv=document.getElementById('engDepthVal'); if(dv) dv.textContent=String(dEl.value); }); }
        document.getElementById('engSetSave')?.addEventListener('click', ()=>{
          try{
            const LS_PV='pmtt_eng_pv', LS_DEPTH='pmtt_eng_depth';
            const pv = Math.max(1, Math.min(10, parseInt(document.getElementById('engPvInput')?.value,10)||3));
            const d  = Math.max(1, Math.min(100, parseInt(document.getElementById('engDepthInput')?.value,10)||16));
            try{ localStorage.setItem(LS_PV, String(pv)); localStorage.setItem(LS_DEPTH, String(d)); }catch{}
            if(window.EngineLive){
              if(window.EngineLive.setMultiPV) window.EngineLive.setMultiPV(pv);
              if(window.EngineLive.setDepth) window.EngineLive.setDepth(d);
            }
          }catch{}
          close();
        });
      }
      document.getElementById('engineSettingsBtn')?.addEventListener('click', ()=>{ open(); wire(); });
    })();

    /********************************************************************
     * Game viewer (Import page)
     ********************************************************************/
    const GAMEVIEW = { fens: [], idx: 0, total: 0, pgn: '', whiteBottom: true };
    function gvHide(){ const el = $('#gameViewer'); if(el) el.style.display = 'none'; }
    function gvShow(){ const el = $('#gameViewer'); if(el) el.style.display = 'block'; }
    function gvUpdate(){
      const lbl = $('#gvStatus');
      if(!lbl) return;
      const total = GAMEVIEW.total;
      const idx = GAMEVIEW.idx;
      lbl.textContent = total ? `Move ${idx}/${total}` : '-';
      setBoardFonts(); /* keep font sizes responsive */
    }

    /********************************************************************
     * Storage (local + remote)
     ********************************************************************/
    const LS_MISTAKES = 'pmtt_mistakes';
    const LS_ATTEMPTS = 'pmtt_attempts';
    const LS_SETS = 'pmtt_sets';
    const fb = () => (window.firebaseAPI && window.firebaseAPI.ready) ? window.firebaseAPI : null;

    function loadMistakes(){ try{ return JSON.parse(localStorage.getItem(LS_MISTAKES)||'[]'); }catch{return [];} }
    function saveMistakes(arr){ localStorage.setItem(LS_MISTAKES, JSON.stringify(arr)); if(fb()) fb().saveAllMistakes(arr).catch(()=>{}); renderStatsSetOptions(); renderStatsMistakeList(); renderStatsSummary(); }
    function addMistakes(newOnes){
      const cur = loadMistakes();
      const seen = new Set(cur.map(m => m.fen + '|' + m.played));
      const merged = [...cur];
      const toUpload=[];
      for(const m of newOnes){
        if(!seen.has(m.fen + '|' + m.played)){ merged.push(m); toUpload.push(m); }
      }
      localStorage.setItem(LS_MISTAKES, JSON.stringify(merged));
      if(fb() && toUpload.length) fb().addMistakesRemote(toUpload).catch(()=>{});
      renderMistakeList(); renderStats();
    }
    function clearAllLocal(){
      localStorage.removeItem(LS_MISTAKES);
      localStorage.removeItem(LS_ATTEMPTS);
      if(fb()) fb().clearAllRemote().catch(()=>{});
      renderMistakeList(); renderStats();
    }
    function logAttempt(mId, correct, moveUCI){
      const arr = JSON.parse(localStorage.getItem(LS_ATTEMPTS)||'[]');
      const rec = { id:mId, ts:nowTs(), correct:!!correct, move: moveUCI||null };
      arr.push(rec); localStorage.setItem(LS_ATTEMPTS, JSON.stringify(arr));
      if(fb()) fb().logAttemptRemote(mId, correct, rec.ts, moveUCI).catch(()=>{});
      renderStats();
    }
    function getAttempts(){
      try{
        const cached = JSON.parse(localStorage.getItem(LS_ATTEMPTS)||'[]');
        if(fb()){
          fb().getAttemptsRemote().then(arr => { localStorage.setItem(LS_ATTEMPTS, JSON.stringify(arr)); renderStats(); }).catch(()=>{});
        }
        return cached;
      }catch{return []}
    }

    window.addEventListener('firebase:mMistakesUpdated', ()=>{ try{renderStatsSetOptions();renderStatsMistakeList();renderStatsSummary();}catch{} });
    window.addEventListener('firebase:attemptsUpdated', ()=>{ try{renderStats();}catch{} });
    window.addEventListener('firebase:setsUpdated', ()=>{
      try{ ACTIVE_SET = null; ACTIVE_SET_KEYS = new Set(); }catch{}
      try{renderSets(); renderSetsForTrain(); renderActiveSetInfo();}catch{}
    });
    window.addEventListener('firebase:importsUpdated', ()=>{ try{rebuildImportedTable();}catch{} });

    /********************************************************************
     * Sets (de-duped)
     ********************************************************************/
    // Key helpers: tolerate historical variations (SAN vs UCI stored in sets/records)
    const UCI_RE = /^[a-h][1-8][a-h][1-8][qrbn]?$/i;
    const isUci = (s) => !!(s && UCI_RE.test(String(s)));
    function normFenKey(fen){
      try{
        const toks = String(fen||'').trim().split(/\s+/);
        return [toks[0]||'', toks[1]||'', toks[2]||'', (toks[3]||'-')].join(' ');
      }catch{ return fen||''; }
    }
    function sanitizeSANKey(s){
      try{
        let out = String(s||'').trim();
        out = out.replace(/[\u00D7×]/g,'x');       // unicode times -> x
        out = out.replace(/[+#]/g,'');              // drop check/mate marks
        out = out.replace(/!!|\?\?|!\?|\?!/g,'');// drop NAG-like
        out = out.replace(/e\.p\./gi,'');         // drop en passant marker
        out = out.replace(/\s+/g,'');              // drop spaces
        // Normalize castling digits to letter O
        if(/^0-0-0$/i.test(out)) out = 'O-O-O';
        else if(/^0-0$/i.test(out)) out = 'O-O';
        return out;
      }catch{ return String(s||''); }
    }
    const keyOf = (m) => (m.fen + '|' + m.played);
    function keysForMistake(m){
      try{
        const fen = m?.fen || '';
        const nfen = normFenKey(fen);
        const played = m?.played || '';
        const out = new Set();
        const add = (f,k)=>{ if(f && k) out.add(f + '|' + k); };
        // As-is and sanitized SAN
        add(fen, played);
        add(nfen, played);
        const sp = sanitizeSANKey(played);
        if(sp && sp!==played){ add(fen, sp); add(nfen, sp); }
        // Convert between SAN/ UCI for robust matching
        if(isUci(played)){
          try{
            const san = uciToSAN(fen, played);
            add(fen, san); add(nfen, san);
            const ss = sanitizeSANKey(san); if(ss && ss!==san){ add(fen, ss); add(nfen, ss); }
          }catch{}
        }else{
          try{
            const cl = ChessLite(); cl.loadFEN(fen);
            const uci = cl.parseSANtoMove(sp||played);
            if(uci){ add(fen, uci); add(nfen, uci); }
          }catch{}
        }
        return Array.from(out.values());
      }catch{ return [keyOf(m)]; }
    }
    function expandKeys(keys){
      const out = new Set();
      try{
        for(const k of (keys||[])){
          if(!k || typeof k !== 'string'){ continue; }
          out.add(k);
          const bar = k.indexOf('|');
          if(bar>0){
            const fen = k.slice(0, bar);
            const nfen = normFenKey(fen);
            const mv0 = k.slice(bar+1);
            const mv = mv0;
            const sp = sanitizeSANKey(mv);
            const add = (f,move)=>{ if(f && move) out.add(f + '|' + move); };
            // base + normalized-fen variants
            add(nfen, mv);
            if(sp && sp!==mv){ add(fen, sp); add(nfen, sp); }
            if(isUci(mv)){
              try{
                const san = uciToSAN(fen, mv);
                add(fen, san); add(nfen, san);
                const ss = sanitizeSANKey(san); if(ss && ss!==san){ add(fen, ss); add(nfen, ss); }
              }catch{}
            }else{
              try{
                const cl = ChessLite(); cl.loadFEN(fen);
                const uci = cl.parseSANtoMove(sp||mv);
                if(uci){ add(fen, uci); add(nfen, uci); }
              }catch{}
            }
          }
        }
      }catch{}
      return out;
    }
    function loadSets(){ try{ return JSON.parse(localStorage.getItem(LS_SETS)||'[]'); }catch{return [];} }
    function saveSets(arr){
      localStorage.setItem(LS_SETS, JSON.stringify(arr));
      try{ if(fb()) fb().saveAllSets(arr).catch(()=>{}); }catch{}
      renderSets();
    }

    function findExistingSetByNameAndKeys(name, keys){
      const sets = loadSets();
      const keySet = new Set(keys);
      return sets.find(s => s.name === name && s.keys.length === keySet.size && s.keys.every(k => keySet.has(k)));
    }
    function createSetFromMistakes(mistakes, name){
      const keys = Array.from(new Set(mistakes.map(keyOf)));
      const existing = findExistingSetByNameAndKeys(name||'', keys);
      if(existing) return existing; // avoid duplicates
      const set = { id: uid(), name: name || `Set ${new Date().toLocaleString()}`, keys, created: nowTs() };
      const sets = loadSets(); sets.unshift(set); saveSets(sets); return set;
    }

    function renderSets(){
      const tb = $('#setsTBody'); if(!tb) return;
      const sets = loadSets(); tb.innerHTML = '';
      let i=0; for(const s of sets){
        const tr = document.createElement('tr');
        tr.innerHTML = `
          <td>${++i}</td>
          <td><input data-setid="${s.id}" class="setNameInput" style="width:100%" value="${s.name}"></td>
          <td>${s.keys.length}</td>
          <td class="tiny">${tsToDate(s.created)}</td>
          <td>
            <button class="ghost" data-act="train" data-id="${s.id}">Train</button>
            <button class="ghost" data-act="delete" data-id="${s.id}">Delete</button>
          </td>`;
        tb.appendChild(tr);
      }
      tb.querySelectorAll('button[data-act="delete"]').forEach(btn => btn.addEventListener('click', () => {
        const id = btn.getAttribute('data-id');
        const sets = loadSets().filter(x => x.id!==id); saveSets(sets);
        try{ if(fb()) fb().deleteSetRemote(id).catch(()=>{}); }catch{}
      }));
      async function ensureMistakesForSet(targetSet, timeoutMs){
        function hasSome(){
          const all = loadMistakes();
          if(!all || !all.length) return false;
          if(!targetSet || !targetSet.keys || !targetSet.keys.length) return all.length>0;
          const ks = new Set(targetSet.keys);
          return all.some(m => ks.has(keyOf(m)));
        }
        if(hasSome()) return;
        await new Promise((res)=>{
          let done=false; const onUpd=()=>{ if(!done && hasSome()){ done=true; try{ window.removeEventListener('firebase:mMistakesUpdated', onUpd); }catch{} res(); } };
          try{ window.addEventListener('firebase:mMistakesUpdated', onUpd); }catch{}
          setTimeout(()=>{ if(!done){ done=true; try{ window.removeEventListener('firebase:mMistakesUpdated', onUpd); }catch{} res(); } }, Math.max(500, timeoutMs||3000));
        });
      }

      tb.querySelectorAll('button[data-act="train"]').forEach(btn => btn.addEventListener('click', async () => {
        const id = btn.getAttribute('data-id');
        const s = loadSets().find(x => x.id===id); if(!s) return;
        setActiveSet(s);
        // jump to Train selection -> training mode and start SRS
        showSection('train');
        enterTrainingMode();
        renderActiveSetInfo();
        try{ const info=document.getElementById('mInfo'); if(info) info.textContent='Loading set…'; }catch{}
        await ensureMistakesForSet(s, 10000);
        Session.startSRS();
      }));
      tb.querySelectorAll('input.setNameInput').forEach(inp => inp.addEventListener('change', () => {
        const id = inp.getAttribute('data-setid'); const sets = loadSets();
        const k = sets.findIndex(x => x.id===id); if(k>=0){ sets[k].name = inp.value.trim()||sets[k].name; saveSets(sets); }
      }));
    }
    let ACTIVE_SET = null; let ACTIVE_SET_KEYS = new Set();
    function setActiveSet(s){
      ACTIVE_SET = s;
      ACTIVE_SET_KEYS = expandKeys((s&&s.keys)||[]);
    }
    function renderActiveSetInfo(){ const el = $('#activeSetInfo'); if(el) el.textContent = `Active set: ${ACTIVE_SET?ACTIVE_SET.name:'â€”'}`; }

    function renderSetsForTrain(){
      const tb = $('#trainSetsTBody'); if(!tb) return;
      tb.innerHTML = '';
      const sets = loadSets();
      let i=0; for(const s of sets){
        const tr = document.createElement('tr');
        tr.style.cursor = 'pointer';
        tr.classList.toggle('selected', ACTIVE_SET && s.id===ACTIVE_SET.id);
        tr.innerHTML = `<td>${++i}</td><td>${s.name}</td><td>${s.keys.length}</td>`;
        tr.addEventListener('click', () => { setActiveSet(s); renderActiveSetInfo(); renderSetsForTrain(); });
        tb.appendChild(tr);
      }
    }

    /********************************************************************
     * User-only helpers for filtering mistakes
     ********************************************************************/
    function parsePGNHeaders(pgn){
      const h={}; const re=/\[(\w+)\s+"([^"]*)"\]/g; let m; while((m=re.exec(pgn||''))) h[m[1]]=m[2]; return h;
    }
    function inferUsernames(){
      const names=[];
      const u1=$('#lichessUser')?.value.trim(); if(u1) names.push(u1.toLowerCase());
      const u2=$('#chesscomUser')?.value.trim(); if(u2) names.push(u2.toLowerCase());
      window.LAST_USERNAMES = new Set(names);
    }
    // Derive a comparable timestamp from PGN headers
    function pgnTimeMs(pgn){
      try{
        const h = parsePGNHeaders(pgn||'');
        const norm = (d)=> (d||'').replace(/\?/g,'01').replace(/\./g,'-');
        function toMs(d,t){
          const dd = norm(d); if(!dd) return 0;
          let iso = dd;
          if(/^\d{4}-\d{2}-\d{2}$/.test(dd)){
            const tt = (t||'12:00:00');
            const tfix = /^\d{2}:\d{2}(:\d{2})?$/.test(tt) ? (tt.length===5?tt+':00':tt) : '12:00:00';
            iso = dd + 'T' + tfix + 'Z';
          }
          const ms = Date.parse(iso);
          return isNaN(ms) ? 0 : ms;
        }
        const utc = toMs(h.UTCDate, h.UTCTime);
        if(utc) return utc;
        const dateOnly = toMs(h.Date, h.UTCTime || '12:00:00');
        if(dateOnly) return dateOnly;
        const end = toMs(h.EndDate || h.EventDate, h.EndTime || '12:00:00');
        if(end) return end;
      }catch{}
      return 0;
    }
    function userSideForPGN(pgn){
      try{
        const h=parsePGNHeaders(pgn||''); const w=(h.White||'').toLowerCase(); const b=(h.Black||'').toLowerCase();
        const us = window.LAST_USERNAMES || new Set();
        for(const name of us){ if(!name) continue; if(w===name || w.includes(name)) return 'w'; if(b===name || b.includes(name)) return 'b'; }
        return null;
      }catch{return null;}
    }
    function filterMistakesToUserOnly(ms){
      if(!ms || !ms.length) return [];
      const out=[];
      for(const m of ms){
        const side = userSideForPGN(m.pgn||'');
        if(side && m.side===side) out.push(m);
      }
      return out;
    }

    /********************************************************************
     * ChessLite minimal engine (FEN, legal moves, SAN parsing)
     ********************************************************************/
    function ChessLite(){
      const FILES='abcdefgh';
      let board = new Array(64).fill(null);
      let side='w';
      let castling={K:true,Q:true,k:true,q:true};
      let ep=-1, halfmove=0, fullmove=1;

      function idx(file, rank){ return (7-(rank-1))*8+file; }
      function sqToIdx(sq){ const f=FILES.indexOf(sq[0]); const r=parseInt(sq[1],10); return idx(f,r); }
      function idxToSq(i){ const r=8-Math.floor(i/8); const f=i%8; return FILES[f]+r; }
      function pieceColor(pc){ return pc===pc?.toUpperCase()?'w':'b'; }
      function reset(){ loadFEN("rnbqkbnr/pppppppp/8/8/8/8/PPPPPPPP/RNBQKBNR w KQkq - 0 1"); }
      function loadFEN(f){
        board.fill(null);
        const parts=f.trim().split(/\s+/);
        const rows=parts[0].split('/');
        for(let r=0;r<8;r++){
          let file=0;
          for(const ch of rows[r]){
            if(/[1-8]/.test(ch)) file+=parseInt(ch,10);
            else{ board[r*8+file]=ch; file++; }
          }
        }
        side=parts[1]||'w';
        castling={K:false,Q:false,k:false,q:false};
        if(parts[2]&&parts[2]!=='-'){ for(const c of parts[2]) if(castling.hasOwnProperty(c)) castling[c]=true; }
        ep=(parts[3]&&parts[3]!=='-')?sqToIdx(parts[3]):-1;
        halfmove=parts[4]?parseInt(parts[4],10):0;
        fullmove=parts[5]?parseInt(parts[5],10):1;
        return true;
      }
      function fen(){
        let s='';
        for(let r=0;r<8;r++){
          let empty=0;
          for(let f=0;f<8;f++){
            const p=board[r*8+f];
            if(!p) empty++;
            else{ if(empty){s+=empty;empty=0;} s+=p; }
          }
          if(empty) s+=empty;
          if(r<7) s+='/';
        }
        s+=' '+side+' ';
        let cstr=''; if(castling.K)cstr+='K'; if(castling.Q)cstr+='Q'; if(castling.k)cstr+='k'; if(castling.q)cstr+='q';
        s+=(cstr||'-');
        s+=' '+(ep>=0?idxToSq(ep):'-');
        s+=' '+halfmove+' '+fullmove;
        return s;
      }
      function rcOf(i){ return { r:Math.floor(i/8), c:i%8 }; }
      function inBounds(r,c){ return r>=0&&r<8&&c>=0&&c<8; }
      function kingIndex(color){ const K=(color==='w')?'K':'k'; for(let i=0;i<64;i++) if(board[i]===K) return i; return -1; }
      function squareAttacked(i, by){
        const {r,c}=rcOf(i);
        // pawns
        if(by==='w'){ const rr=r+1; if(inBounds(rr,c-1)&&board[rr*8+c-1]==='P')return true; if(inBounds(rr,c+1)&&board[rr*8+c+1]==='P')return true;}
        else{ const rr=r-1; if(inBounds(rr,c-1)&&board[rr*8+c-1]==='p')return true; if(inBounds(rr,c+1)&&board[rr*8+c+1]==='p')return true;}
        // knights
        const nn=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
        for(const [dr,dc] of nn){ const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc))continue; const p=board[rr*8+cc]; if(p && ((by==='w'&&p==='N')||(by==='b'&&p==='n'))) return true; }
        // bishops/queens
        const di=[[-1,-1],[-1,1],[1,-1],[1,1]];
        for(const [dr,dc] of di){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const p=board[rr*8+cc]; if(p){ if((by==='w'&&('BQ'.includes(p)))||(by==='b'&&('bq'.includes(p)))) return true; break;} rr+=dr; cc+=dc; } }
        // rooks/queens
        const or=[[-1,0],[1,0],[0,-1],[0,1]];
        for(const [dr,dc] of or){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const p=board[rr*8+cc]; if(p){ if((by==='w'&&('RQ'.includes(p)))||(by==='b'&&('rq'.includes(p)))) return true; break;} rr+=dr; cc+=dc; } }
        // king
        for(let dr=-1;dr<=1;dr++){ for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0)continue; const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc))continue; const p=board[rr*8+cc]; if(p && ((by==='w'&&p==='K')||(by==='b'&&p==='k'))) return true; } }
        return false;
      }
      function inCheck(color){ const ki=kingIndex(color); return squareAttacked(ki, color==='w'?'b':'w'); }

      function clone(){ return { board:board.slice(), side, castling:{...castling}, ep, halfmove, fullmove }; }
      function restore(s){ board=s.board.slice(); side=s.side; castling={...s.castling}; ep=s.ep; halfmove=s.halfmove; fullmove=s.fullmove; }

      function makeMove(from, to, promotion){
        const prev=clone();
        const p=board[from];
        const pc=pieceColor(p);
        const cap=board[to];

        // en passant capture
        if((p==='P'||p==='p')){
          const {r:rf,c:cf}=rcOf(from); const {r:rt,c:ct}=rcOf(to);
          if(cf!==ct && !cap){ const capIdx = pc==='w' ? to+8 : to-8; board[capIdx]=null; }
        }
        // move piece
        board[to]=board[from]; board[from]=null;

        // promotion
        if(promotion){ board[to] = (pc==='w'?promotion.toUpperCase():promotion.toLowerCase()); }

        // castling rook move
        if(p==='K' && Math.abs(rcOf(to).c - rcOf(from).c)===2){
          if(rcOf(to).c===6){ board[sqToIdx('f1')]='R'; board[sqToIdx('h1')]=null; }
          else { board[sqToIdx('d1')]='R'; board[sqToIdx('a1')]=null; }
          castling.K=false; castling.Q=false;
        }
        if(p==='k' && Math.abs(rcOf(to).c - rcOf(from).c)===2){
          if(rcOf(to).c===6){ board[sqToIdx('f8')]='r'; board[sqToIdx('h8')]=null; }
          else { board[sqToIdx('d8')]='r'; board[sqToIdx('a8')]=null; }
          castling.k=false; castling.q=false;
        }

        // update ep
        ep=-1;
        if(p==='P' || p==='p'){
          const {r:rf}=rcOf(from); const {r:rt}=rcOf(to);
          if(Math.abs(rt-rf)===2) ep = pc==='w' ? (to+8) : (to-8);
        }

        // castling rights
        const fromSq=idxToSq(from), toSq=idxToSq(to);
        if(p==='K'){ castling.K=false; castling.Q=false; }
        if(p==='k'){ castling.k=false; castling.q=false; }
        if(fromSq==='h1'||toSq==='h1') castling.K=false;
        if(fromSq==='a1'||toSq==='a1') castling.Q=false;
        if(fromSq==='h8'||toSq==='h8') castling.k=false;
        if(fromSq==='a8'||toSq==='a8') castling.q=false;

        if((p==='P'||p==='p') || cap) halfmove=0; else halfmove++;
        if(side==='b') fullmove++;
        side = side==='w'?'b':'w';

        return prev;
      }

      function generate(){
        const moves=[];
        const us=side, them=side==='w'?'b':'w';
        for(let i=0;i<64;i++){
          const p=board[i]; if(!p||pieceColor(p)!==us) continue;
          const {r,c}=rcOf(i);

          const add=(from,to,promotion)=>{
            const prev=clone(); makeMove(from,to,promotion);
            const legal=!inCheck(us); restore(prev);
            if(legal){ moves.push({from, to, promotion:promotion||null, piece:p, captured:null}); }
          };

          if(p==='P'||p==='p'){
            const forward=(us==='w')?-1:1; const start=(us==='w')?6:1; const promo=(us==='w')?0:7;
            const oneR=r+forward;
            if(inBounds(oneR,c) && !board[oneR*8+c]){
              if(oneR===promo){ for(const pr of ['q','r','b','n']) add(i, oneR*8+c, pr); }
              else add(i, oneR*8+c);
              const twoR=r+2*forward;
              if(r===start && !board[twoR*8+c]) add(i, twoR*8+c);
            }
            for(const dc of [-1,1]){
              const rr=r+forward, cc=c+dc; if(!inBounds(rr,cc)) continue;
              const t=rr*8+cc;
              if(board[t] && pieceColor(board[t])===them){
                if(rr===promo){ for(const pr of ['q','r','b','n']) add(i,t,pr); }
                else add(i,t);
              }else if(t===ep){ add(i,t); }
            }
          }else if(p==='N'||p==='n'){
            const NN=[[-2,-1],[-2,1],[-1,-2],[-1,2],[1,-2],[1,2],[2,-1],[2,1]];
            for(const [dr,dc] of NN){ const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc)) continue; const t=rr*8+cc; if(!board[t]||pieceColor(board[t])!==us) add(i,t); }
          }else if(p==='B'||p==='b'){
            const D=[[-1,-1],[-1,1],[1,-1],[1,1]];
            for(const [dr,dc] of D){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const t=rr*8+cc; if(board[t]){ if(pieceColor(board[t])!==us) add(i,t); break; } add(i,t); rr+=dr; cc+=dc; } }
          }else if(p==='R'||p==='r'){
            const D=[[-1,0],[1,0],[0,-1],[0,1]];
            for(const [dr,dc] of D){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const t=rr*8+cc; if(board[t]){ if(pieceColor(board[t])!==us) add(i,t); break; } add(i,t); rr+=dr; cc+=dc; } }
          }else if(p==='Q'||p==='q'){
            const D=[[-1,-1],[-1,1],[1,-1],[1,1],[-1,0],[1,0],[0,-1],[0,1]];
            for(const [dr,dc] of D){ let rr=r+dr,cc=c+dc; while(inBounds(rr,cc)){ const t=rr*8+cc; if(board[t]){ if(pieceColor(board[t])!==us) add(i,t); break; } add(i,t); rr+=dr; cc+=dc; } }
          }else if(p==='K'||p==='k'){
            for(let dr=-1;dr<=1;dr++){ for(let dc=-1;dc<=1;dc++){ if(dr===0&&dc===0)continue; const rr=r+dr,cc=c+dc; if(!inBounds(rr,cc))continue; const t=rr*8+cc; if(!board[t]||pieceColor(board[t])!==us) add(i,t); } }
            if(us==='w' && r===7 && c===4){
              if(castling.K && !board[sqToIdx('f1')] && !board[sqToIdx('g1')] && !inCheck('w') && !squareAttacked(sqToIdx('f1'),'b') && !squareAttacked(sqToIdx('g1'),'b')) add(i,sqToIdx('g1'));
              if(castling.Q && !board[sqToIdx('d1')] && !board[sqToIdx('c1')] && !board[sqToIdx('b1')] && !inCheck('w') && !squareAttacked(sqToIdx('d1'),'b') && !squareAttacked(sqToIdx('c1'),'b')) add(i,sqToIdx('c1'));
            }
            if(us==='b' && r===0 && c===4){
              if(castling.k && !board[sqToIdx('f8')] && !board[sqToIdx('g8')] && !inCheck('b') && !squareAttacked(sqToIdx('f8'),'w') && !squareAttacked(sqToIdx('g8'),'w')) add(i,sqToIdx('g8'));
              if(castling.q && !board[sqToIdx('d8')] && !board[sqToIdx('c8')] && !board[sqToIdx('b8')] && !inCheck('b') && !squareAttacked(sqToIdx('d8'),'w') && !squareAttacked(sqToIdx('c8'),'w')) add(i,sqToIdx('c8'));
            }
          }
        }
        return moves.map(m=>({
          from: idxToSq(m.from), to: idxToSq(m.to),
          uci: idxToSq(m.from)+idxToSq(m.to)+(m.promotion?m.promotion:''),
          piece: m.piece, promotion: m.promotion||null,
          captured: null
        }));
      }

      function moveUci(uci){
        const from = sqToIdx(uci.slice(0,2)), to = sqToIdx(uci.slice(2,4));
        const promo = uci.length>4 ? uci[4] : null;
        const legal = generate().filter(m => m.uci === (uci));
        if(legal.length){
          const prev = makeMove(from,to,promo);
          return {ok:true, prev};
        }
        return {ok:false};
      }

      function parseSANtoMove(san){
        san=san.trim();
        if(/^O-O-O|^0-0-0/.test(san)){ return (side==='w'?'e1c1':'e8c8'); }
        if(/^O-O|^0-0/.test(san)){ return (side==='w'?'e1g1':'e8g8'); }
        san = san.replace(/[+#]|!!|\?\?|!\?|\?!/g, '');
        let promo=null; const pm=san.match(/=([NBRQ])/); if(pm){ promo=pm[1].toLowerCase(); san=san.replace(/=([NBRQ])/, ''); }
        const dm=san.match(/([a-h][1-8])$/); if(!dm) return null; const dest=dm[1]; san=san.slice(0, san.length-dest.length);
        let pieceLetter='P'; if(/^[NBRQK]/.test(san)){ pieceLetter=san[0]; san=san.slice(1); }
        san=san.replace('x','');
        let disFile=null, disRank=null;
        if(san.length===2){ if(/[a-h]/.test(san[0]))disFile=san[0]; if(/[1-8]/.test(san[0]))disRank=san[0]; if(/[a-h]/.test(san[1]))disFile=san[1]; if(/[1-8]/.test(san[1]))disRank=san[1]; }
        else if(san.length===1){ if(/[a-h]/.test(san))disFile=san; if(/[1-8]/.test(san))disRank=san; }

        const legal=generate().filter(m=>m.to===dest).filter(m=>{
          const want=pieceLetter; const isPawn=want==='P';
          const okPiece = isPawn ? /[Pp]/.test(m.piece) :
            (want==='N'?/[Nn]/.test(m.piece): want==='B'?/[Bb]/.test(m.piece):
             want==='R'?/[Rr]/.test(m.piece): want==='Q'?/[Qq]/.test(m.piece): /[Kk]/.test(m.piece));
          if(!okPiece) return false;
          if(disFile && m.from[0]!==disFile) return false;
          if(disRank && m.from[1]!==disRank) return false;
          if(promo && m.promotion!==promo) return false;
          return true;
        });
        return (legal[0] && legal[0].uci) || null;
      }

      function loadPGN(pgn){
        const text = (pgn||'').replace(/\r/g,'').replace(/\[(.|\n)*?\]\s*/g,' ').trim();
        const tokens=[]; let i=0;
        while(i<text.length){
          const ch=text[i];
          if(ch==='{' ){ let j=i+1; while(j<text.length&&text[j]!=='}') j++; tokens.push({type:'comment', value:text.slice(i+1,j)}); i=j+1; continue; }
          if(/\s/.test(ch)){ i++; continue; }
          const num=text.slice(i).match(/^\d+\.(\.\.)?/); if(num){ i+=num[0].length; continue; }
          const res=text.slice(i).match(/^(1-0|0-1|1\/2-1\/2|\*)/); if(res){ i+=res[0].length; continue; }
          const nag=text.slice(i).match(/^\$\d+/); if(nag){ i+=nag[0].length; continue; }
          let j=i; while(j<text.length && !/\s|\{/.test(text[j])) j++;
          tokens.push({type:'san', value:text.slice(i,j)}); i=j;
        }
        reset();
        const moves=[];
        for(const t of tokens){
          if(t.type==='san'){
            const uci=parseSANtoMove(t.value);
            if(!uci) continue;
            const mv=moveUci(uci);
            if(!mv.ok) continue;
            moves.push({uci, san:t.value, fenAfter:fen()});
          }else{
            moves.push({comment:t.value});
          }
        }
        return moves;
      }

      return {
        reset, loadFEN, fen, turn:()=>side,
        moves: generate, moveUci, parseSANtoMove, loadPGN,
        idxToSq, sqToIdx, inCheck
      }
    }

    /********************************************************************
     * SAN helper (UCI -> SAN)
     ********************************************************************/
    function uciToSAN(fen, uci){
      if(!fen || !uci) return uci || 'â€”';
      const cl = ChessLite(); cl.loadFEN(fen);
      const legal = cl.moves();
      const mv = legal.find(m => m.uci === uci);
      if(!mv){ try { return uci.slice(2,4); } catch { return uci; } }
      // Castling
      if((mv.piece==='K' || mv.piece==='k') && ((mv.from==='e1'&& (mv.to==='g1'||mv.to==='c1')) || (mv.from==='e8' && (mv.to==='g8'||mv.to==='c8')))){
        return (mv.to==='g1'||mv.to==='g8') ? 'O-O' : 'O-O-O';
      }
      const isPawn = /[Pp]/.test(mv.piece);
      const pieceLetter = isPawn ? '' : mv.piece.toUpperCase();
      // Disambiguation
      let disamb='';
      if(!isPawn){
        const competing = legal.filter(x => x.to===mv.to && x.piece===mv.piece && x.uci!==mv.uci);
        if(competing.length){
          const sameFile = competing.some(x => x.from[0]===mv.from[0]);
          const sameRank = competing.some(x => x.from[1]===mv.from[1]);
          if(!sameFile) disamb = mv.from[0];
          else if(!sameRank) disamb = mv.from[1];
          else disamb = mv.from;
        }
      }
      const isCapture = !!mv.captured;
      let san = '';
      if(isPawn){ san = (isCapture ? (mv.from[0] + 'x') : '') + mv.to; }
      else { san = pieceLetter + disamb + (isCapture?'x':'') + mv.to; }
      if(mv.promotion){ san += '=' + mv.promotion.toUpperCase(); }
      const tmp = ChessLite(); tmp.loadFEN(fen); tmp.moveUci(uci);
      const opp = tmp.turn(); const inCheck = tmp.inCheck(opp); const hasReply = tmp.moves().length>0;
      if(inCheck) san += hasReply ? '+' : '#';
      return san;
    }

    /********************************************************************
     * Stockfish wrapper
     ********************************************************************/
    const Engine = (() => {
      let sf=null, ready=false, busy=false, lastScore={cp:0,mate:null}, resolvers=[], initPromise=null;
      function ensure(){
        if(initPromise) return initPromise;
        initPromise = new Promise(async (resolve) => {
          try{
            if(window.SF_BACKEND_URL){ ready=true; $('#engineStateServer').textContent='server'; return resolve(true); }
          }catch{}
          try{
            if(typeof Stockfish==='function'){
              try{ Stockfish.locateFile = (path, prefix)=> 'engine/' + path; }catch{}
              sf = Stockfish();
            } else {
              sf = null;
            }
            if(!sf){ /* do not show error text in UI */ return resolve(false); }
            sf.onmessage = (e) => {
              const line=(''+(e.data||e)).trim();
              if(line==='uciok'){ sf.postMessage('isready'); return; }
              if(line==='readyok'){ ready=true; $('#engineStateServer').textContent='ready'; return; }
              if(line.startsWith('info')){
                const mMate=line.match(/score\s+mate\s+(-?\d+)/);
                const mCp=line.match(/score\s+cp\s+(-?\d+)/);
                if(mMate){ lastScore={mate:parseInt(mMate[1],10),cp:mMate[1][0]==='-'?-10000:10000}; }
                else if(mCp){ lastScore={cp:parseInt(mCp[1],10),mate:null}; }
              }
              if(line.startsWith('bestmove')){
                const bm=line.split(' ')[1]; const r=resolvers.shift(); busy=false; if(r) r({bestmove:bm, score:lastScore});
              }
            };
            sf.postMessage('uci');
            const t0=Date.now(); while(!ready && (Date.now()-t0)<4000){ await sleep(20); }
            $('#engineStateServer').textContent = ready ? 'ready' : 'loadingâ€¦';
            resolve(true);
          }catch(err){ /* suppress Engine:error in UI */ resolve(false); }
        });
        return initPromise;
      }
      async function analyze(fen, depth=12){
        await ensure();
        while(busy) await sleep(5);
        if(sf){
          busy=true; lastScore={cp:0,mate:null};
          sf.postMessage('ucinewgame');
          sf.postMessage('position fen ' + fen);
          const p=new Promise(res=>resolvers.push(res));
          sf.postMessage('go depth '+depth);
          const out=await p;
          return { cp:(out.score.mate!==null?(out.score.mate>0?10000:-10000):out.score.cp), bestmove: out.bestmove };
        }
        // Server (Cloud Run)
        const base=(window.SF_BACKEND_URL||'').replace(/\/$/,'');
        const url=`${base}/bestmove`;
        const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({fen,depth})});
        const data=await res.json(); return { cp:data.cp??0, bestmove:data.bestmove };
      }
      return { analyze, ensure };
    })();

    /********************************************************************
     * PGN helpers & analysis (user-only)
     ********************************************************************/
    const DEFAULT_SEV={ inacc:50, mistake:150, blunder:300 };
    function getSev(){
      try{
        const fromLs = JSON.parse(localStorage.getItem('pmtt_sev')||'{}');
        let base = {...DEFAULT_SEV, ...fromLs};
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          if(p && p.analysisThresholds && typeof p.analysisThresholds==='object'){
            base = {...base, ...p.analysisThresholds};
          }
        }catch{}
        return base;
      }catch{ return DEFAULT_SEV; }
    }
    function severityFromDrop(cp){ const T=getSev(); const x=Math.abs(Math.round(cp)); if(x>=T.blunder) return 'blunder'; if(x>=T.mistake) return 'mistake'; if(x>=T.inacc) return 'inaccuracy'; return null; }

    // Format deltaCp (positive drop) as "centipawn loss" (negative value in pawns)
    function formatCentipawnLoss(deltaCp){
      const cp = Number(deltaCp)||0; // delta in centipawns (positive means worse)
      const loss = -(cp)/100;        // convert to pawns and invert sign
      const abs = Math.abs(loss);
      if(loss === 0) return '0';
      return abs < 1 ? loss.toFixed(1) : loss.toFixed(2);
    }

    async function analyzeOnBackend(pgns){
      const url=`${window.FN_BASE}/analyzePGNs`;
      const thr=getSev();
      const depth = parseInt(window.getAnalysisDepth?.()||12,10)||12;
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({pgns,depth,thresholds:thr})});
      if(!res.ok) throw new Error(`analyzePGNs failed ${res.status}`);
      const json=await res.json();
      return json.mistakes||[];
    }

    /********************************************************************
     * Live Engine (WASM) analysis for Train board (Worker-based)
     ********************************************************************/
    const EngineLive = (() => {
      const DEBUG = (window.DEBUG_ENGINE ?? true);
      const dlog = (...args)=>{ try{ if(DEBUG) console.log('[EngineLive]', ...args); }catch{} };
      const derr = (...args)=>{ try{ if(DEBUG) console.error('[EngineLive]', ...args); }catch{} };

      let sf = null, ready = false, active = false, pending = false;
      let gotUci = false;
      let queuedFen = null;
      let curFen = null, analyzeTimer = null;
      const lines = new Map(); // multipv -> {scoreStr, pvUci:[], pvSan:[]}
      let engineName = '-';
      let lastNps = 0;
      let curDepth = 0; // current depth reported by engine
      let curSelDepth = 0; // optional seldepth
      const LS_ENG_PV = 'pmtt_eng_pv';
      const LS_ENG_DEPTH = 'pmtt_eng_depth';
      function loadPv(){ try{ return Math.max(1, Math.min(10, parseInt(localStorage.getItem(LS_ENG_PV)||'',10)||3)); }catch{ return 3; } }
      function loadDepth(){ try{ return Math.max(1, Math.min(100, parseInt(localStorage.getItem(LS_ENG_DEPTH)||'',10)||16)); }catch{ return 16; } }
      let multiPV = loadPv();
      let depth = loadDepth();

      function setState(txt){
        dlog('state ->', txt);
        try{ const s = $('#engineStateLive'); if(s) s.textContent = txt; }catch{}
        try{ if(txt==='off'||txt==='error'||txt==='messageerror'){ evalBarVisible(false); } }catch{}
      }
      function clearUI(){ try{ const el=$('#engineLines'); if(el) el.textContent=''; }catch{} }
      function updateMeta(){
        try{ const m=$('#engineMeta'); if(m) m.textContent = engineName; }catch{}
        try{ const p=$('#enginePerf'); if(p){ const knps=Math.round(lastNps/1000); p.textContent = `${knps} kn/s`; } }catch{}
        try{ const d=$('#engineDepth'); if(d){ d.textContent = `depth: ${depth}/${curDepth||0}`; } }catch{}
      }
      function formatScore(line){
        const mMate=line.match(/score\s+mate\s+(-?\d+)/);
        if(mMate){ const n=parseInt(mMate[1],10); return (n>0?`#${n}`:`#-${Math.abs(n)}`); }
        const mCp=line.match(/score\s+cp\s+(-?\d+)/);
        const cp = mCp? parseInt(mCp[1],10):0;
        const pawns = (cp/100).toFixed(2);
        return (cp>=0?`+${pawns}`:pawns);
      }
      function pvToSANs(fen, pvUci){
        try{
          const out=[]; let cur = fen; const cl=ChessLite(); cl.loadFEN(cur);
          for(const u of pvUci){
            out.push(uciToSAN(cur, u));
            const mv=cl.moveUci(u); if(!mv.ok) break; cur = cl.fen();
          }
          return out;
        }catch{ return pvUci; }
      }
      function updateUI(){
        const el=$('#engineLines'); if(!el) return;
        const keys=Array.from({length: multiPV}, (_,i)=>i+1);
        const parts=[];
        for(const k of keys){
          const ln=lines.get(k); if(!ln) continue;
          const san = (ln.pvSan||[]).slice(0,6).join(' ');
          const scoreOut = (ln.scoreStrW || ln.scoreStr);
          parts.push(`${k}. ${scoreOut}  ${san}`);
        }
        el.textContent = parts.join("\n");
      }

      function ensure(){
        if(sf) return true;

        // Create dedicated worker that loads stockfish.js and resolves wasm locally
        try{
          // Use our bridge worker so stdout/stderr are forwarded to main thread
          // and engine assets resolve relative to /engine/
          sf = new Worker('/engine/stockfish-worker.js');
          // Expose for DevTools validation
          try{ window._engineWorker = sf; }catch{}
          dlog('worker created');
        }catch(err){
          setState('worker error');
          derr('worker creation failed', err);
          try{
            const el=$('#engineLines');
            if(el) el.textContent = 'Failed to create Stockfish worker: ' + (err && err.message ? err.message : String(err));
          }catch{}
          return false;
        }

        sf.onmessage = (e) => {
          const line = (''+(e.data||e)).trim();
          if(DEBUG && line) dlog('worker ->', line.slice(0,240));

          if(line === 'uciok'){ gotUci=true; try{ sf.postMessage('isready'); }catch{} return; }
          if(line === 'readyok'){
            ready=true; setState('ready');
            if(queuedFen){ const f=queuedFen; queuedFen=null; go(f); }
            return;
          }

          // Capture engine identity
          {
            const m = line.match(/^id\s+name\s+(.+)$/i);
            if(m){ engineName = m[1].trim(); updateMeta(); }
          }

          if(line.startsWith('info')){
            if(!active) return;
            // Track perf/depth from any info line
            try{ const md=line.match(/\bdepth\s+(\d+)/); if(md){ const nd=parseInt(md[1],10)||0; if(nd>curDepth){ curDepth=nd; updateMeta(); } } }catch{}
            try{ const msd=line.match(/\bseldepth\s+(\d+)/); if(msd){ const nsd=parseInt(msd[1],10)||0; if(nsd!==curSelDepth){ curSelDepth=nsd; } } }catch{}
            try{ const mnps=line.match(/\bnps\s+(\d+)/); if(mnps){ lastNps = parseInt(mnps[1],10)||0; updateMeta(); } }catch{}

            // Only process PV lines that include multipv; ignore generic info to avoid wiping values
            const m=line.match(/\bmultipv\s+(\d+)/);
            if(!m) return;
            const idx = parseInt(m[1],10)||1;
            const scoreStr = formatScore(line);
            // compute eval for white, then adapt to bar orientation
            let cpWhite = 0;
            let scoreStrW = scoreStr;
            try{
              const mMate=line.match(/score\s+mate\s+(-?\d+)/);
              const mCp=line.match(/score\s+cp\s+(-?\d+)/);
              const turnWhite = /\sw\s/.test(curFen||' ');
              if(mMate){
                const mate=parseInt(mMate[1],10)||0; // positive = mate for side to move
                // derive white-centric cp and string (# for white, #- for black)
                const whiteMating = (turnWhite && mate>0) || (!turnWhite && mate<0);
                scoreStrW = whiteMating ? ('#'+Math.abs(mate)) : ('#-'+Math.abs(mate));
                const cp = mate>0 ? 10000 : -10000; cpWhite = turnWhite ? cp : -cp;
              } else if(mCp){
                const cp=parseInt(mCp[1],10)||0;
                cpWhite = turnWhite ? cp : -cp;
                const pawns = (cpWhite/100).toFixed(2);
                scoreStrW = (cpWhite>=0?`+${pawns}`:pawns);
              }
              if(idx===1 && (mMate || mCp)) updateEvalBar(cpWhite);
            }catch{}
            const prev = lines.get(idx) || {};
            const pvIdx=line.indexOf(' pv ');
            const nextPvUci = pvIdx>=0 ? line.slice(pvIdx+4).trim().split(/\s+/) : (prev.pvUci||[]);
            const nextPvSan = (pvIdx>=0 && curFen) ? pvToSANs(curFen, nextPvUci) : (prev.pvSan||nextPvUci);
            // If line had no explicit score, keep previous display string
            const hadScore = /score\s+(cp|mate)\s+(-?\d+)/.test(line);
            const nextScoreStr = hadScore ? scoreStr : (prev.scoreStr||scoreStr);
            const nextScoreStrW = hadScore ? scoreStrW : (prev.scoreStrW||scoreStrW);
            lines.set(idx, { scoreStr: nextScoreStr, scoreStrW: nextScoreStrW, pvUci: nextPvUci, pvSan: nextPvSan });

            // Draw the first PV arrow
            if(idx===1 && nextPvUci.length){
              BOARD.arrows.engine = nextPvUci[0];
              renderArrows();
            }
            updateUI();
          }

          if(line.startsWith('bestmove')){
            pending=false;
          }

          // Emit loader errors to UI as text
          if(/^stockfish importScripts error:/.test(line) || /^stockfish worker error:/.test(line)){
            try{
              const el=$('#engineLines');
              if(el) el.textContent = line + '\nCheck that /engine/stockfish.wasm is present and COOP/COEP headers are enabled.';
            }catch{}
            setState('error');
          }
        };

        sf.onmessageerror = (e) => {
          setState('messageerror');
          derr('worker messageerror', e);
          try{ const el=$('#engineLines'); if(el) el.textContent = 'Stockfish worker messageerror.'; }catch{}
        };

        sf.onerror = (ev) => {
          setState('error');
          derr('worker error', ev);
          try{
            const el=$('#engineLines');
            if(el) el.textContent = 'Stockfish worker error: ' + (ev && ev.message ? ev.message : (ev && ev.filename ? ev.filename : 'unknown'));
          }catch{}
        };

        try{ dlog('post -> uci'); sf.postMessage('uci'); }catch(e){ derr('post uci failed', e);}        
        // caller (enable) will set label to "loading"
        return true;
      }

      function go(fen){
        if(!active) return;
        if(!ensure()) return;
        curFen=fen; lines.clear(); clearUI();
        BOARD.arrows.engine=null; renderArrows();
        try{ curDepth = 0; updateMeta(); }catch{}

        // If not ready yet, queue this position to run immediately after 'readyok'
        if(!ready){
          queuedFen = fen;
          try{ sf.postMessage('uci'); }catch{}
          return;
        }

        pending=true;
        try{ dlog('post -> stop'); sf.postMessage('stop'); }catch(e){ derr('post stop failed', e); }
        dlog('post -> ucinewgame'); sf.postMessage('ucinewgame');
        dlog('post -> position fen', fen);
        sf.postMessage('position fen '+fen);
        dlog('post -> setoption Threads=1'); sf.postMessage('setoption name Threads value 1');
        dlog('post -> setoption MultiPV='+multiPV); sf.postMessage('setoption name MultiPV value '+multiPV);
        dlog('post -> go depth '+depth); sf.postMessage('go depth '+depth);
      }

      function analyzeDebounced(fen){
        if(!active) return;
        curFen=fen;
        clearTimeout(analyzeTimer);
        analyzeTimer=setTimeout(()=>go(fen), 200);
      }

      function enable(){
        active=true;
        setState('loading');
        dlog('enable');
        updateMeta();
        try{ evalBarVisible(true); updateEvalBar(EVALBAR.lastCpWhite||0); }catch{}
        const ok = ensure();
        if(ok && BOARD.current) analyzeDebounced(BOARD.current);
      }

      function disable(){
        active=false;
        dlog('disable');
        setState('off');
        lines.clear();
        clearUI();
        try{ dlog('post -> stop'); sf && sf.postMessage('stop'); }catch{}
        BOARD.arrows.engine=null; renderArrows();
        try{ evalBarVisible(false); }catch{}
        try{ curDepth=0; updateMeta(); }catch{}
      }

      // Small debug surface for manual testing from DevTools
      function ping(){ try{ ensure(); sf && sf.postMessage('uci'); setTimeout(()=>sf && sf.postMessage('isready'), 250); }catch(e){ derr('ping failed', e);} }
      try{ window.EngineLiveDebug = { ping, ensure: ()=>ensure(), post:(s)=>sf && sf.postMessage(String(s)) }; }catch{}
      function setMultiPV(n){
        multiPV = Math.max(1, Math.min(10, parseInt(n,10)||1));
        try{ localStorage.setItem(LS_ENG_PV, String(multiPV)); }catch{}
        updateMeta();
        try{ ensure(); if(ready) sf.postMessage('setoption name MultiPV value '+multiPV); if(active && curFen) analyzeDebounced(curFen); }catch{}
      }
      function setDepth(n){
        depth = Math.max(1, Math.min(100, parseInt(n,10)||depth));
        try{ localStorage.setItem(LS_ENG_DEPTH, String(depth)); }catch{}
        updateMeta();
        try{
          ensure();
          if(active && ready){ try{ sf.postMessage('stop'); }catch{} }
          if(active && curFen) analyzeDebounced(curFen);
        }catch{}
      }
      function getMultiPV(){ return multiPV; }
      function getDepth(){ return depth; }
      return { enable, disable, analyzeDebounced, setMultiPV, setDepth, getMultiPV, getDepth };
    })();
    async function analyzeOnServer(pgn, depth){
      const base=(window.SF_BACKEND_URL||'').replace(/\/$/,''); if(!base) throw new Error('SF_BACKEND_URL not set');
      const url=`${base}/analyze`;
      const thr=getSev();
      depth = parseInt(depth||window.getAnalysisDepth?.()||12,10)||12;
      const depthFast = (window.getFastDepth ? window.getFastDepth() : 12);
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({pgn,depth,thresholds:thr,depthFast})});
      if(!res.ok) throw new Error(`Stockfish backend error ${res.status}`);
      const data=await res.json(); const mistakes=data.mistakes||[];
      try{
        mistakes.forEach(m=>{ m.pgn=pgn; const h=parsePGNHeaders(pgn); const urlHdr=h.Site||h.Link||''; if(urlHdr && /^https?:\/\//i.test(urlHdr)) m.gameUrl=urlHdr; });
      }catch{}
      return mistakes;
    }

    // Server: fast pass only
    async function scanOnServer(pgn, depthFast){
      const base=(window.SF_BACKEND_URL||'').replace(/\/$/,''); if(!base) throw new Error('SF_BACKEND_URL not set');
      const url=`${base}/scan`;
      const thr=getSev();
      const dFast = parseInt(depthFast||window.getFastDepth?.()||12,10)||12;
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({pgn,depthFast:dFast,thresholds:thr})});
      if(!res.ok) throw new Error(`Stockfish scan error ${res.status}`);
      const data=await res.json();
      return Array.isArray(data.candidates)?data.candidates:[];
    }

    // Server: deep pass on candidates
    async function analyzeCandidatesOnServer(candidates, depth){
      const base=(window.SF_BACKEND_URL||'').replace(/\/$/,''); if(!base) throw new Error('SF_BACKEND_URL not set');
      const url=`${base}/analyzeCandidates`;
      const thr=getSev();
      const d = parseInt(depth||window.getAnalysisDepth?.()||12,10)||12;
      const res=await fetch(url,{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({candidates,depth:d,thresholds:thr})});
      if(!res.ok) throw new Error(`Stockfish analyzeCandidates error ${res.status}`);
      const data=await res.json();
      return Array.isArray(data.mistakes)?data.mistakes:[];
    }

    // NEW: keep a stacked list of imported games across sources
    window.importedGames = window.importedGames || []; // [{pgn, source, sel?:boolean}]
    function rebuildImportedTable(){
      const tb = $('#importTBody'); if(!tb) return;
      tb.innerHTML='';
      let i=0;
      try{
        LAST_ANALYZED = { mistakes: [], suggestedName: '' };
        const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo');
        if(btn){ btn.textContent = 'Create set (0 mistakes)'; }
        if(info){ info.textContent = '-'; }
      }catch{}
      // ensure selection defaults
      try{ (window.importedGames||[]).forEach(r=>{ if(r && typeof r.sel==='undefined') r.sel = true; }); }catch{}
      const list = (window.importedGames||[]).slice().sort((a,b)=> pgnTimeMs(b.pgn) - pgnTimeMs(a.pgn));
      for(const rec of list){
        const pgn = rec.pgn; const source=rec.source||'Imported';
        const h = parsePGNHeaders(pgn||'');
        const tr=document.createElement('tr');
        tr.innerHTML = `
          <td>${++i}</td>
          <td>${h.White||'-'}</td>
          <td>${h.Black||'-'}</td>
          <td>${h.Result||'-'}</td>
          <td>${h.Date||h.UTCDate||'-'}</td>
          <td>${source}</td>
          <td style="text-align:center"><input type="checkbox" class="impSel" data-pgn="${encodeURIComponent(pgn)}" ${rec.sel!==false?'checked':''} /></td>`;
        tr.style.cursor='pointer';
        tr.addEventListener('click', () => {
          Array.from(tb.querySelectorAll('tr')).forEach(r=>r.classList.remove('selected'));
          tr.classList.add('selected');
          // load game into viewer (mini-board)
          try{
            const cl = ChessLite(); cl.reset();
            const startFen = cl.fen();
            const mixed = cl.loadPGN(pgn);
            const fens = [startFen, ...mixed.filter(x=>x.san).map(x=>x.fenAfter)];
            GAMEVIEW.fens=fens; GAMEVIEW.idx=0; GAMEVIEW.total=fens.length-1; GAMEVIEW.pgn=pgn;
            // Orient from user's perspective if possible
            const side = userSideForPGN(pgn);
            const wb = side ? (side==='w') : true;
            GAMEVIEW.whiteBottom = wb;
            gvShow(); setTimeout(()=>{ drawBoardInto('gvBoard', fens[0], wb); gvUpdate(); }, 0);
            setStatus('Game loaded in viewer.');
          }catch(e){ console.warn('viewer load failed', e); }
        });
        tb.appendChild(tr);
      }
      // wire selection checkboxes
      try{
        tb.querySelectorAll('input.impSel').forEach(el=>{
          el.addEventListener('click', (ev)=>{ ev.stopPropagation(); });
          el.addEventListener('change', (ev)=>{
            const key = decodeURIComponent(ev.target.getAttribute('data-pgn')||'');
            const sel = !!ev.target.checked;
            const arr = window.importedGames || [];
            for(const r of arr){ if(r && r.pgn===key){ r.sel = sel; break; } }
          });
        });
      }catch{}
      const help = $('#importHelp');
      if(help){
        try{
          const total = window.importedGames.length;
          const chosen = (window.importedGames||[]).filter(r=>r && r.sel!==false).length;
          help.textContent = `${total} game(s) listed · ${chosen} selected. Click a row to preview.`;
        }catch{ help.textContent = `${window.importedGames.length} game(s) listed. Click a row to preview.`; }
      }
    }
    function appendImportedGames(pgns, source){
      const set = new Set((window.importedGames||[]).map(r=>r.pgn));
      for(const p of (pgns||[])){
        if(!p || set.has(p)) continue;
        window.importedGames.push({pgn:p, source:source||'Imported', sel:true});
      }
      try{ window._importsLocalBump = Date.now(); }catch{}
      try{ if(fb()) fb().appendImports(pgns, source).catch(()=>{}); }catch{}
      rebuildImportedTable();
    }

    async function analyzeImportedWithBackendAbortable(state){
      const imported = window.importedGames || [];
      const list = imported.filter(x => x && x.sel!==false).map(x => x.pgn);
      if(!list.length){ alert('No imported games found. Import games first.'); return; }
      inferUsernames();
      const all=[];
      let i=0;
      let phaseTimer = null;
      for(const pgn of list){
        if(state.stop) break;
        try{
          const fastDepth = (window.getFastDepth ? window.getFastDepth() : 12);
          setStatus(`Fast pass at depth: ${fastDepth} — Game ${i+1}/${list.length}`);
          setMistakeCounter(all.length);
          try{
            const deep = parseInt(window.getAnalysisDepth?.()||12,10)||12;
            if(phaseTimer) { clearTimeout(phaseTimer); phaseTimer = null; }
            phaseTimer = setTimeout(()=>{ try{ setStatus(`Deep analysis at depth: ${deep} - Game ${i+1}/${list.length}`); }catch{} }, 1500);
          }catch{}
        }catch{}
        setStatus(`Analyzing ${++i}/${list.length} â€” mistakes found: ${all.length}`);
        try{
          let ms=[];
          if(window.SF_BACKEND_URL){
            try{ ms=await analyzeOnServer(pgn, window.getAnalysisDepth ? window.getAnalysisDepth() : 12); }
            catch(err){
              console.warn('Analyze via SF backend failed, falling back', err);
              if(window.FN_BASE){
                try{ ms=await analyzeOnBackend([pgn]); }
                catch(err2){ console.warn('Analyze via Functions failed, falling back to local', err2); ms=await analyzeManualLocal(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; setStatus(`Analyzing ${i}/${list.length} â€” mistakes found: ${all.length}`); }catch{} }); }
              } else {
                ms=await analyzeManualLocal(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; setStatus(`Analyzing ${i}/${list.length} â€” mistakes found: ${all.length}`); }catch{} });
              }
            }
          }
          else if(window.FN_BASE){ ms=await analyzeOnBackend([pgn]); }
          else { ms = await analyzeManualLocal(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; setStatus(`Analyzing ${i}/${list.length} â€” mistakes found: ${all.length}`); }catch{} }); }

          // Ensure PGN and game URL are attached regardless of backend
          try{
            const hdr = parsePGNHeaders(pgn);
            const urlHdr = hdr.Site || hdr.Link || '';
            ms.forEach(m => {
              if(!m.pgn) m.pgn = pgn;
              if(!m.gameUrl && urlHdr && /^https?:\/\//i.test(urlHdr)) m.gameUrl = urlHdr;
            });
          }catch{}

          // Update status: deep analysis phase for this game
          try{ if(phaseTimer){ clearTimeout(phaseTimer); phaseTimer=null; } }catch{}
          try{
            const deep = parseInt(window.getAnalysisDepth?.()||12,10)||12;
            setStatus(`Deep analysis at depth: ${deep} - Game ${i}/${list.length}`);
            await sleep(20);
          }catch{}

          // Apply user and severity filters
          ms = filterMistakesToUserOnly(ms).filter(m => (window.includeSeverity ? window.includeSeverity(m.severity) : true));
          if(ms.length){
            for(const m of ms){
              all.push(m);
              LAST_ANALYZED.mistakes = all.slice();
              try{ setMistakeCounter(all.length); }catch{}
              try{
                const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`;
                setStatus(`Analyzing ${i}/${list.length} â€” mistakes found: ${all.length}`);
              }catch{}
            }
          }
        }catch(e){ console.warn('Analyze failed:', e); }
      }
      if(all.length) addMistakes(all);

      const srcSet = new Set(imported.map(x => x.source || 'Imported'));
      const tagBase = (srcSet.size===1 ? Array.from(srcSet)[0] : 'Imported');
      const tagName = `${tagBase}${state.stop ? ' (partial)' : ''} ${new Date().toLocaleString()}`;

      // Cache last analyzed results for manual set creation and show button
      LAST_ANALYZED = { mistakes: all.slice(), suggestedName: tagName };
      try{
        const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo');
        if(btn){ btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; }
        if(info) info.textContent = all.length>0 ? `Ready: ${all.length} mistake(s) detected in last analysis.` : '-';
      }catch{}

      if(state.stop){
        setStatus(`Analysis stopped â€” mistakes found: ${all.length}`);
      }else{
        setStatus(`Done. Added ${all.length} user-mistake(s).`);
      }
    }

    // New two-step analyzer that uses backend scan + deep endpoints when available
    async function analyzeImportedWithBackendAbortable2(state){
      const imported = window.importedGames || [];
      const list = imported.filter(x => x && x.sel!==false).map(x => x.pgn);
      if(!list.length){ alert('No imported games found. Import games first.'); return; }
      inferUsernames();
      const all=[];
      let i=0;
      for(const pgn of list){
        if(state.stop) break;
        const idx = i+1;
        const fastDepth = (window.getFastDepth ? window.getFastDepth() : 12);
        setStatus(`Fast pass at depth: ${fastDepth} - Game ${idx}/${list.length}`);
        setMistakeCounter(all.length);
        let ms=[];
        try{
          if(window.SF_BACKEND_URL){
            let candidates=[];
            try{ candidates = await scanOnServer(pgn, fastDepth); }
            catch(e){ console.warn('scan failed; fallback to /analyze', e); ms = await analyzeOnServer(pgn, window.getAnalysisDepth ? window.getAnalysisDepth() : 12); }
            if(!ms.length && Array.isArray(candidates)){
              const deep = parseInt(window.getAnalysisDepth?.()||12,10)||12;
              setStatus(`Deep analysis at depth: ${deep} - Game ${idx}/${list.length}`);
              ms = await analyzeCandidatesOnServer(candidates, deep);
            }
          } else if(window.FN_BASE){
            ms = await analyzeOnBackend([pgn]);
          } else {
            ms = await analyzeManualLocal(pgn, (m)=>{ all.push(m); LAST_ANALYZED.mistakes = all.slice(); try{ setMistakeCounter(all.length); }catch{} });
          }
        }catch(e){ console.warn('Analyze failed:', e); }

        // Attach PGN and URL
        try{
          const hdr = parsePGNHeaders(pgn);
          const urlHdr = hdr.Site || hdr.Link || '';
          (ms||[]).forEach(m => { if(!m.pgn) m.pgn = pgn; if(!m.gameUrl && urlHdr && /^https?:\/\//i.test(urlHdr)) m.gameUrl = urlHdr; });
        }catch{}

        // Filter and accumulate
        ms = filterMistakesToUserOnly(ms).filter(m => (window.includeSeverity ? window.includeSeverity(m.severity) : true));
        for(const m of (ms||[])){
          all.push(m); LAST_ANALYZED.mistakes = all.slice();
          try{ setMistakeCounter(all.length); }catch{}
          try{ const btn=$('#btnCreateSetFromLast'); if(btn) btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; }catch{}
        }
        i++;
      }
      if(all.length) addMistakes(all);

      const srcSet = new Set(imported.map(x => x.source || 'Imported'));
      const tagBase = (srcSet.size===1 ? Array.from(srcSet)[0] : 'Imported');
      const tagName = `${tagBase}${state.stop ? ' (partial)' : ''} ${new Date().toLocaleString()}`;
      LAST_ANALYZED = { mistakes: all.slice(), suggestedName: tagName };
      try{ const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo'); if(btn){ btn.textContent = `Create set (${all.length} mistake${all.length!==1?'s':''})`; } if(info) info.textContent = all.length>0 ? `Ready: ${all.length} mistake(s) detected in last analysis.` : '-'; }catch{}

      setStatus(state.stop ? 'Analysis stopped' : 'Analysis finished');
    }

    // Local fallback (two-pass)
    async function analyzeManualLocal(pgn, onFound){
      const clRead = ChessLite();
      const seq = clRead.loadPGN(pgn).filter(x=>x.san);
      const game = ChessLite(); game.reset();
      const mistakes = [];
      const sideWanted = userSideForPGN(pgn);
      const depth = parseInt(window.getAnalysisDepth?.()||12,10)||12;
      const depthFast = (window.getFastDepth ? parseInt(window.getFastDepth(),10)||12 : 12);

      // Pass 1: shallow scan to find candidates
      const candidates = [];
      for(const mv of seq){
        const fenBefore = game.fen();
        const side = game.turn();
        if(sideWanted && side !== sideWanted){
          const skipUci = game.parseSANtoMove(mv.san); if(skipUci) game.moveUci(skipUci);
          continue;
        }
        const { cp: cpBefore1, bestmove: best1 } = await Engine.analyze(fenBefore, depthFast);
        const playedUci = game.parseSANtoMove(mv.san); if(!playedUci) continue;
        game.moveUci(playedUci);
        const fenAfter = game.fen();
        if(playedUci === best1) { continue; }
        const { cp: cpAfter1 } = await Engine.analyze(fenAfter, depthFast);
        const drop1 = Math.max(0, cpBefore1 + cpAfter1);
        if(severityFromDrop(drop1)){
          candidates.push({ fenBefore, fenAfter, side, san: mv.san, uci: playedUci });
        }
      }

      // Pass 2: deep analysis on candidates only
      try{ setStatus(`Deep analysis at depth: ${depth}`); await sleep(10); }catch{}
      for(const c of candidates){
        const { cp: cpBefore2, bestmove: best2 } = await Engine.analyze(c.fenBefore, depth);
        if(c.uci === best2) { continue; }
        const { cp: cpAfter2 } = await Engine.analyze(c.fenAfter, depth);
        const drop2 = Math.max(0, cpBefore2 + cpAfter2);
        const sev2 = severityFromDrop(drop2);
        const include = (window.includeSeverity ? window.includeSeverity(sev2) : true);
        if(sev2 && include){
          const m = { id:uid(), fen:c.fenBefore, side:c.side, played:c.san, best:best2, deltaCp:drop2, severity:sev2, nextReview:nowTs(), ef:2.5, reps:0, interval:0, pgn };
          mistakes.push(m);
          try{ if(typeof onFound==='function') onFound(m); }catch{}
        }
      }
      return mistakes;
    }

    /********************************************************************
     * Importers
     ********************************************************************/
    async function fetchLichess(user, maxN){
      const n=Math.max(1, Math.min(50, parseInt(maxN,10)||5));
      const base=(window.FN_LICHESS_URL||`${window.FN_BASE||''}/fetchLichess`).replace(/\/$/,'');
      const url=`${base}?username=${encodeURIComponent(user)}&max=${n}`;
      const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error(`Lichess proxy failed (${res.status})`);
      const json=await res.json();
      let games=(json.games||[]).filter(g=>g&&g.pgn);
      // Ensure newest-first and limit to last N
      games.sort((a,b)=>((b.lastMoveAt||b.createdAt||0) - (a.lastMoveAt||a.createdAt||0)));
      games = games.slice(0, n);
      const out=games.map(g=>g.pgn);
      appendImportedGames(out,'Lichess'); return out;
    }

    async function fetchChesscom(user, maxN){
      const n=Math.max(1, Math.min(50, parseInt(maxN,10)||5));
      const base=(window.FN_CHESSCOM_URL||`${window.FN_BASE||''}/fetchChessCom`).replace(/\/$/,'');
      const url=`${base}?username=${encodeURIComponent(user)}&limit=${n}`;
      const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error(`Chess.com proxy failed (${res.status})`);
      const json=await res.json();
      let games=(json.games||[]).filter(g=>g&&g.pgn);
      // Ensure newest-first and limit to last N
      games.sort((a,b)=>((b.end_time||0)-(a.end_time||0)));
      games = games.slice(0, n);
      const out=games.map(g=>g.pgn);
      appendImportedGames(out,'Chess.com'); return out;
    }

    // List-only versions (do not mutate Imported Games). Used by unified import.
    async function fetchLichessList(user, maxN){
      const n=Math.max(1, Math.min(50, parseInt(maxN,10)||5));
      const base=(window.FN_LICHESS_URL||`${window.FN_BASE||''}/fetchLichess`).replace(/\/$/,'');
      const url=`${base}?username=${encodeURIComponent(user)}&max=${n}`;
      const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error(`Lichess proxy failed (${res.status})`);
      const json=await res.json();
      let games=(json.games||[]).filter(g=>g&&g.pgn);
      games.sort((a,b)=>((b.lastMoveAt||b.createdAt||0) - (a.lastMoveAt||a.createdAt||0)));
      games = games.slice(0, n);
      return games.map(g=>g.pgn);
    }

    async function fetchChesscomList(user, maxN){
      const n=Math.max(1, Math.min(50, parseInt(maxN,10)||5));
      const base=(window.FN_CHESSCOM_URL||`${window.FN_BASE||''}/fetchChessCom`).replace(/\/$/,'');
      const url=`${base}?username=${encodeURIComponent(user)}&limit=${n}`;
      const res=await fetch(url,{headers:{'Accept':'application/json'}}); if(!res.ok) throw new Error(`Chess.com proxy failed (${res.status})`);
      const json=await res.json();
      let games=(json.games||[]).filter(g=>g&&g.pgn);
      games.sort((a,b)=>((b.end_time||0)-(a.end_time||0)));
      games = games.slice(0, n);
      return games.map(g=>g.pgn);
    }

  /********************************************************************
   * Unified Import UI logic
   ********************************************************************/
  function getPrefs(){ try{ return JSON.parse(localStorage.getItem('pmtt_prefs')||'{}'); }catch{return {}} }
  function savePrefsLocal(p){ try{ const cur=getPrefs(); localStorage.setItem('pmtt_prefs', JSON.stringify({...cur, ...p})); }catch{} }
  function applyPrefsToUI(){
    try{
      const p=getPrefs();
      if($('#provLichess')) $('#provLichess').checked = (p.provLichess!==false);
      if($('#provChesscom')) $('#provChesscom').checked = (p.provChesscom!==false);
      if($('#modeTime')) $('#modeTime').checked = (p.importMode==='time');
      if($('#modeCount')) $('#modeCount').checked = (p.importMode!=='time');
      if($('#importCount')) $('#importCount').value = String(p.importCount||10);
      if($('#importCount2')) $('#importCount2').value = String(p.importCount||10);
      const pv = document.getElementById('periodValue'); if(pv) pv.value = String(p.periodValue ?? 30);
      const pu = document.getElementById('periodUnit'); if(pu) pu.value = p.periodUnit || 'days';
      if($('#accLichess')) $('#accLichess').value = p.lichessUser||'';
      if($('#accChessCom')) $('#accChessCom').value = p.chesscomUser||'';
      if($('#lichessUser')) $('#lichessUser').value = p.lichessUser||'';
      if($('#chesscomUser')) $('#chesscomUser').value = p.chesscomUser||'';
      if($('#modeTime') && $('#modeTime').checked){ $('#periodWrap').style.display='block'; $('#countWrap2').style.display='none'; }
      else { if($('#periodWrap')) $('#periodWrap').style.display='none'; if($('#countWrap2')) $('#countWrap2').style.display='block'; }
    }catch{}
  }
  try{ window.getPrefs = getPrefs; window.savePrefsLocal = savePrefsLocal; window.applyPrefsToUI = applyPrefsToUI; }catch{}

    function periodMsFromControls(){
      try{
        const valStr = (document.getElementById('periodValue')?.value || '0').trim();
        let v = parseFloat(valStr); if(!isFinite(v) || v < 0) v = 0;
        const unit = (document.getElementById('periodUnit')?.value || 'days');
        const msPer = { minutes:60*1000, hours:3600*1000, days:24*3600*1000, weeks:7*24*3600*1000, months:30*24*3600*1000 };
        const mult = msPer[unit] || msPer.days;
        return v * mult;
      }catch{ return 30*24*3600*1000; }
    }

  async function importUnified(){
    const provL = !!($('#provLichess') && $('#provLichess').checked);
    const provC = !!($('#provChesscom') && $('#provChesscom').checked);
    if(!provL && !provC){ alert('Select at least one provider'); return; }
    const modeTime = !!($('#modeTime') && $('#modeTime').checked);
    const count = Math.max(1, parseInt($('#importCount2')?.value||$('#importCount')?.value||'10',10)||10);
    const period = null; // deprecated; use periodValue + periodUnit
    const lichUser = ($('#accLichess')?.value||$('#lichessUser')?.value||'').trim();
    const chessUser = ($('#accChessCom')?.value||$('#chesscomUser')?.value||'').trim();
    const prefs = { provLichess:provL, provChesscom:provC, importMode: modeTime?'time':'count', importCount:count, periodValue: parseFloat(document.getElementById('periodValue')?.value||'30')||30, periodUnit: (document.getElementById('periodUnit')?.value||'days'), lichessUser:lichUser, chesscomUser:chessUser };
    try { (window.savePrefsLocal||savePrefsLocal)(prefs); } catch {}
    try{ if(fb()) fb().savePrefs(prefs).catch(()=>{}); }catch{}
    if(provL && !lichUser){ alert('Enter your Lichess username in Settings'); return; }
    if(provC && !chessUser){ alert('Enter your Chess.com username in Settings'); return; }
    setStatus('Fetching games...');
    const jobs = [];
    if(modeTime){
      const want = 200; // generous upper bound per provider
      if(provL) jobs.push(fetchLichessList(lichUser, want).then(arr=>arr.map(p=>({pgn:p, src:'Lichess'}))).catch(()=>[]));
      if(provC) jobs.push(fetchChesscomList(chessUser, want).then(arr=>arr.map(p=>({pgn:p, src:'Chess.com'}))).catch(()=>[]));
    } else {
      const want = Math.max(1, count); // fetch N from each selected provider (list-only)
      if(provL) jobs.push(fetchLichessList(lichUser, want).then(arr=>arr.map(p=>({pgn:p, src:'Lichess'}))).catch(()=>[]));
      if(provC) jobs.push(fetchChesscomList(chessUser, want).then(arr=>arr.map(p=>({pgn:p, src:'Chess.com'}))).catch(()=>[]));
    }
    const results = (await Promise.all(jobs)).flat();
    const withTs = results.map(r=>({ ...r, ms: pgnTimeMs(r.pgn) || 0 }));
    let chosen=[];
    if(modeTime){ const since = Date.now() - periodMsFromControls();
      chosen = withTs.filter(r=>r.ms>=since).sort((a,b)=>b.ms-a.ms);
    } else {
      chosen = withTs.sort((a,b)=>b.ms-a.ms).slice(0, count);
    }
    const gL=[], gC=[]; for(const r of chosen){ if(r.src==='Lichess') gL.push(r.pgn); else if(r.src==='Chess.com') gC.push(r.pgn); }
    if(gL.length) appendImportedGames(gL,'Lichess');
    if(gC.length) appendImportedGames(gC,'Chess.com');
    setStatus('Idle');
  }
  try{ window.importUnified = importUnified; }catch{}

    /********************************************************************
     * Trainer session + SM-2
     ********************************************************************/
    let ORIENT_WHITE_BOTTOM = true;

    function pickDueSRS(){
      let list = loadMistakes();
      if(ACTIVE_SET_KEYS && ACTIVE_SET_KEYS.size){
        list = list.filter(m => {
          const ks = keysForMistake(m);
          for(const k of ks){ if(ACTIVE_SET_KEYS.has(k)) return true; }
          return false;
        });
      }
      const now = nowTs(); return list.filter(m => (m.nextReview||0) <= now);
    }

    function sm2Update(m, quality){
      m.ef = m.ef ?? 2.5; m.reps = m.reps ?? 0; m.interval = m.interval ?? 0;
      const q = clamp(quality, 0, 5);
      m.ef = m.ef + (0.1 - (5-q)*(0.08 + (5-q)*0.02)); m.ef = Math.max(1.3, m.ef);
      if(q<3){ m.reps=0; m.interval=1; }
      else{ m.reps+=1; if(m.reps===1)m.interval=1; else if(m.reps===2)m.interval=6; else m.interval=Math.round(m.interval*m.ef); }
      m.nextReview = nowTs() + days(m.interval||1);
    }

    const Session = (() => {
      let queue=[]; let mode='srs'; let active=null; let pendingFirstTry=true;

      function startWoodpecker(N){
        let list = loadMistakes().slice();
        if(ACTIVE_SET_KEYS && ACTIVE_SET_KEYS.size){
          list = list.filter(m => {
            const ks = keysForMistake(m);
            for(const k of ks){ if(ACTIVE_SET_KEYS.has(k)) return true; }
            return false;
          });
        }
        list.sort((a,b) => {
          const rank = s => s==='blunder'?3 : s==='mistake'?2 : s==='inaccuracy'?1 : 0;
          const d = rank(b.severity) - rank(a.severity); if(d) return d;
          return (b.deltaCp||0) - (a.deltaCp||0);
        });
        queue = list.slice(0, Math.max(1,N)).map(m=>({...m}));
        mode='woodpecker'; next();
      }
      function startSRS(){ queue = pickDueSRS(); mode='srs'; next(); }
      function next(){
      $('#yourMove').textContent='-'; $('#feedback').textContent='-';
      try{
        const cpl = formatCentipawnLoss(m.deltaCp);
        $('#mInfo').innerHTML = `<span class="pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}">${m.severity}</span> Â· centipawn loss: ${cpl}`;
      }catch{}
      try{
        const cpl = formatCentipawnLoss(m.deltaCp);
        $('#mInfo').innerHTML = `<span class="pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}">${m.severity}</span> Â· centipawn loss: ${cpl}`;
      }catch{}
        // clear arrows
        BOARD.arrows.user = null; BOARD.arrows.best = null; BOARD.arrows.showBest=false; renderArrows();
        try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
        if(queue.length===0){
          if(mode==='srs'){ queue = pickDueSRS(); if(queue.length===0){ $('#mInfo').textContent='No SRS items due now. ??'; active=null; drawBoardMain(null); return; } }
          else { $('#mInfo').textContent='Woodpecker set complete. ?'; active=null; drawBoardMain(null); return; }
        }
        active = queue.shift(); pendingFirstTry=true; loadMistakeOnBoard(active);
      }
      function answer(moveUci){
        if(!active) return;
        const correct = (moveUci === (active.best||''));
        const yourSan = uciToSAN(active.fen, moveUci);
        $('#yourMove').textContent = yourSan || moveUci || 'â€”';

        // Do not auto-draw last-move arrow; keep arrows clear
        BOARD.arrows.user = null; BOARD.arrows.showBest=false; renderArrows();

        // Move the board tentatively so user can see result
        const tmp=ChessLite(); tmp.loadFEN(BOARD.current); const mv=tmp.moveUci(moveUci);
        if(mv.ok){ drawBoardMain(tmp.fen()); }

        if(correct){
          $('#feedback').innerHTML = '?? Correct (best move)';
          const list = loadMistakes(); const idx=list.findIndex(m=>m.id===active.id);
          if(idx>=0){ const q=(mode==='srs') ? (pendingFirstTry?5:3) : (pendingFirstTry?5:4); sm2Update(list[idx], q); saveMistakes(list); }
          logAttempt(active.id, true, moveUci);
          // DO NOT auto-advance; user presses Next
        }else{
          const bestSan = uciToSAN(active.fen, active.best);
          $('#feedback').innerHTML = `? Not the best. <span class="mono">Best = ${bestSan || active.best}</span>`;
          logAttempt(active.id, false, moveUci);
          pendingFirstTry=false;
          if(mode==='woodpecker') queue.push(active);
        }
      }
      return { startWoodpecker, startSRS, next, answer, get active(){return active;} }
    })();

    /********************************************************************
     * Board rendering + arrows + DnD
     ********************************************************************/
    const VS15 = '\uFE0E'; // force text (non-emoji) glyphs
    const PIECES = {
      'P':'?'+VS15,'N':'?'+VS15,'B':'?'+VS15,'R':'?'+VS15,'Q':'?'+VS15,'K':'?'+VS15,
      'p':'?'+VS15,'n':'?'+VS15,'b':'?'+VS15,'r':'?'+VS15,'q':'?'+VS15,'k':'?'+VS15
    };
    const BOARD = { current:null, selected:null, highlights:new Set(), chess:ChessLite(), arrows:{ user:null, best:null, engine:null, showBest:false }, lastFromTo:null };
    const CB = { main:null, extras:{} };
    // Evaluation bar state
    const EVALBAR = { lastCpWhite: 0 };

    function ensureEvalBar(){ try{ const bar=document.getElementById('evalBar'); if(!bar) return null; const outer=document.getElementById('trainBoard'); if(!outer) return bar; const r=outer.getBoundingClientRect(); bar.style.height = r.height+'px'; return bar; }catch{ return null; } }
    function evalBarVisible(on){ const bar=ensureEvalBar(); if(!bar) return; bar.style.display = on ? 'block' : 'none'; }
    // White-centric proportion of the bar (0..1); 0.5 = equal
    function cpToPercentWhite(cpWhite){ const RANGE=1000; let p = 0.5 + (Math.max(-RANGE, Math.min(RANGE, cpWhite)) / (2*RANGE)); return Math.max(0, Math.min(1, p)); }
    function updateEvalBar(cpWhite){
      EVALBAR.lastCpWhite = cpWhite;
      const bar=ensureEvalBar(); if(!bar) return;
      const fill=bar.querySelector('.eval-fill'); if(!fill) return;
      const p = cpToPercentWhite(cpWhite);
      // Height reflects white advantage proportion; anchor to the side of the white pieces
      fill.style.height = Math.round(p*100)+'%';
      if(ORIENT_WHITE_BOTTOM){ fill.style.bottom = '0'; fill.style.top = ''; }
      else { fill.style.top = '0'; fill.style.bottom = ''; }
    }

    function ensureArrowCanvas(){
      const outer = document.getElementById('trainBoard'); if(!outer) return null;
      let cv = document.getElementById('boardArrows');
      if(!cv){ cv=document.createElement('canvas'); cv.id='boardArrows'; Object.assign(cv.style,{position:'absolute', inset:'0', pointerEvents:'none'}); outer.appendChild(cv); }
      const rect = outer.getBoundingClientRect();
      const dpr = Math.min(2, (window.devicePixelRatio || 1));
      cv.width = Math.max(1, Math.floor(rect.width*dpr)); cv.height = Math.max(1, Math.floor(rect.height*dpr)); cv.style.width=rect.width+'px'; cv.style.height=rect.height+'px';
      try{ const bar=document.getElementById('evalBar'); if(bar){ bar.style.height = rect.height+'px'; } }catch{}
      return { cv, dpr, rect };
    }
    function sqCenterPx(sq, rectW, rectH, dpr){
      const files='abcdefgh'; const f=files.indexOf(sq[0]); const r=parseInt(sq[1],10)-1;
      let col=f, row=7-r;
      if(!ORIENT_WHITE_BOTTOM){ col=7-col; row=7-row; }
      const cellW=rectW/8, cellH=rectH/8; return { x:dpr*((col+0.5)*cellW), y:dpr*((row+0.5)*cellH) };
    }
    function drawArrow(ctx,dpr,from,to,color, dashed){
      const outer=document.getElementById('trainBoard'); if(!outer) return;
      const rect=outer.getBoundingClientRect();
      const a=sqCenterPx(from, rect.width, rect.height, dpr);
      const b=sqCenterPx(to, rect.width, rect.height, dpr);
      ctx.save();
      if(dashed && ctx.setLineDash) ctx.setLineDash([10*dpr, 8*dpr]);
      // Make arrows semi-transparent regardless of dashed/solid
      ctx.globalAlpha = 0.7;
      ctx.strokeStyle=color; ctx.fillStyle=color; ctx.lineWidth=6*dpr; ctx.lineCap='round'; ctx.lineJoin='round';
      // Compute arrowhead geometry and shorten shaft so tip sits at the end
      const ang=Math.atan2(b.y-a.y,b.x-a.x);
      const ux=Math.cos(ang), uy=Math.sin(ang);
      const headLen=18*dpr; // longer head
      const headWidth=16*dpr; // wider head
      const bx=b.x-ux*headLen, by=b.y-uy*headLen; // shaft end (base of head)
      const px=-uy, py=ux; // unit perpendicular
      const lx=bx+px*(headWidth/2), ly=by+py*(headWidth/2);
      const rx=bx-px*(headWidth/2), ry=by-py*(headWidth/2);
      // Draw shaft only up to base of head
      ctx.beginPath(); ctx.moveTo(a.x,a.y); ctx.lineTo(bx,by); ctx.stroke();
      // Draw head with tip exactly at b
      ctx.beginPath(); ctx.moveTo(b.x,b.y); ctx.lineTo(lx,ly); ctx.lineTo(rx,ry); ctx.closePath(); ctx.fill();
      ctx.restore();
    }
    function renderArrows(){
      const info=ensureArrowCanvas(); if(!info) return;
      const {cv,dpr}=info; const ctx=cv.getContext('2d'); if(!ctx) return; ctx.clearRect(0,0,cv.width,cv.height);
      const red = getComputedStyle(document.documentElement).getPropertyValue('--arrow-user').trim()||'#ff5c5c';
      const green = getComputedStyle(document.documentElement).getPropertyValue('--arrow-best').trim()||'#2ecc71';
      const cyan = getComputedStyle(document.documentElement).getPropertyValue('--arrow-engine').trim()||'#00bcd4';
      const u=BOARD.arrows.user; if(u){ drawArrow(ctx,dpr,u.slice(0,2),u.slice(2,4),red,false); }
      const b=BOARD.arrows.best; if(b && BOARD.arrows.showBest){ drawArrow(ctx,dpr,b.slice(0,2),b.slice(2,4),green,false); }
      const e=BOARD.arrows.engine; if(e){ drawArrow(ctx,dpr,e.slice(0,2),e.slice(2,4),cyan,false); }
    }

    function drawBoardInto(rootId, fen, whiteBottom){
      const el = document.getElementById(rootId); if(!el) return;
      if(!CB.extras[rootId]){
        CB.extras[rootId] = Chessboard(el, {
          draggable: false,
          showNotation: false,
          orientation: (whiteBottom ? 'white' : 'black'),
          position: fen || 'empty',
          pieceTheme: '/chessboardjs/img/chesspieces/wikipedia/{piece}.png',
          onMoveEnd: (oldPos, newPos) => { highlightLastMoveFromDiff(`#${rootId}`, oldPos, newPos); }
        });
      } else {
        CB.extras[rootId].orientation(whiteBottom ? 'white' : 'black');
        if(!fen) CB.extras[rootId].clear(true); else CB.extras[rootId].position(fen, false);
      }
      clearLastMoveHighlights(`#${rootId}`);
      // Ensure layout after visibility changes (e.g., viewer toggled)
      try { CB.extras[rootId].resize(); } catch {}
      setTimeout(()=>{ try{ CB.extras[rootId].resize(); }catch{} }, 0);
      setBoardFonts();
    }

    function setBoardFonts(){ renderArrows(); }

    // Last-move highlight helpers (for chessboard.js boards)
    function clearLastMoveHighlights(rootSel){
      try{ document.querySelectorAll(`${rootSel} [data-square].last-move`).forEach(el=>el.classList.remove('last-move')); }catch{}
    }
    function addLastMoveSquare(rootSel, sq){
      try{ const el = document.querySelector(`${rootSel} [data-square="${sq}"]`); if(el) el.classList.add('last-move'); }catch{}
    }
    function highlightLastMoveFromDiff(rootSel, oldPos, newPos){
      try{
        const o = oldPos||{}; const n = newPos||{};
        const squares = new Set([...Object.keys(o), ...Object.keys(n)]);
        const fromCandidates=[], toCandidates=[];
        for(const s of squares){
          const ov=o[s], nv=n[s];
          if(ov===nv) continue;
          if(ov && !nv) { fromCandidates.push(s); continue; }
          if(!ov && nv) { toCandidates.push(s); continue; }
          // changed piece (capture, move into occupied, etc.) => count as both
          fromCandidates.push(s); toCandidates.push(s);
        }
        let from=null, to=null;
        if(fromCandidates.length===1 && toCandidates.length===1){ from=fromCandidates[0]; to=toCandidates[0]; }
        else{
          // try pair by color/type similarity
          let best=null;
          for(const t of toCandidates){
            const np=n[t]; if(!np) continue;
            for(const f of fromCandidates){
              const op=o[f]; if(!op) continue;
              const sameColor = np[0]===op[0];
              const sameType  = np[1]===op[1];
              const score = (sameColor?1:0)+(sameType?2:0);
              const isKingDest = np && (np[1]==='K' || np[1]==='k');
              if(!best || score>best.score || (score===best.score && isKingDest)) best={from:f,to:t,score};
            }
          }
          if(best){ from=best.from; to=best.to; }
          else { from=fromCandidates[0]||null; to=toCandidates[0]||null; }
        }
        clearLastMoveHighlights(rootSel);
        if(from) addLastMoveSquare(rootSel, from);
        if(to) addLastMoveSquare(rootSel, to);
      }catch{}
    }

    function ensureMainBoard(){
      if(CB.main) return CB.main;
      const el = document.getElementById('board'); if(!el) return null;
      CB.main = Chessboard(el, {
        draggable: true,
        showNotation: false,
        orientation: ORIENT_WHITE_BOTTOM ? 'white' : 'black',
        position: 'empty',
        pieceTheme: '/chessboardjs/img/chesspieces/wikipedia/{piece}.png',
        onMoveEnd: (oldPos, newPos) => {
          // After animation, mark last moved squares
          highlightLastMoveFromDiff('#board', oldPos, newPos);
        },
        // Defer DOM sync until after snap completes to avoid ghost piece
        onSnapEnd: () => {
          try{
            CB.main.orientation(ORIENT_WHITE_BOTTOM ? 'white' : 'black');
            CB.main.position(BOARD.current || 'start', false);
            // Re-apply last-move square highlights after DOM sync
            clearLastMoveHighlights('#board');
            const lm = BOARD.lastFromTo; if(lm){ addLastMoveSquare('#board', lm.from); addLastMoveSquare('#board', lm.to); }
          }catch{}
        },
        onDragStart: (source, piece) => {
          try{
            const turn = BOARD.chess.turn();
            if((turn==='w' && piece[0] !== 'w') || (turn==='b' && piece[0] !== 'b')) return false;
          }catch{}
          return true;
        },
        onDrop: (source, target, piece, newPos, oldPos) => {
          try{
            if(source===target) return 'snapback';
            let uci = source + target;
            try{
              const legal = BOARD.chess.moves().filter(m=>m.from===source && m.to===target);
              if(legal.length){ let move=legal[0]; const q=legal.find(m=>m.promotion==='q'); if(q) move=q; if(move.promotion) uci+=move.promotion; }
            }catch{}
            const tmp=ChessLite(); tmp.loadFEN(BOARD.current); const mv=tmp.moveUci(uci);
            if(!mv.ok) return 'snapback';
            const nextFen = tmp.fen();
            BOARD.chess.loadFEN(nextFen); BOARD.current=nextFen;
            // Remember last move squares for highlight re-application
            BOARD.lastFromTo = { from: source, to: target };
            try{ if($('#engineToggle')?.checked) EngineLive.analyzeDebounced(nextFen); }catch{}
            try{ $('#sideToMove').textContent = BOARD.chess.turn()==='w'?'White':'Black'; }catch{}
            try{ const fenEl=$('#trainFen'); if(fenEl) fenEl.textContent = `FEN: ${nextFen}`; }catch{}
            BOARD.arrows.showBest=false; BOARD.arrows.user=null; renderArrows();
            try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
            try{ Session.answer(uci); }catch{}
          }catch(e){
            try{ console && console.warn && console.warn('onDrop error', e); }catch{}
            return 'snapback';
          }
        }
      });
      return CB.main;
    }

    function drawBoardMain(fen){
      const board = ensureMainBoard(); if(!board) return;
      if(!fen){
        try{ const fenEl=$('#trainFen'); if(fenEl) fenEl.textContent='FEN: -'; }catch{}
        BOARD.current=null;
        BOARD.arrows.engine=null; try{ const el=$('#engineLines'); if(el) el.textContent=''; }catch{}
        board.clear(true);
        clearLastMoveHighlights('#board');
        setBoardFonts(); renderArrows(); return;
      }
      BOARD.chess.loadFEN(fen); BOARD.current=fen; $('#sideToMove').textContent = BOARD.chess.turn()==='w'?'White':'Black';
      try{ const fenEl = $('#trainFen'); if(fenEl) fenEl.textContent = `FEN: ${fen}`; }catch{}
      board.orientation(ORIENT_WHITE_BOTTOM ? 'white' : 'black');
      board.position(fen, false);
      clearLastMoveHighlights('#board');
      try{ board.resize(); }catch{}
      BOARD.selected=null; BOARD.highlights.clear(); setBoardFonts(); renderArrows();
      try{ updateEvalBar(EVALBAR.lastCpWhite||0); }catch{}
      try{ if($('#engineToggle')?.checked) EngineLive.analyzeDebounced(fen); }catch{}
    }

    function showHints(){
      $$('#board .sq').forEach(el=>el.classList.remove('sel','hl','hint'));
      if(!BOARD.current) return;
      const legal=BOARD.chess.moves();
      if(BOARD.selected!==null){
        const fromSq=BOARD.chess.idxToSq(BOARD.selected);
        $$('#board .sq').forEach(el=>{ if(parseInt(el.dataset.index,10)===BOARD.selected) el.classList.add('sel'); });
        for(const m of legal){ if(m.from===fromSq){ const el=$(`#board .sq[data-square="${m.to}"]`); if(el) el.classList.add('hint'); } }
      }
    }

    function onSquareClick(e){
      const idx=parseInt(e.currentTarget.dataset.index,10);
      if(BOARD.selected===null){
        const all=BOARD.chess.moves(); const sq=BOARD.chess.idxToSq(idx);
        if(all.some(m=>m.from===sq)){ BOARD.selected=idx; showHints(); }
      }else{
        const from=BOARD.chess.idxToSq(BOARD.selected); const to=e.currentTarget.dataset.square;
        if(from===to){ BOARD.selected=null; showHints(); return; } // deselect if same square
        let uci = from+to;
        const legal=BOARD.chess.moves().filter(m=>m.from===from && m.to===to);
        if(legal.length){ let move=legal[0]; if(legal.length>1){ const q=legal.find(m=>m.promotion==='q'); if(q) move=q; } if(move.promotion) uci+=move.promotion; }
        const tmp=ChessLite(); tmp.loadFEN(BOARD.current); const mv=tmp.moveUci(uci);
        // Always exit selection; only register + draw if legal
        if(mv.ok){
          drawBoardMain(tmp.fen());
          // clear old arrows, then answer
          BOARD.arrows.showBest=false; BOARD.arrows.user=null; renderArrows();
          try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
          try{ Session.answer(uci); }catch{}
        }
        BOARD.selected=null; showHints();
      }
    }

    // Drag & Drop support
    let DRAG_FROM=null;
    function onDragStart(ev){
      const parent = ev.target.closest('.sq');
      DRAG_FROM = parent?.dataset.square || null;

      // Mark selected and show legal-move dots during drag
      try{
        if(DRAG_FROM){
          BOARD.selected = BOARD.chess.sqToIdx(DRAG_FROM);
          showHints();
        }
      }catch{}

      // Use a custom drag image to avoid dotted placeholders
      try{
        if(ev.dataTransfer){
          const ghost = ev.target.cloneNode(true);
          ghost.style.position='absolute'; ghost.style.top='-1000px';
          document.body.appendChild(ghost);
          ev.dataTransfer.setDragImage(ghost, ghost.offsetWidth/2, ghost.offsetHeight/2);
          setTimeout(()=>document.body.removeChild(ghost),0);
          ev.dataTransfer.setData('text/plain', DRAG_FROM||'');
        }
      }catch{}
    }
    function onDragEnd(){
      DRAG_FROM=null;
      // Clear selection/hints after drag
      BOARD.selected=null; showHints();
    }
    function onDragOver(ev){ ev.preventDefault(); }
    function onDrop(ev){
      ev.preventDefault();
      const to = ev.currentTarget.dataset.square;
      const from = DRAG_FROM || (ev.dataTransfer && ev.dataTransfer.getData('text/plain')) || null;
      if(!from || !to) return;
      if(from===to){ BOARD.selected=null; showHints(); return; } // deselect on same-square drop
      let uci = from+to;
      const legal=BOARD.chess.moves().filter(m=>m.from===from && m.to===to);
      if(legal.length){ let move=legal[0]; if(legal.length>1){ const q=legal.find(m=>m.promotion==='q'); if(q) move=q; } if(move.promotion) uci+=move.promotion; }
      const tmp=ChessLite(); tmp.loadFEN(BOARD.current); const mv=tmp.moveUci(uci);
      if(mv.ok){
        drawBoardMain(tmp.fen());
        BOARD.arrows.showBest=false; BOARD.arrows.user=null; renderArrows();
        try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}
        try{ Session.answer(uci); }catch{}
      }
      BOARD.selected=null; showHints();
    }

    function loadMistakeOnBoard(m){
      if(!m){ drawBoardMain(null); return; }
      gvHide();
      try{
        const cpl = formatCentipawnLoss(m.deltaCp);
        $('#mInfo').innerHTML = `<span class=\"pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}\">${m.severity}</span> Â· centipawn loss: ${cpl}`;
      }catch{}
      $('#mInfo').innerHTML = `<span class="mono">${m.fen.split(' ').slice(0,4).join(' ')}</span> Â· <span class="pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}">${m.severity}</span> Â· ?cp ${Math.round(m.deltaCp)}`;
      $('#yourMove').textContent='â€”'; $('#feedback').textContent='â€”';
      ORIENT_WHITE_BOTTOM = (m.side==='w'); drawBoardMain(m.fen);
      try{
        const cpl = formatCentipawnLoss(m.deltaCp);
        $('#mInfo').innerHTML = `<span class=\"pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}\">${m.severity}</span> Â· centipawn loss: ${cpl}`;
      }catch{}
      // Arrows start clean; will draw on attempt/reveal
      BOARD.arrows.user = null; BOARD.arrows.best = m.best || null; BOARD.arrows.showBest = false; renderArrows();
      try{ $('#btnReveal')?.setAttribute('aria-pressed','false'); $('#btnShowMistake')?.setAttribute('aria-pressed','false'); }catch{}

      // Update info
      try{
        const fenEl=$('#trainFen'); if(fenEl) fenEl.textContent=`FEN: ${m.fen}`;
        const pgnEl=$('#trainPgn'); if(pgnEl) pgnEl.textContent=`PGN: ${m.pgn ? m.pgn.split('\n')[0] : 'â€”'}`;
        const linkEl=$('#trainLink'); if(linkEl){ if(m.gameUrl){ linkEl.textContent='Open game'; linkEl.href=m.gameUrl; } else { linkEl.textContent='â€”'; linkEl.href='#'; } }
      }catch{}
    }

    // Reveal, Show mistake & Next buttons
    $('#btnReveal').addEventListener('click', () => {
      const a=Session.active; if(!a) return;
      const btn=$('#btnReveal');
      const isOn=!!BOARD.arrows.showBest;
      if(isOn){
        BOARD.arrows.showBest=false; renderArrows();
        btn && btn.setAttribute('aria-pressed','false');
        const fb=$('#feedback'); if(fb) fb.textContent='-';
      }else{
        // Revert to original mistake position, then show best arrow
        drawBoardMain(a.fen);
        const bestSan=uciToSAN(a.fen, a.best);
        $('#feedback').innerHTML = `Best move: <b class="mono">${bestSan || a.best}</b>`;
        BOARD.arrows.user=null; BOARD.arrows.best=a.best; BOARD.arrows.showBest=true; renderArrows();
        btn && btn.setAttribute('aria-pressed','true');
        const other=$('#btnShowMistake'); other && other.setAttribute('aria-pressed','false');
      }
    });
    // NEW: Show mistake arrow (red) for the move actually played in the game (toggle)
    $('#btnShowMistake').addEventListener('click', () => {
      const a=Session.active; if(!a) return;
      const btn=$('#btnShowMistake');
      const cl=ChessLite(); cl.loadFEN(a.fen);
      const uci=cl.parseSANtoMove(a.played||'');
      if(!uci){ $('#feedback').textContent='Could not parse recorded mistake.'; return; }
      if(BOARD.arrows.user === uci){
        // toggle off
        BOARD.arrows.user=null; renderArrows();
        btn && btn.setAttribute('aria-pressed','false');
        const fb=$('#feedback'); if(fb) fb.textContent='-';
      }else{
        // toggle on (reset position to original mistake)
        drawBoardMain(a.fen);
        BOARD.arrows.best=null; // only show the user's (mistake) arrow
        BOARD.arrows.user=uci; BOARD.arrows.showBest=false; renderArrows();
        $('#feedback').innerHTML = `Mistake played: <b class="mono">${a.played}</b>`;
        btn && btn.setAttribute('aria-pressed','true');
        const other=$('#btnReveal'); other && other.setAttribute('aria-pressed','false');
      }
    });

    $('#btnNext').addEventListener('click', () => Session.next());
    $('#btnFlip').addEventListener('click', () => { ORIENT_WHITE_BOTTOM=!ORIENT_WHITE_BOTTOM; if(Session.active) drawBoardMain(Session.active.fen); });
    
    $('#btnExitTrain').addEventListener('click', () => {
      showSection('train');
      showTrainSelectionMode();
      renderTrainSelectList();
    });
    
    /********************************************************************
     * Mistake list + Stats
     ********************************************************************/
    // Stats page: set-filtered mistakes list + summary + preview board
    let STATS_SELECTED_SET_ID = null;
    let STATS_CURRENT_LIST = [];
    function renderStatsSetOptions(){
      const sel = $('#statsSetSelect'); if(!sel) return;
      const sets = loadSets();
      sel.innerHTML = '';
      const opt0 = document.createElement('option'); opt0.value=''; opt0.textContent='Select a setâ€¦'; sel.appendChild(opt0);
      for(const s of sets){ const o=document.createElement('option'); o.value=s.id; o.textContent=`${s.name} (${s.keys.length})`; sel.appendChild(o);
      }
      if(STATS_SELECTED_SET_ID){ sel.value = STATS_SELECTED_SET_ID; }
      else if(sets.length){ STATS_SELECTED_SET_ID = sets[0].id; sel.value = STATS_SELECTED_SET_ID; }
      sel.onchange = ()=>{ STATS_SELECTED_SET_ID = sel.value || null; renderStatsMistakeList(); renderStatsSummary(); drawBoardInto('statsBoard', null, true); $('#statsMInfo').textContent='-'; $('#statsSideToMove').textContent='-'; $('#statsBest').textContent='-'; $('#statsDelta').textContent='-'; };
    }

    function renderStatsMistakeList(){
      inferUsernames();
      const tb=$('#statsMistakeTBody'); if(!tb) return;
      try{ const thCp=document.querySelector('#statsMistakeTable thead th:nth-child(6)'); if(thCp) thCp.textContent='centipawn loss'; }catch{}
      tb.innerHTML='';
      const sets = loadSets(); const target = sets.find(s=>s.id===STATS_SELECTED_SET_ID);
      if(!target){ STATS_CURRENT_LIST=[]; $('#statsTotal') && ($('#statsTotal').textContent='0'); $('#statsDue') && ($('#statsDue').textContent='0'); return; }
      const keySet = expandKeys(target.keys||[]);
      const all=filterMistakesToUserOnly(loadMistakes());
      const list=all.filter(m => {
        const ks = keysForMistake(m);
        for(const k of ks){ if(keySet.has(k)) return true; }
        return false;
      });
      STATS_CURRENT_LIST = list;
      list.forEach((m,i)=>{
        const bestSan = m.best ? uciToSAN(m.fen, m.best) : '-';
        const tr=document.createElement('tr');
      tr.innerHTML=`
          <td class="mono tiny">${i+1}</td>
          <td>${m.severity ? `<span class="pill ${m.severity==='blunder'?'blun':(m.severity==='mistake'?'mist':'inacc')}">${m.severity}</span>` : '-'}</td>
          <td>${m.side==='w'?'White':'Black'}</td>
          <td class="mono tiny">${m.played}</td>
          <td class="mono tiny">${bestSan}</td>
          <td class="mono tiny">${formatCentipawnLoss(m.deltaCp)}</td>
          <td class="tiny">${tsToDate(m.nextReview)}</td>`;
        tr.addEventListener('click', ()=>{ loadMistakeOnStatsBoard(m); });
        tb.appendChild(tr);
      });
      const due = pickDueSRS().filter(m => {
        const ks = keysForMistake(m);
        for(const k of ks){ if(keySet.has(k)) return true; }
        return false;
      }).length;
      const totalEl=$('#statsTotal'); if(totalEl) totalEl.textContent=list.length;
      const dueEl=$('#statsDue'); if(dueEl) dueEl.textContent=due;
    }

    function renderStatsSummary(){
      const att=getAttempts(); const n=att.length; const correct=att.filter(a=>a.correct).length; const acc=n?Math.round(100*correct/n):0;
      $('#statsAcc') && ($('#statsAcc').textContent = n ? `${acc}% (${correct}/${n})` : '-');
      $('#statsReviews') && ($('#statsReviews').textContent = String(n));

      const counts={inaccuracy:0,mistake:0,blunder:0};
      for(const m of (STATS_CURRENT_LIST||[])){ if(counts[m.severity]!==undefined) counts[m.severity]++; }
      const canvas=$('#statsSevChart'); if(!canvas) return; const ctx=canvas.getContext('2d'); const W=canvas.width,H=canvas.height;
      ctx.clearRect(0,0,W,H); ctx.fillStyle='#0d0f15'; ctx.fillRect(0,0,W,H);
      const labels=['Inacc','Mistake','Blunder'], keys=['inaccuracy','mistake','blunder']; const maxv=Math.max(1, ...keys.map(k=>counts[k])); const barW=Math.floor((W-80)/3);
      for(let i=0;i<3;i++){ const x=40+i*(barW+20); const v=counts[keys[i]]; const h=Math.round((H-40)*(v/maxv)); ctx.fillStyle=i===0?'#2f9e44':(i===1?'#f2c94c':'#ff6b6b'); ctx.fillRect(x,H-20-h,barW,h); ctx.fillStyle='#9aa4b2'; ctx.font='12px system-ui'; ctx.textAlign='center'; ctx.fillText(labels[i],x+barW/2,H-6); ctx.fillText(String(v),x+barW/2,H-28-h); }
    }

    function loadMistakeOnStatsBoard(m){
      if(!m){ drawBoardInto('statsBoard', null, true); return; }
      $('#statsMInfo').textContent = m.fen.split(' ').slice(0,4).join(' ');
      $('#statsSideToMove').textContent = (m.side==='w')?'White':'Black';
      const bestSan = m.best ? uciToSAN(m.fen, m.best) : '-';
      $('#statsBest').textContent = bestSan || m.best || '-';
      try{ const lbl=$('#statsDelta')?.parentElement?.querySelector('b'); if(lbl) lbl.textContent='centipawn loss:'; }catch{}
      $('#statsDelta').textContent = formatCentipawnLoss(m.deltaCp);
      try{
        const sideUser = userSideForPGN(m.pgn||'');
        const whiteBottom = sideUser ? (sideUser==='w') : true;
        drawBoardInto('statsBoard', m.fen, whiteBottom);
      }catch{
        const whiteBottom = (m.side==='w');
        drawBoardInto('statsBoard', m.fen, whiteBottom);
      }
    }

    /********************************************************************
     * Import controls & toggles
     ********************************************************************/
    let ANALYZE_STATE = { stop:false };
    let LAST_ANALYZED = { mistakes: [], suggestedName: '' };
    const btnAnalyze = $('#btnAnalyzeImported');
    btnAnalyze?.addEventListener('click', async () => {
      if(btnAnalyze.dataset.state!=='running'){
        // start analysis
        btnAnalyze.dataset.state='running';
        btnAnalyze.textContent='Stop analysis';
        btnAnalyze.classList.remove('btn-green'); btnAnalyze.classList.add('btn-red');
        ANALYZE_STATE={stop:false};
        // reset create-set affordance while (re)running (keep visible)
        try{
          LAST_ANALYZED = { mistakes: [], suggestedName: '' };
          const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo');
          if(btn) btn.textContent='Create set (0 mistakes)';
          if(info) info.textContent='-';
        }catch{}
        try{
          const fd = (window.getFastDepth ? window.getFastDepth() : 12);
          setStatus(`Fast pass at depth: ${fd}`);
          setMistakeCounter(0);
        }catch{}
        try{ await (window.analyzeImportedWithBackendAbortable2 ? analyzeImportedWithBackendAbortable2 : analyzeImportedWithBackendAbortable)(ANALYZE_STATE); }catch(e){ setStatus('Error: '+(e?.message||e)); }
        // ensure button reset (in case stop wasn't pressed)
        btnAnalyze.dataset.state='idle';
        btnAnalyze.textContent='Analyse mistakes';
        btnAnalyze.classList.remove('btn-red'); btnAnalyze.classList.add('btn-green');
      }else{
        // stop analysis - immediately revert UI as requested
        ANALYZE_STATE.stop=true;
        btnAnalyze.dataset.state='idle';
        btnAnalyze.textContent='Analyse mistakes';
        btnAnalyze.classList.remove('btn-red'); btnAnalyze.classList.add('btn-green');
      }
    });

    // Create set from last analysis (manual)
    $('#btnCreateSetFromLast')?.addEventListener('click', () => {
      const n = (LAST_ANALYZED && Array.isArray(LAST_ANALYZED.mistakes)) ? LAST_ANALYZED.mistakes.length : 0;
      if(!n){ alert('No mistakes available from the last analysis.'); return; }
      const defName = (LAST_ANALYZED && LAST_ANALYZED.suggestedName) ? LAST_ANALYZED.suggestedName : `Imported ${new Date().toLocaleString()}`;
      const name = prompt(`Enter set name (${n} mistake${n!==1?'s':''})`, defName || 'New Set');
      if(!name) return;
      const set = createSetFromMistakes(LAST_ANALYZED.mistakes, name.trim());
      setStatus(`Created set "${set.name}" with ${set.keys.length} mistake(s).`);
      try{ const info=$('#createSetInfo'); if(info) info.textContent = `Created set "${set.name}" with ${set.keys.length} mistake(s).`; }catch{}
      renderSets(); renderSetsForTrain();
    });

    $('#btnClearImports')?.addEventListener('click', () => {
      const toRemove = new Set((window.importedGames||[]).map(r=>r.pgn));
      // Remove mistakes created from these imports (match by pgn)
      if(toRemove.size){
        let list=loadMistakes();
        list=list.filter(m => !toRemove.has(m.pgn));
        saveMistakes(list);
      }
      // Clear table + viewer + state
      window.importedGames = [];
      try{ if(fb()) fb().clearImportsRemote().catch(()=>{}); }catch{}
      rebuildImportedTable();
      const help=$('#importHelp'); if(help) help.textContent='Imported games cleared.';
      gvHide();
      // reset create-set affordance
      try{
        LAST_ANALYZED = { mistakes: [], suggestedName: '' };
        const btn=$('#btnCreateSetFromLast'); const info=$('#createSetInfo');
        if(btn){ btn.textContent = 'Create set (0 mistakes)'; }
        if(info){ info.textContent='-'; }
      }catch{}
    });

    $('#btnFetchLichess').addEventListener('click', async () => {
      const u=$('#lichessUser').value.trim(); if(!u) return alert('Enter a Lichess username');
      try{ const n=parseInt($('#lichessCount')?.value,10)||5; setStatus(`Fetching Lichess games (N=${n})â€¦`); await fetchLichess(u,n); setStatus('Idle'); }catch(e){ setStatus('Error: '+(e?.message||e)); }
    });

    $('#btnFetchChesscom').addEventListener('click', async () => {
      const u=$('#chesscomUser').value.trim(); if(!u) return alert('Enter a Chess.com username');
      try{ const n=parseInt($('#chesscomCount')?.value,10)||5; setStatus(`Fetching Chess.com games (N=${n})â€¦`); await fetchChesscom(u,n); setStatus('Idle'); }catch(e){ setStatus('Error: '+(e?.message||e)); }
    });

    // Unified import controls
    $('#btnImportUnified')?.addEventListener('click', async () => { try{ const fn=(window.importUnified||importUnified); await fn(); }catch(e){ setStatus('Error: '+(e?.message||e)); } });
    $('#btnImportSettings')?.addEventListener('click', () => {
      const box = document.getElementById('importSettingsBox'); if(!box) return;
      box.style.display = (box.style.display==='none' || !box.style.display) ? 'block' : 'none';
      try{ (window.applyPrefsToUI||applyPrefsToUI)(); }catch{}
    });
    $('#modeCount')?.addEventListener('change', ()=>{ if($('#modeCount').checked){ $('#periodWrap').style.display='none'; $('#countWrap2').style.display='block'; (window.savePrefsLocal||savePrefsLocal)({importMode:'count'}); try{ fb()&&fb().savePrefs({importMode:'count'}); }catch{} } });
    $('#modeTime')?.addEventListener('change', ()=>{ if($('#modeTime').checked){ $('#periodWrap').style.display='block'; $('#countWrap2').style.display='none'; (window.savePrefsLocal||savePrefsLocal)({importMode:'time'}); try{ fb()&&fb().savePrefs({importMode:'time'}); }catch{} } });
    $('#importCount')?.addEventListener('change', ()=>{ const v=parseInt($('#importCount')?.value||'10',10)||10; if($('#importCount2')) $('#importCount2').value=String(v); (window.savePrefsLocal||savePrefsLocal)({importCount:v}); try{ fb()&&fb().savePrefs({importCount:v}); }catch{} });
    $('#importCount2')?.addEventListener('change', ()=>{ const v=parseInt($('#importCount2')?.value||'10',10)||10; if($('#importCount')) $('#importCount').value=String(v); (window.savePrefsLocal||savePrefsLocal)({importCount:v}); try{ fb()&&fb().savePrefs({importCount:v}); }catch{} });
    document.getElementById('periodValue')?.addEventListener('change', ()=>{ const v=document.getElementById('periodValue')?.value; (window.savePrefsLocal||savePrefsLocal)({periodValue:parseFloat(v)||30}); try{ fb()&&fb().savePrefs({periodValue:parseFloat(v)||30}); }catch{} });
    document.getElementById('periodUnit')?.addEventListener('change', ()=>{ const u=document.getElementById('periodUnit')?.value; (window.savePrefsLocal||savePrefsLocal)({periodUnit:u}); try{ fb()&&fb().savePrefs({periodUnit:u}); }catch{} });
    $('#provLichess')?.addEventListener('change', ()=>{ const on=$('#provLichess').checked; (window.savePrefsLocal||savePrefsLocal)({provLichess:on}); try{ fb()&&fb().savePrefs({provLichess:on}); }catch{} });
    $('#provChesscom')?.addEventListener('change', ()=>{ const on=$('#provChesscom').checked; (window.savePrefsLocal||savePrefsLocal)({provChesscom:on}); try{ fb()&&fb().savePrefs({provChesscom:on}); }catch{} });
    $('#accLichess')?.addEventListener('change', ()=>{ const v=$('#accLichess').value.trim(); (window.savePrefsLocal||savePrefsLocal)({lichessUser:v}); try{ fb()&&fb().savePrefs({lichessUser:v}); }catch{}; if($('#lichessUser')) $('#lichessUser').value=v; });
    $('#accChessCom')?.addEventListener('change', ()=>{ const v=$('#accChessCom').value.trim(); (window.savePrefsLocal||savePrefsLocal)({chesscomUser:v}); try{ fb()&&fb().savePrefs({chesscomUser:v}); }catch{}; if($('#chesscomUser')) $('#chesscomUser').value=v; });
    window.addEventListener('firebase:prefsUpdated', applyPrefsToUI);
    $('#btnSaveImportSettings')?.addEventListener('click', async ()=>{
      try{
        const prefs = {
          provLichess: !!($('#provLichess') && $('#provLichess').checked),
          provChesscom: !!($('#provChesscom') && $('#provChesscom').checked),
          importMode: ($('#modeTime') && $('#modeTime').checked) ? 'time' : 'count',
          importCount: parseInt($('#importCount2')?.value||'10',10)||10,
          periodValue: parseFloat(document.getElementById('periodValue')?.value||'30')||30,
          periodUnit: (document.getElementById('periodUnit')?.value||'days'),
          lichessUser: ($('#accLichess')?.value||'').trim(),
          chesscomUser: ($('#accChessCom')?.value||'').trim(),
        };
        (window.savePrefsLocal||savePrefsLocal)(prefs);
        try{ fb() && await fb().savePrefs(prefs); }catch{}
        setStatus('Settings saved.');
        try{ const box=document.getElementById('importSettingsBox'); if(box) box.style.display='none'; }catch{}
      }catch(e){ setStatus('Error: '+(e?.message||e)); }
    });
    $('#btnLinkChessCom')?.addEventListener('click', async ()=>{
      const v=($('#accChessCom')?.value||'').trim(); if(!v) { alert('Enter Chess.com username'); return; }
      (window.savePrefsLocal||savePrefsLocal)({chesscomUser:v}); try{ fb()&&await fb().savePrefs({chesscomUser:v}); }catch{}
      if($('#chesscomUser')) $('#chesscomUser').value=v;
      setStatus('Chess.com account linked.');
    });
    $('#btnLinkLichess')?.addEventListener('click', async ()=>{
      const v=($('#accLichess')?.value||'').trim(); if(!v) { alert('Enter Lichess username'); return; }
      (window.savePrefsLocal||savePrefsLocal)({lichessUser:v}); try{ fb()&&await fb().savePrefs({lichessUser:v}); }catch{}
      if($('#lichessUser')) $('#lichessUser').value=v;
      setStatus('Lichess account linked.');
    });

    // Game viewer controls
    $('#gvPrev')?.addEventListener('click', () => { if(GAMEVIEW.idx>0){ GAMEVIEW.idx--; setTimeout(()=>{ drawBoardInto('gvBoard', GAMEVIEW.fens[GAMEVIEW.idx], GAMEVIEW.whiteBottom); gvUpdate(); }, 0); } });
    $('#gvNext')?.addEventListener('click', () => { if(GAMEVIEW.idx+1<GAMEVIEW.fens.length){ GAMEVIEW.idx++; setTimeout(()=>{ drawBoardInto('gvBoard', GAMEVIEW.fens[GAMEVIEW.idx], GAMEVIEW.whiteBottom); gvUpdate(); }, 0); } });
    $('#gvStart')?.addEventListener('click', () => { GAMEVIEW.idx=0; setTimeout(()=>{ drawBoardInto('gvBoard', GAMEVIEW.fens[GAMEVIEW.idx], GAMEVIEW.whiteBottom); gvUpdate(); }, 0); });
    $('#gvEnd')?.addEventListener('click', () => { GAMEVIEW.idx=Math.max(0,GAMEVIEW.fens.length-1); setTimeout(()=>{ drawBoardInto('gvBoard', GAMEVIEW.fens[GAMEVIEW.idx], GAMEVIEW.whiteBottom); gvUpdate(); }, 0); });

    /********************************************************************
     * Session start buttons
     ********************************************************************/
    $('#btnStart').addEventListener('click', async () => {
      // Ensure a set is active; default to first
      let s = ACTIVE_SET;
      if(!s){ const sets = loadSets(); if(sets.length){ s = sets[0]; setActiveSet(s); } }
      if(!s){ alert('Create or select a set first.'); return; }

      // Enter training mode and wait for mistakes to be available
      enterTrainingMode();
      renderActiveSetInfo();
      try{ const info=document.getElementById('mInfo'); if(info) info.textContent='Loading set.'; }catch{}
      try{ await ensureMistakesForSet(s, 10000); }catch{}

      const mode=$('#modeSel').value;
      if(mode==='woodpecker'){ const N=parseInt($('#wpCount').value,10)||10; Session.startWoodpecker(N); }
      else{ Session.startSRS(); }
    });
    $('#modeSel').addEventListener('change', () => { $('#wpCountWrap').style.display = ($('#modeSel').value==='woodpecker') ? 'block' : 'none'; });

    /********************************************************************
     * Init + preferences + nav
     ********************************************************************/
    (async function init(){
      // prefs
      try{
        const bs = localStorage.getItem('pmtt_board_size');
        const curDefault = parseInt((getComputedStyle(document.documentElement).getPropertyValue('--board-size')||'520').replace('px',''))||520;
        const cur = bs ? parseInt(bs,10) : curDefault;
        applyBoardSize(cur);
      }catch{}

      // apply unified import prefs
      try{ (window.applyPrefsToUI||applyPrefsToUI)(); }catch{}

      rebuildImportedTable();
      renderStatsSetOptions(); renderStatsMistakeList(); renderStatsSummary(); renderSets(); renderSetsForTrain(); renderActiveSetInfo();
      drawBoardMain(null);
      setStatus('Loading engineâ€¦'); await Engine.ensure(); setStatus('Idle');
      // keep boards/arrows sized when window resizes
      window.addEventListener('resize', ()=>{
        try{ CB.main && CB.main.resize(); }catch{}
        try{ Object.values(CB.extras||{}).forEach(b=>{ try{ b && b.resize && b.resize(); }catch{} }); }catch{}
        setBoardFonts();
      });

      // Enable board drag-resize via the corner handle
      setupBoardResizeHandle();
      // Engine toggle handlers
      try{
        const tog=$('#engineToggle');
        tog && tog.addEventListener('change', ()=>{ if(tog.checked){ EngineLive.enable(); if(BOARD.current) EngineLive.analyzeDebounced(BOARD.current); } else { EngineLive.disable(); } });
        // MultiPV stepper
// Removed inline Lines +/- controls; configure via Engine settings modal
      }catch{}
    })();

    // Board size preference
    function applyBoardSize(v){
      // Allow large sizes so fullscreen resizing isn't capped artificially
      const hi = 2400; // upper bound; final width still limited by layout (min(100%, var(--board-size)))
      const size = Math.max(320, Math.min(hi, parseInt(v,10)||520));
      document.documentElement.style.setProperty('--board-size', size+'px');
      const lbl=$('#boardSizeVal'); if(lbl) lbl.textContent = `(${size})`;
      localStorage.setItem('pmtt_board_size', String(size));
      try{ CB.main && CB.main.resize(); }catch{}
      try{ Object.values(CB.extras||{}).forEach(b=>{ try{ b && b.resize && b.resize(); }catch{} }); }catch{}
      setBoardFonts();
      renderArrows();
    }
    // Train page: selection list (click to start training)
    function renderTrainSelectList(){
      const tb = $('#trainSelectTBody'); if(!tb) return;
      tb.innerHTML='';
      const sets = loadSets(); let i=0;
      for(const s of sets){
        const tr = document.createElement('tr');
        tr.style.cursor='pointer';
        tr.innerHTML = `<td>${++i}</td><td>${s.name}</td><td>${s.keys.length}</td><td><button class="ghost" data-id="${s.id}">Train</button></td>`;
        const start = async ()=>{ setActiveSet(s); enterTrainingMode(); renderActiveSetInfo(); try{ const info=document.getElementById('mInfo'); if(info) info.textContent='Loading set.'; }catch{}; try{ await ensureMistakesForSet(s, 10000); }catch{}; Session.startSRS(); };
        tr.addEventListener('click', (ev)=>{ if((ev.target && ev.target.tagName==='BUTTON')) return; start(); });
        tr.querySelector('button')?.addEventListener('click', (ev)=>{ ev.stopPropagation(); start(); });
        tb.appendChild(tr);
      }
    }

    function enterTrainingMode(){
      const sec = document.getElementById('trainSection'); if(!sec) return;
      sec.classList.add('training-mode');
      try{ gvHide(); }catch{}
      setTimeout(()=>{ try{ ensureMainBoard(); CB.main && CB.main.resize(); }catch{} setBoardFonts(); renderArrows(); }, 0);
    }
    function showTrainSelectionMode(){
      const sec = document.getElementById('trainSection'); if(!sec) return;
      sec.classList.remove('training-mode');
      try{ drawBoardMain(null); }catch{}
    }
    // Pointer-based resize on the corner handle
    function setupBoardResizeHandle(){
      const handle = document.getElementById('resizeHandle');
      const boardEl = document.getElementById('trainBoard');
      if(!handle || !boardEl) return;
      let startRect=null, active=false, mode='corner';
      const CORNER=12; // px inside bottom-right corner considered resizable zone

      const onMove = (ev)=>{
        if(!active) return;
        const t = ev.touches && ev.touches[0];
        const clientX = (t ? t.clientX : ev.clientX) ?? 0;
        const clientY = (t ? t.clientY : ev.clientY) ?? 0;
        const r = startRect || boardEl.getBoundingClientRect();
        let targetPx = 0;
        if(mode==='right') targetPx = clientX - r.left;
        else if(mode==='bottom') targetPx = clientY - r.top;
        else targetPx = Math.max(clientX - r.left, clientY - r.top);
        const next = Math.round(targetPx);
        applyBoardSize(next);
      };
      const end = ()=>{
        if(!active) return;
        active=false;
        window.removeEventListener('pointermove', onMove);
        window.removeEventListener('pointerup', end);
        window.removeEventListener('touchmove', onMove);
        window.removeEventListener('touchend', end);
        try{ document.body.style.userSelect=''; document.body.style.cursor=''; boardEl.classList.remove('resize-corner-hover'); }catch{}
      };
      handle.addEventListener('pointerdown', (ev)=>{
        ev.preventDefault();
        ev.stopPropagation();
        active=true;
        startRect = boardEl.getBoundingClientRect(); mode='corner';
        try{ handle.setPointerCapture && handle.setPointerCapture(ev.pointerId); }catch{}
        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', end, {passive:false});
        try{ document.body.style.userSelect='none'; document.body.style.cursor='nwse-resize'; }catch{}
      });
      // Basic touch support
      handle.addEventListener('touchstart', (ev)=>{
        const t = ev.touches && ev.touches[0]; if(!t) return;
        ev.preventDefault(); ev.stopPropagation(); active=true;
        startRect = boardEl.getBoundingClientRect(); mode='corner';
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', end);
        try{ document.body.style.userSelect='none'; document.body.style.cursor='nwse-resize'; }catch{}
      }, {passive:false});

      // Only allow grabbing from the very bottom-right corner
      const zoneAt = (clientX, clientY)=>{
        const r = boardEl.getBoundingClientRect();
        const nearRight = (r.right - clientX) >= 0 && (r.right - clientX) <= CORNER;
        const nearBottom = (r.bottom - clientY) >= 0 && (r.bottom - clientY) <= CORNER;
        const inside = clientX >= r.left && clientX <= r.right && clientY >= r.top && clientY <= r.bottom;
        if(inside && nearRight && nearBottom) return 'corner';
        return null;
      };
      // Disable outside-board initiation
      const zoneAtExtended = (_x, _y)=> null;
      const hoverCheck = (ev)=>{
        if(active) return;
        const cx = ev.clientX ?? 0, cy = ev.clientY ?? 0;
        if(zoneAt(cx, cy)) boardEl.classList.add('resize-corner-hover');
        else boardEl.classList.remove('resize-corner-hover');
      };
      const startFromCorner = (ev)=>{
        const t = ev.touches && ev.touches[0];
        const cx = (t ? t.clientX : ev.clientX) ?? 0;
        const cy = (t ? t.clientY : ev.clientY) ?? 0;
        const z = zoneAt(cx, cy); if(!z) return;
        ev.preventDefault(); ev.stopPropagation();
        active=true; mode=z; startRect = boardEl.getBoundingClientRect();
        try{ boardEl.setPointerCapture && boardEl.setPointerCapture(ev.pointerId); }catch{}
        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', end, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', end);
        try{ document.body.style.userSelect='none'; document.body.style.cursor='nwse-resize'; }catch{}
      };
      // Use capture to intercept before piece drag begins
      boardEl.addEventListener('pointermove', hoverCheck, true);
      boardEl.addEventListener('pointerleave', ()=> boardEl.classList.remove('resize-corner-hover'));
      boardEl.addEventListener('pointerdown', startFromCorner, true);
      boardEl.addEventListener('touchstart', startFromCorner, {passive:false, capture:true});
      boardEl.addEventListener('dragstart', (ev)=>{ if(active) { ev.preventDefault(); ev.stopPropagation(); } }, true);

      // Also listen on the document to catch clicks just outside the board corner/edges
      const docStart = (ev)=>{
        if(active) return;
        const t = ev.touches && ev.touches[0];
        const cx = (t ? t.clientX : ev.clientX) ?? 0;
        const cy = (t ? t.clientY : ev.clientY) ?? 0;
        const z = zoneAtExtended(cx, cy);
        if(!z) return;
        ev.preventDefault(); ev.stopPropagation();
        active=true; mode=z; startRect = boardEl.getBoundingClientRect();
        try{ document.body.style.userSelect='none'; document.body.style.cursor='nwse-resize'; }catch{}
        window.addEventListener('pointermove', onMove, {passive:false});
        window.addEventListener('pointerup', end, {passive:false});
        window.addEventListener('touchmove', onMove, {passive:false});
        window.addEventListener('touchend', end);
      };
      document.addEventListener('pointerdown', docStart, true);
      document.addEventListener('touchstart', docStart, {passive:false, capture:true});
    }

  </script>

  <script>
    // Analysis settings modal
    (function(){
      const LS_DEPTH = 'pmtt_an_depth';
      const LS_FLAGS = 'pmtt_sev_flags'; // {inacc:boolean, mistake:boolean, blunder:boolean}
      const LS_SEV = 'pmtt_sev'; // thresholds object {inacc, mistake, blunder}

      function loadDepth(){
        try{
          const v = localStorage.getItem(LS_DEPTH);
          if(v!=null) return Math.max(6, Math.min(40, parseInt(v,10)||12));
        }catch{}
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          const d = p && p.analysisDepth;
          if(d!=null) return Math.max(6, Math.min(40, parseInt(d,10)||12));
        }catch{}
        return 12;
      }
      function saveDepth(n){ try{ localStorage.setItem(LS_DEPTH, String(Math.max(6, Math.min(40, parseInt(n,10)||12)))); }catch{} }
      function loadFlags(){
        try{
          const o=JSON.parse(localStorage.getItem(LS_FLAGS)||'{}');
          return { inacc: o.inacc!==false, mistake: o.mistake!==false, blunder: o.blunder!==false };
        }catch{}
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          const o = p && p.analysisInclude;
          if(o && typeof o==='object') return { inacc: o.inacc!==false, mistake: o.mistake!==false, blunder: o.blunder!==false };
        }catch{}
        return {inacc:true, mistake:true, blunder:true};
      }
      function saveFlags(f){ try{ localStorage.setItem(LS_FLAGS, JSON.stringify({ inacc:!!f.inacc, mistake:!!f.mistake, blunder:!!f.blunder })); }catch{} }
      function loadSev(){
        try{
          const d=JSON.parse(localStorage.getItem(LS_SEV)||'{}');
          const base = { inacc: Number.isFinite(d.inacc)?d.inacc:50, mistake: Number.isFinite(d.mistake)?d.mistake:150, blunder: Number.isFinite(d.blunder)?d.blunder:300 };
          return base;
        }catch{}
        try{
          const p = (window.getPrefs ? window.getPrefs() : {});
          const t = p && p.analysisThresholds;
          if(t && typeof t==='object') return { inacc: Number.isFinite(t.inacc)?t.inacc:50, mistake: Number.isFinite(t.mistake)?t.mistake:150, blunder: Number.isFinite(t.blunder)?t.blunder:300 };
        }catch{}
        return {inacc:50, mistake:150, blunder:300};
      }
      function saveSev(t){ try{ localStorage.setItem(LS_SEV, JSON.stringify({ inacc:Math.max(0,parseInt(t.inacc,10)||50), mistake:Math.max(0,parseInt(t.mistake,10)||150), blunder:Math.max(0,parseInt(t.blunder,10)||300) })); }catch{} }

      function includeSeverity(sev){
        try{
          const f = loadFlags();
          if(sev==='inaccuracy') return !!f.inacc;
          if(sev==='mistake') return !!f.mistake;
          if(sev==='blunder') return !!f.blunder;
          return true;
        }catch{ return true; }
      }
      window.includeSeverity = includeSeverity;

      // Modal DOM
      const modal = document.createElement('div');
      modal.id = 'anSettingsModal';
      modal.style.display = 'none';
      modal.innerHTML = `
        <div id="anSettingsBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:50"></div>
        <div style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:51">
          <div class="card" style="width:min(560px, 95vw); max-height:90vh; overflow:auto">
            <div style="display:flex;align-items:center;gap:10px;justify-content:space-between">
              <h2>Analysis Settings</h2>
              <button id="anSettingsClose" class="ghost" title="Close">✕</button>
            </div>
            <div id="anSettingsCloud" class="tiny muted" style="margin-top:4px; display:flex; align-items:center; gap:8px">-</div>
            <div class="row" style="margin-top:8px">
              <div style="max-width:140px">
                <label>Depth</label>
                <input id="anDepth" type="number" min="6" max="40" value="12" />
              </div>
              <div class="stroke" style="flex:1">
                <div class="small"><b>Classify by centipawn loss</b></div>
                <div class="grid-2" style="margin-top:6px; gap:10px">
                  <div>
                    <label>Inaccuracy ≥</label>
                    <input id="sevInacc" type="number" min="0" step="1" value="50" />
                  </div>
                  <div>
                    <label>Mistake ≥</label>
                    <input id="sevMistake" type="number" min="0" step="1" value="150" />
                  </div>
                  <div>
                    <label>Blunder ≥</label>
                    <input id="sevBlunder" type="number" min="0" step="1" value="300" />
                  </div>
                </div>
              </div>
            </div>
            <div class="stroke" style="margin-top:10px">
              <div class="small"><b>Include severities</b></div>
              <div class="row" style="margin-top:6px">
                <label style="display:flex;align-items:center;gap:6px"><input id="incInacc" type="checkbox" checked /> Inaccuracies</label>
                <label style="display:flex;align-items:center;gap:6px"><input id="incMistake" type="checkbox" checked /> Mistakes</label>
                <label style="display:flex;align-items:center;gap:6px"><input id="incBlunder" type="checkbox" checked /> Blunders</label>
              </div>
            </div>
            <div class="row" style="margin-top:12px; justify-content:flex-end">
              <button id="anSettingsReset" class="ghost">Reset</button>
              <button id="anSettingsSave" class="secondary">Save</button>
            </div>
          </div>
        </div>`;
      document.body.appendChild(modal);

      function fillFromPrefs(){
        try{
          const depth = loadDepth();
          const t = loadSev();
          const f = loadFlags();
          const dEl=document.getElementById('anDepth'); if(dEl) dEl.value=String(depth);
          const si=document.getElementById('sevInacc'); if(si) si.value=String(t.inacc);
          const sm=document.getElementById('sevMistake'); if(sm) sm.value=String(t.mistake);
          const sb=document.getElementById('sevBlunder'); if(sb) sb.value=String(t.blunder);
          const ci=document.getElementById('incInacc'); if(ci) ci.checked=!!f.inacc;
          const cm=document.getElementById('incMistake'); if(cm) cm.checked=!!f.mistake;
          const cb=document.getElementById('incBlunder'); if(cb) cb.checked=!!f.blunder;
        }catch{}
      }
      let prefsListener=null;
      function updateCloudStatus(){
        try{
          const el = document.getElementById('anSettingsCloud'); if(!el) return;
          const u = (window.firebaseUser || null);
          const signedIn = !!u && !u.isAnonymous;
          const btn = '<button id="anSettingsSignIn" class="ghost small">' + (signedIn ? 'Switch account' : 'Sign in') + '</button>';
          el.innerHTML = signedIn ? ('Cloud sync: ' + (u.email||u.displayName||'account') + ' ' + btn) : ('Cloud sync: signed out. ' + btn);
          const b=document.getElementById('anSettingsSignIn'); if(b){ b.addEventListener('click', ()=>{ try{ document.getElementById('btnAuth')?.click(); }catch{} }); }
        }catch{}
      }
      function open(){
        fillFromPrefs();
        updateCloudStatus();
        // Update once remote prefs arrive
        try{
          prefsListener = ()=>{ try{ fillFromPrefs(); updateCloudStatus(); }catch{} };
          window.addEventListener('firebase:prefsUpdated', prefsListener);
          // Safety: also refresh after a short delay
          setTimeout(()=>{ try{ fillFromPrefs(); updateCloudStatus(); }catch{} }, 800);
        }catch{}
        modal.style.display = 'block';
      }
      function close(){
        modal.style.display = 'none';
        try{ if(prefsListener){ window.removeEventListener('firebase:prefsUpdated', prefsListener); prefsListener=null; } }catch{}
      }
      function reset(){ try{ localStorage.removeItem(LS_DEPTH); localStorage.removeItem(LS_FLAGS); localStorage.removeItem(LS_SEV); }catch{} open(); }
      function save(){
        const depth = parseInt(document.getElementById('anDepth').value,10)||12; saveDepth(depth);
        const t = { inacc: parseInt(document.getElementById('sevInacc').value,10)||50,
                    mistake: parseInt(document.getElementById('sevMistake').value,10)||150,
                    blunder: parseInt(document.getElementById('sevBlunder').value,10)||300 };
        saveSev(t);
        const f = { inacc: !!document.getElementById('incInacc').checked,
                    mistake: !!document.getElementById('incMistake').checked,
                    blunder: !!document.getElementById('incBlunder').checked };
        saveFlags(f);
        // Persist to unified prefs in Firestore as well (only if signed in)
        try{
          const payload = { analysisDepth: depth, analysisThresholds: t, analysisInclude: f };
          if(window.savePrefsLocal) window.savePrefsLocal(payload);
          if(window.firebaseAPI && window.firebaseAPI.ready && window.firebaseAPI.savePrefs){ window.firebaseAPI.savePrefs(payload).catch(()=>{}); }
        }catch{}
        close();
      }
      document.getElementById('btnAnalyzeSettings')?.addEventListener('click', open);
      document.getElementById('anSettingsBackdrop')?.addEventListener('click', close);
      document.getElementById('anSettingsClose')?.addEventListener('click', close);
      document.getElementById('anSettingsReset')?.addEventListener('click', reset);
      document.getElementById('anSettingsSave')?.addEventListener('click', save);

      // Expose helpers used below
      window.getAnalysisDepth = loadDepth;
      window.getFastDepth = function(){ return 12; };
    })();

    // Add-to-existing-set modal
    (function(){
      const LS_SETS = 'pmtt_sets';
      const loadSetsLocal = () => { try{ return JSON.parse(localStorage.getItem(LS_SETS)||'[]'); }catch{return [];} };
      const saveSetsLocal = (arr) => { try{ localStorage.setItem(LS_SETS, JSON.stringify(arr)); }catch{} try{ window.firebaseAPI && window.firebaseAPI.saveAllSets && window.firebaseAPI.saveAllSets(arr).catch(()=>{}); }catch{} try{ renderSets && renderSets(); renderSetsForTrain && renderSetsForTrain(); renderTrainSelectList && renderTrainSelectList(); }catch{} };
      const keyOf = (m) => ((m&&m.fen)||'' ) + '|' + ((m&&m.played)||'');

      // Modal DOM
      const modal = document.createElement('div');
      modal.id = 'addToSetModal';
      modal.style.display = 'none';
      modal.innerHTML = `
        <div id="atsBackdrop" style="position:fixed;inset:0;background:rgba(0,0,0,.55);backdrop-filter:blur(2px);z-index:50"></div>
        <div style="position:fixed;inset:0;display:flex;align-items:center;justify-content:center;z-index:51">
          <div class="card" style="width:min(620px,95vw); max-height:90vh; overflow:auto">
            <div style="display:flex;align-items:center;gap:10px;justify-content:space-between">
              <h2>Add to existing set</h2>
              <button id="atsClose" class="ghost" title="Close">✕</button>
            </div>
            <div id="atsInfo" class="tiny muted" style="margin-top:6px">-</div>
            <div style="max-height:50vh;overflow:auto;border:1px dashed #2a3142;border-radius:10px;margin-top:8px">
              <table style="width:100%">
                <thead><tr><th>Name</th><th>Count</th><th>Add</th></tr></thead>
                <tbody id="atsTBody"></tbody>
              </table>
            </div>
            <div class="row" style="margin-top:10px; justify-content:flex-end">
              <button id="atsCancel" class="ghost">Cancel</button>
            </div>
          </div>
        </div>`;
      document.body.appendChild(modal);

      function close(){ modal.style.display='none'; }
      // Choose source mistakes: prefer LAST_ANALYZED; fallback to mistakes linked to current imports; else all mistakes
      function getAddCandidates(){
        try{
          const la = (window.LAST_ANALYZED && Array.isArray(window.LAST_ANALYZED.mistakes)) ? window.LAST_ANALYZED.mistakes : [];
          if(la.length) return la;
          const all = (typeof loadMistakes==='function') ? loadMistakes() : [];
          const imports = Array.isArray(window.importedGames) ? window.importedGames : [];
          const importPgns = new Set(imports.map(r=>r && r.pgn).filter(Boolean));
          const byImport = all.filter(m => m && m.pgn && importPgns.has(m.pgn));
          if(byImport.length) return byImport;
          return all;
        }catch{ return []; }
      }
      function open(){
        const cand = getAddCandidates();
        const n = cand.length;
        const info = document.getElementById('atsInfo');
        if(info){
          if(n){
            const laCount = (window.LAST_ANALYZED && Array.isArray(window.LAST_ANALYZED.mistakes)) ? window.LAST_ANALYZED.mistakes.length : 0;
            info.textContent = laCount ? `Last analysis: ${n} mistake(s) ready to add.` : `Using detected mistakes: ${n} item(s).`;
          } else {
            info.textContent = 'No mistakes available. Run Analyse mistakes first.';
          }
        }
        const tb = document.getElementById('atsTBody'); if(tb) tb.innerHTML='';
        const sets = loadSetsLocal();
        if(!sets.length){
          const tr=document.createElement('tr'); tr.innerHTML='<td colspan="3" class="tiny muted">No sets found. Create a set first.</td>'; tb && tb.appendChild(tr);
        } else {
          const newKeys = new Set(cand.map(keyOf));
          for(const s of sets){
            const existing = new Set((s.keys||[]));
            let addCount=0; for(const k of newKeys){ if(!existing.has(k)) addCount++; }
            const tr=document.createElement('tr');
            tr.innerHTML = `<td>${s.name}</td><td>${(s.keys||[]).length}</td><td><button class="ghost" data-setid="${s.id}" ${(!n||addCount===0)?'disabled':''}>Add to set${addCount?` (+${addCount})`:''}</button></td>`;
            tr.querySelector('button')?.addEventListener('click', ()=>{
              const sets2 = loadSetsLocal();
              const idx = sets2.findIndex(x=>x.id===s.id);
              if(idx<0) return;
              const ex = new Set((sets2[idx].keys||[]));
              let added=0; for(const k of newKeys){ if(!ex.has(k)){ ex.add(k); added++; } }
              sets2[idx].keys = Array.from(ex);
              saveSetsLocal(sets2);
              setStatus(`Added ${added} item(s) to set "${sets2[idx].name}".`);
              try{ const el=document.getElementById('createSetInfo'); if(el) el.textContent = `Added ${added} item(s) to "${sets2[idx].name}"`; }catch{}
              close();
            });
            tb && tb.appendChild(tr);
          }
        }
        modal.style.display='block';
      }

      document.getElementById('btnAddToExistingSet')?.addEventListener('click', open);
      document.getElementById('atsBackdrop')?.addEventListener('click', close);
      document.getElementById('atsClose')?.addEventListener('click', close);
      document.getElementById('atsCancel')?.addEventListener('click', close);
    })();
    // Simple SPA nav
    function showSection(which){
      const map = { home:'homeSection', analyze:'analyzeSection', stats:'statsSection', sets:'setsSection', train:'trainSection' };
      Object.values(map).forEach(id => document.getElementById(id)?.classList.remove('active'));
      document.getElementById(map[which]||'homeSection')?.classList.add('active');
      document.getElementById('navHome')?.classList.toggle('active', which==='home');
      document.getElementById('navAnalyze')?.classList.toggle('active', which==='analyze');
      document.getElementById('navStats')?.classList.toggle('active', which==='stats');
      document.getElementById('navSets')?.classList.toggle('active', which==='sets');
      document.getElementById('navTrain')?.classList.toggle('active', which==='train');
      if(which==='train' || which==='stats'){
        setTimeout(()=>{
          try{ ensureMainBoard(); CB.main && CB.main.resize(); if(BOARD.current) CB.main.position(BOARD.current, false); else CB.main.clear(true); }catch{}
          try{ Object.values(CB.extras||{}).forEach(b=>{ try{ b && b.resize && b.resize(); }catch{} }); }catch{}
          setBoardFonts();
          renderArrows();
        }, 50);
      }
    }
    document.getElementById('navHome')?.addEventListener('click', (e)=>{ e.preventDefault(); showSection('home'); });
    document.getElementById('navAnalyze')?.addEventListener('click', (e)=>{ e.preventDefault(); showSection('analyze'); });
    document.getElementById('navStats')?.addEventListener('click', (e)=>{ e.preventDefault(); renderStatsSetOptions(); renderStatsMistakeList(); renderStatsSummary(); showSection('stats'); try{ const lbl=document.querySelector('#statsDelta')?.parentElement?.querySelector('b'); if(lbl) lbl.textContent='centipawn loss:'; }catch{} });
    document.getElementById('navSets')?.addEventListener('click', (e)=>{ e.preventDefault(); renderSets(); showSection('sets'); });
    document.getElementById('navTrain')?.addEventListener('click', (e)=>{
      e.preventDefault();
      showSection('train');
      showTrainSelectionMode();
      renderTrainSelectList();
    });
    document.getElementById('btnGoAnalyze')?.addEventListener('click', ()=> showSection('analyze'));

    // Sets page actions (create empty set, de-duped by name+content)
    document.getElementById('btnCreateEmptySet')?.addEventListener('click', ()=>{
      const el=document.getElementById('newSetName');
      const name=(el && el.value ? el.value.trim() : '') || `Set ${new Date().toLocaleString()}`;
      createSetFromMistakes([], name); renderSets();
    });
  </script>
</body>
</html>



























